{
  "assignments": [
    {
      "track": "clojure",
      "slug": "bob",
      "files": {
        "bob_test.clj": "(ns bob.test (:require [clojure.test :refer :all]))\n(load-file \"bob.clj\")\n\n(deftest responds-to-something\n  (is (= \"Whatever.\" (bob/response-for \"Tom-ay-to, tom-aaaah-to.\"))))\n\n(deftest responds-to-shouts\n  (is (= \"Woah, chill out!\" (bob/response-for \"WATCH OUT!\"))))\n\n(deftest responds-to-questions\n  (is (= \"Sure.\" (bob/response-for \"Does this cryogenic chamber make me look fat?\"))))\n\n(deftest responds-to-forceful-talking\n  (is (= \"Whatever.\" (bob/response-for \"Let's go make out behind the gym!\"))))\n\n(deftest responds-to-acronyms\n  (is (= \"Whatever.\" (bob/response-for \"It's OK if you don't want to go to the DMV.\"))))\n\n(deftest responds-to-forceful-questions\n  (is (= \"Woah, chill out!\" (bob/response-for \"WHAT THE HELL WERE YOU THINKING?\"))))\n\n(deftest responds-to-shouting-with-special-characters\n  (is (= \"Woah, chill out!\" (bob/response-for \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\"))))\n\n(deftest responds-to-shouting-numbers\n  (is (= \"Woah, chill out!\" (bob/response-for \"1, 2, 3 GO!\"))))\n\n(deftest responds-to-shouting-with-no-exclamation-mark\n  (is (= \"Woah, chill out!\" (bob/response-for \"I HATE YOU\"))))\n\n(deftest responds-to-statement-containing-question-mark\n  (is (= \"Whatever.\" (bob/response-for \"Ending with ? means a question.\"))))\n\n(deftest responds-to-silence\n  (is (= \"Fine. Be that way!\" (bob/response-for \"\"))))\n\n(deftest responds-to-prolonged-silence\n  (is (= \"Fine. Be that way!\" (bob/response-for \"    \"))))\n\n(deftest responds-to-only-numbers\n  (is (= \"Whatever.\" (bob/response-for \"1, 2, 3\"))))\n\n(deftest responds-to-number-question\n  (is (= \"Sure.\" (bob/response-for \"4?\"))))\n\n(run-tests)\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Woah, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying anything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the first test to pass, go to the first pending or skipped test, and make that pass as well. When all of the tests are passing, feel free to submit.\n\nRemember that passing code is just the first step. The goal is to work towards a solution that is as readable and expressive as you can make it.\n\nPlease make your solution as general as possible. Good code doesn't just pass the test suite, it works with any input that fits the specification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "coffeescript",
      "slug": "bob",
      "files": {
        "bob_test.spec.coffee": "Bob = require \"./bob\"\ndescribe \"Bob\", ->\n  bob = new Bob()\n  it \"stating something\", ->\n    result = bob.hey \"Tom-ay-to, tom-aaaah-to.\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"shouting\", ->\n    result = bob.hey \"WATCH OUT!\"\n    expect(result).toEqual \"Woah, chill out!\"\n\n  xit \"asking a question\", ->\n    result = bob.hey \"Does this cryogenic chamber make me look fat?\"\n    expect(result).toEqual \"Sure.\"\n\n  xit \"talking forcefully\", ->\n    result = bob.hey \"Let's go make out behind the gym!\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"using acronyms in regular speech\", ->\n    result = bob.hey \"It's OK if you don't want to go to the DMV.\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"forceful questions\", ->\n    result = bob.hey \"WHAT THE HELL WERE YOU THINKING?\"\n    expect(result).toEqual \"Woah, chill out!\"\n\n  xit \"shouting numbers\", ->\n    result = bob.hey \"1, 2, 3 GO!\"\n    expect(result).toEqual \"Woah, chill out!\"\n\n  xit \"shouting with special characters\", ->\n    result = bob.hey \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\"\n    expect(result).toEqual \"Woah, chill out!\"\n\n  xit \"shouting with no exclamation mark\", ->\n    result = bob.hey \"I HATE YOU\"\n    expect(result).toEqual \"Woah, chill out!\"\n\n  xit \"statement containing question mark\", ->\n    result = bob.hey \"Ending with a ? means a question.\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"prattling on\", ->\n    result = bob.hey \"Wait! Hang on.  Are you going to be OK?\"\n    expect(result).toEqual \"Sure.\"\n\n  xit \"silence\", ->\n    result = bob.hey \"\"\n    expect(result).toEqual \"Fine. Be that way!\"\n\n  xit \"prolonged silence\", ->\n    result = bob.hey \"   \"\n    expect(result).toEqual \"Fine. Be that way!\"\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Woah, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying anything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the first test to pass, go to the first pending or skipped test, and make that pass as well. When all of the tests are passing, feel free to submit.\n\nRemember that passing code is just the first step. The goal is to work towards a solution that is as readable and expressive as you can make it.\n\nPlease make your solution as general as possible. Good code doesn't just pass the test suite, it works with any input that fits the specification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "csharp",
      "slug": "leap",
      "files": {
        "LeapTest.cs": "using NUnit.Framework;\n\n[TestFixture]\npublic class LeapTest\n{\n    [Test]\n    public void Valid_leap_year()\n    {\n        Assert.That(Year.IsLeap(1996), Is.True);\n    }\n\n    [Test, Ignore]\n    public void Invalid_leap_year()\n    {\n        Assert.That(Year.IsLeap(1997), Is.False);\n    }\n\n    [Test, Ignore]\n    public void Turn_of_the_20th_century_is_not_a_leap_year()\n    {\n        Assert.That(Year.IsLeap(1900), Is.False);\n    }\n\n    [Test, Ignore]\n    public void Turn_of_the_25th_century_is_a_leap_year()\n    {\n        Assert.That(Year.IsLeap(2400), Is.True);\n    }\n}",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.\n1900 is not a leap year, but 2000 is.\n\nIf your language provides a method in the standard library that does this\nlook-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year phenomenon, go watch [this youtube video](http://www.youtube.com/watch?v=xX96xng7sAE).\n\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": true,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "elixir",
      "slug": "bob",
      "files": {
        "bob.exs": "defmodule Teenager do\n  def hey(input) do\n    cond do\n\n    end\n  end\nend\n",
        "bob_test.exs": "if System.get_env(\"EXERCISM_TEST_EXAMPLES\") do\n  Code.load_file(\"example.exs\")\nelse\n  Code.load_file(\"bob.exs\")\nend\n\nExUnit.start\n\ndefmodule TeenagerTest do\n  use ExUnit.Case, async: true\n  doctest Teenager\n\n  test \"stating something\" do\n    assert Teenager.hey(\"Tom-ay-to, tom-aaaah-to.\") == \"Whatever.\"\n  end\n\n  test \"shouting\" do\n    # assert Teenager.hey(\"WATCH OUT!\") == \"Woah, chill out!\"\n  end\n\n  test \"asking a question\" do\n    # assert Teenager.hey(\"Does this cryogenic chamber make me look fat?\") == \"Sure.\"\n  end\n\n  test \"talking forcefully\" do\n    # assert Teenager.hey(\"Let's go make out behind the gym!\") == \"Whatever.\"\n  end\n\n  test \"talking in capitals\" do\n    # assert Teenager.hey(\"This Isn't Shouting!\") == \"Whatever.\"\n  end\n\n  test \"shouting numbers\" do\n    # assert Teenager.hey(\"1, 2, 3 GO!\") == \"Woah, chill out!\"\n  end\n\n  test \"shouting with special characters\" do\n    # assert Teenager.hey(\"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\") == \"Woah, chill out!\"\n  end\n\n  test \"shouting with no exclamation mark\" do\n    # assert Teenager.hey(\"I HATE YOU\") == \"Woah, chill out!\"\n  end\n\n  test \"statement containing question mark\" do\n    # assert Teenager.hey(\"Ending with ? means a question.\") == \"Whatever.\"\n  end\n\n  test \"silence\" do\n    # assert Teenager.hey(\"\") == \"Fine. Be that way!\"\n  end\n\n  test \"prolonged silence\" do\n    # assert Teenager.hey(\"  \") == \"Fine. Be that way!\"\n  end\n\n  test \"only numbers\" do\n    # assert Teenager.hey(\"1, 2, 3\") == \"Whatever.\"\n  end\n\n  test \"question with numbers\" do\n    # assert Teenager.hey(\"4?\") == \"Sure.\"\n  end\n\n  test \"shouting in Russian\" do\n    # Hopefully this is Russian for \"get out\"\n    # assert Teenager.hey(\"УХОДИТЬ\") == \"Woah, chill out!\"\n  end\nend\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Woah, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying anything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the first test to pass, go to the first pending or skipped test, and make that pass as well. When all of the tests are passing, feel free to submit.\n\nRemember that passing code is just the first step. The goal is to work towards a solution that is as readable and expressive as you can make it.\n\nPlease make your solution as general as possible. Good code doesn't just pass the test suite, it works with any input that fits the specification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "go",
      "slug": "raindrops",
      "files": {
        "raindrops_test.go": "package raindrops\n\nimport \"testing\"\n\nvar tests = []struct {\n\tinput    int\n\texpected string\n}{\n\t{1, \"1\"},\n\t{3, \"Pling\"},\n\t{5, \"Plang\"},\n\t{7, \"Plong\"},\n\t{6, \"Pling\"},\n\t{9, \"Pling\"},\n\t{10, \"Plang\"},\n\t{14, \"Plong\"},\n\t{15, \"PlingPlang\"},\n\t{21, \"PlingPlong\"},\n\t{25, \"Plang\"},\n\t{35, \"PlangPlong\"},\n\t{49, \"Plong\"},\n\t{52, \"52\"},\n\t{105, \"PlingPlangPlong\"},\n\t{12121, \"12121\"},\n}\n\nfunc TestConvert(t *testing.T) {\n\tfor _, test := range tests {\n\t\tif actual := Convert(test.input); actual != test.expected {\n\t\t\tt.Errorf(\"Convert(%d) expected %q, Actual %q\", test.input, test.expected, actual)\n\t\t}\n\t}\n}\n",
        "README.md": "# Raindrops\n\nWrite a program that converts a number to a string, the contents of which depends on the number's prime factors.\n\n- If the number contains 3 as a prime factor, output 'Pling'.\n- If the number contains 5 as a prime factor, output 'Plang'.\n- If the number contains 7 as a prime factor, output 'Plong'.\n- If the number does not contain 3, 5, or 7 as a prime factor,\n  just pass the number's digits straight through.\n\n## Examples\n- 28's prime-factorization is 2, 2, 7.\n  - In raindrop-speak, this would be a simple \"Plong\".\n- 1755 prime-factorization is 3, 3, 3, 5, 13.\n  - In raindrop-speak, this would be a \"PlingPlang\".\n- The prime factors of 34 are 2 and 17.\n  - Raindrop-speak doesn't know what to make of that,\n    so it just goes with the straightforward \"34\".\n\n\n## Source\n\nA variation on a famous interview question intended to weed out the obviously incompetent. [view source](http://jumpstartlab.com)\n"
      },
      "fresh": true,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "haskell",
      "slug": "bob",
      "files": {
        "bob_test.hs": "import Test.HUnit (Assertion, (@=?), runTestTT, Test(..), Counts(..))\nimport System.Exit (ExitCode(..), exitWith)\nimport Bob (responseFor)\n\nexitProperly :: IO Counts -> IO ()\nexitProperly m = do\n  counts <- m\n  exitWith $ if failures counts /= 0 || errors counts /= 0 then ExitFailure 1 else ExitSuccess\n\ntestCase :: String -> Assertion -> Test\ntestCase label assertion = TestLabel label (TestCase assertion)\n\ntest_respondsToSomething :: Assertion\ntest_respondsToSomething =\n  \"Whatever.\" @=? responseFor \"Tom-ay-to, tom-aaaah-to.\"\n\ntest_respondsToShouts :: Assertion\ntest_respondsToShouts =\n  \"Woah, chill out!\" @=? responseFor \"WATCH OUT!\"\n\ntest_respondsToQuestions :: Assertion\ntest_respondsToQuestions =\n  \"Sure.\" @=? responseFor \"Does this cryogenic chamber make me look fat?\"\n\ntest_respondsToForcefulTalking :: Assertion\ntest_respondsToForcefulTalking =\n  \"Whatever.\" @=? responseFor \"Let's go make out behind the gym!\"\n\ntest_respondsToAcronyms :: Assertion\ntest_respondsToAcronyms =\n  \"Whatever.\" @=? responseFor \"It's OK if you don't want to go to the DMV.\"\n\ntest_respondsToForcefulQuestions :: Assertion\ntest_respondsToForcefulQuestions =\n  \"Woah, chill out!\" @=? responseFor \"WHAT THE HELL WERE YOU THINKING?\"\n\ntest_respondsToShoutingWithSpecialCharacters :: Assertion\ntest_respondsToShoutingWithSpecialCharacters =\n  \"Woah, chill out!\" @=? responseFor (\n    \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\")\n\ntest_respondsToShoutingNumbers :: Assertion\ntest_respondsToShoutingNumbers =\n  \"Woah, chill out!\" @=? responseFor \"1, 2, 3 GO!\"\n\ntest_respondsToShoutingWithNoExclamationMark :: Assertion\ntest_respondsToShoutingWithNoExclamationMark =\n  \"Woah, chill out!\" @=? responseFor \"I HATE YOU\"\n\ntest_respondsToStatementContainingQuestionMark :: Assertion\ntest_respondsToStatementContainingQuestionMark =\n  \"Whatever.\" @=? responseFor \"Ending with ? means a question.\"\n\ntest_respondsToSilence :: Assertion\ntest_respondsToSilence =\n  \"Fine. Be that way!\" @=? responseFor \"\"\n\ntest_respondsToProlongedSilence :: Assertion\ntest_respondsToProlongedSilence =\n  \"Fine. Be that way!\" @=? responseFor \"    \"\n\ntest_respondsToNonLettersWithQuestion :: Assertion\ntest_respondsToNonLettersWithQuestion =\n  \"Sure.\" @=? responseFor \":) ?\"\n\ntest_respondsToMultipleLineQuestions :: Assertion\ntest_respondsToMultipleLineQuestions =\n  \"Whatever.\" @=? responseFor \"\\nDoes this cryogenic chamber make me look fat? \\nno\"\n\ntest_respondsToOtherWhitespace :: Assertion\ntest_respondsToOtherWhitespace =\n  \"Fine. Be that way!\" @=? responseFor \"\\n\\r \\t\\v\\xA0\\x2002\" -- \\xA0 No-break space, \\x2002 En space\n\ntest_respondsToOnlyNumbers :: Assertion\ntest_respondsToOnlyNumbers =\n  \"Whatever.\" @=? responseFor \"1, 2, 3\"\n\ntest_respondsToQuestionWithOnlyNumbers :: Assertion\ntest_respondsToQuestionWithOnlyNumbers =\n  \"Sure.\" @=? responseFor \"4?\"\n\ntest_respondsToUnicodeShout :: Assertion\ntest_respondsToUnicodeShout =\n  \"Woah, chill out!\" @=? responseFor \"\\xdcML\\xc4\\xdcTS!\"\n\ntest_respondsToUnicodeNonShout :: Assertion\ntest_respondsToUnicodeNonShout =\n  \"Whatever.\" @=? responseFor \"\\xdcML\\xe4\\xdcTS!\"\n\nrespondsToTests :: [Test]\nrespondsToTests =\n  [ testCase \"something\" test_respondsToSomething\n  , testCase \"shouts\" test_respondsToShouts\n  , testCase \"questions\" test_respondsToQuestions\n  , testCase \"forceful talking\" test_respondsToForcefulTalking\n  , testCase \"acronyms\" test_respondsToAcronyms\n  , testCase \"forceful questions\" test_respondsToForcefulQuestions\n  , testCase \"shouting with special characters\"\n    test_respondsToShoutingWithSpecialCharacters\n  , testCase \"shouting numbers\" test_respondsToShoutingNumbers\n  , testCase \"shouting with no exclamation mark\"\n    test_respondsToShoutingWithNoExclamationMark\n  , testCase \"statement containing question mark\"\n    test_respondsToStatementContainingQuestionMark\n  , testCase \"silence\" test_respondsToSilence\n  , testCase \"prolonged silence\" test_respondsToProlongedSilence\n  , testCase \"questioned nonsence\" test_respondsToNonLettersWithQuestion\n  , testCase \"multiple-line statement containing question mark\"\n    test_respondsToMultipleLineQuestions\n  , testCase \"all whitespace is silence\" test_respondsToOtherWhitespace\n  , testCase \"only numbers\" test_respondsToOnlyNumbers\n  , testCase \"question with only numbers\" test_respondsToQuestionWithOnlyNumbers\n  , testCase \"unicode shout\" test_respondsToUnicodeShout\n  , testCase \"unicode non-shout\" test_respondsToUnicodeNonShout\n  ]\n\nmain :: IO ()\nmain = exitProperly (runTestTT (TestList respondsToTests))\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Woah, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying anything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the first test to pass, go to the first pending or skipped test, and make that pass as well. When all of the tests are passing, feel free to submit.\n\nRemember that passing code is just the first step. The goal is to work towards a solution that is as readable and expressive as you can make it.\n\nPlease make your solution as general as possible. Good code doesn't just pass the test suite, it works with any input that fits the specification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "javascript",
      "slug": "bob",
      "files": {
        "bob_test.spec.js": "var Bob = require('./bob');\n\ndescribe(\"Bob\", function() {\n  var bob = new Bob();\n\n  it(\"stating something\", function() {\n    var result = bob.hey('Tom-ay-to, tom-aaaah-to.');\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"shouting\", function() {\n    var result = bob.hey('WATCH OUT!');\n    expect(result).toEqual('Woah, chill out!');\n  });\n\n  xit(\"asking a question\", function() {\n    var result = bob.hey('Does this cryogenic chamber make me look fat?');\n    expect(result).toEqual('Sure.');\n  });\n\n  xit(\"talking forcefully\", function() {\n    var result = bob.hey(\"Let's go make out behind the gym!\");\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"using acronyms in regular speech\", function() {\n    var result = bob.hey(\"It's OK if you don't want to go to the DMV.\");\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"forceful questions\", function() {\n    var result = bob.hey('WHAT THE HELL WERE YOU THINKING?');\n    expect(result).toEqual('Woah, chill out!');\n  });\n\n  xit(\"shouting numbers\", function() {\n    var result = bob.hey('1, 2, 3 GO!');\n    expect(result).toEqual('Woah, chill out!');\n  });\n\n  xit(\"only numbers\", function() {\n    var result = bob.hey('1, 2, 3');\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"question with only numbers\", function() {\n    var result = bob.hey('4?');\n    expect(result).toEqual('Sure.');\n  });\n\n  xit(\"shouting with special characters\", function() {\n    var result = bob.hey('ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!');\n    expect(result).toEqual('Woah, chill out!');\n  });\n\n  xit(\"shouting with umlauts\", function() {\n    var result = bob.hey(\"\\xdcML\\xc4\\xdcTS!\");\n    expect(result).toEqual('Woah, chill out!');\n  });\n\n  xit(\"calmly speaking about umlauts\", function() {\n    var result = bob.hey(\"\\xdcML\\xe4\\xdcTS!\");\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"shouting with no exclamation mark\", function () {\n    var result = bob.hey('I HATE YOU');\n    expect(result).toEqual('Woah, chill out!');\n  });\n\n  xit(\"statement containing question mark\", function() {\n    var result = bob.hey('Ending with a ? means a question.');\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"prattling on\", function () {\n    var result = bob.hey('Wait! Hang on.  Are you going to be OK?');\n    expect(result).toEqual('Sure.');\n  });\n\n  xit(\"silence\", function () {\n    var result = bob.hey('');\n    expect(result).toEqual('Fine. Be that way!');\n  });\n\n   xit(\"prolonged silence\", function () {\n    var result = bob.hey('   ');\n    expect(result).toEqual('Fine. Be that way!');\n  });\n});\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Woah, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying anything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the first test to pass, go to the first pending or skipped test, and make that pass as well. When all of the tests are passing, feel free to submit.\n\nRemember that passing code is just the first step. The goal is to work towards a solution that is as readable and expressive as you can make it.\n\nPlease make your solution as general as possible. Good code doesn't just pass the test suite, it works with any input that fits the specification.\n\nHave fun!\n\n\n## Making the Test Suite Pass\n\nExecute the tests with:\n\n```bash\n$ jasmine-node bob_test.spec.js\n```\n\nAll but the first test have been skipped.\n\nOnce you get a test passing, you can unskip the next one by\nchanging `xit` to `it`.\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "objective-c",
      "slug": "bob",
      "files": {
        "BobTest.m": "#import <XCTest/XCTest.h>\n#import \"Bob.h\"\n\n@interface test_suite : XCTestCase\n\n@end\n\n@implementation test_suite\n\n- (Bob *)bob {\n  return [[Bob alloc] init];\n}\n\n- (void)testStatingSomething {\n  NSString *input = @\"Tom-ay-to, tom-aaaah-to.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShouting {\n  NSString *input = @\"WATCH OUT!\";\n  NSString *expected = @\"Woah, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testAskingAQuestion {\n  NSString *input = @\"Does this cryogenic chamber make me look fat?\";\n  NSString *expected = @\"Sure.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testTalkingForcefully {\n  NSString *input = @\"Let's go make out behind the gym!\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testUsingAcronyms {\n  NSString *input = @\"It's OK if you don't want to go to the DMV.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testForcefulQuestions {\n  NSString *input = @\"WHAT THE HELL WERE YOU THINKING?\";\n  NSString *expected = @\"Woah, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShoutingNumbers {\n  NSString *input = @\"1, 2, 3 GO!\";\n  NSString *expected = @\"Woah, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testOnlyNumbers {\n  NSString *input = @\"1, 2, 3.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n- (void)testQuestionWithOnlyNumbers {\n  NSString *input = @\"4?\";\n  NSString *expected = @\"Sure.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShoutingWithSpecialCharacters {\n  NSString *input = @\"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\";\n  NSString *expected = @\"Woah, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShoutingWithUmlautsCharacters {\n  NSString *input = @\"ÄMLÄTS!\";\n  NSString *expected = @\"Woah, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testCalmlySpeakingAboutUmlauts {\n  NSString *input = @\"ÄMLäTS!\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShoutingWithNoExclamationMark {\n  NSString *input = @\"I HATE YOU\";\n  NSString *expected = @\"Woah, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testStatementContainingQuestionsMark {\n  NSString *input = @\"Ending with a ? means a question.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testPrattlingOn {\n  NSString *input = @\"Wait! Hang on.  Are you going to be OK?\";\n  NSString *expected = @\"Sure.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testSilence {\n  NSString *input = @\"\";\n  NSString *expected = @\"Fine, be that way.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testProlongedSilence {\n  NSString *input = @\"     \";\n  NSString *expected = @\"Fine, be that way.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n@end\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Woah, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying anything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the first test to pass, go to the first pending or skipped test, and make that pass as well. When all of the tests are passing, feel free to submit.\n\nRemember that passing code is just the first step. The goal is to work towards a solution that is as readable and expressive as you can make it.\n\nPlease make your solution as general as possible. Good code doesn't just pass the test suite, it works with any input that fits the specification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "ocaml",
      "slug": "bob",
      "files": {
        "Makefile": "test: test.native\n\t@./test.native\n\ntest.native: *.ml *.mli\n\t@corebuild -quiet test.native\n\nclean:\n\trm -rf _build\n\n.PHONY: clean\n",
        "bob.mli": "(*\nAnswers to `hey` like a teenager.\n\n## Examples\n\n  # response_for \"\"\n  \"Fine. Be that way!\"\n\n  # response_for \"Do you like math?\"\n  \"Sure.\"\n\n  # response_for \"HELLO!\"\n  \"Woah, chill out!\"\n\n  # response_for \"Coding is cool.\"\n  \"Whatever.\"\n*)\nval response_for : string -> string\n",
        "test.ml": "open Core.Std\nopen OUnit2\nopen Bob\n\nlet ae exp got _test_ctxt = assert_equal ~printer:String.to_string exp got\n\nlet tests =\n  [\"something\">::\n     ae \"Whatever.\" (response_for \"Tom-ay-to, tom-aaaah-to.\");\n   \"shouts\">::\n     ae \"Woah, chill out!\" (response_for \"WATCH OUT!\");\n   \"questions\">::\n     ae \"Sure.\" (response_for \"Does this cryogenic chamber make me look fat?\");\n   \"forceful talking\">::\n     ae \"Whatever.\" (response_for \"Let's go make out behind the gym!\");\n   \"acronyms\">::\n     ae \"Whatever.\" (response_for \"It's ok if you don't want to go to the DMV.\");\n   \"forceful questions\">::\n     ae \"Woah, chill out!\" (response_for \"WHAT THE HELL WERE YOU THINKING?\");\n   \"shouting with special characters\">::\n     ae \"Woah, chill out!\"\n       (response_for \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\");\n   \"shouting numbers\">::\n     ae \"Woah, chill out!\" (response_for \"1, 2, 3, GO!\");\n   \"statement containing question mark\">::\n     ae \"Whatever.\" (response_for \"Ending with ? means a question.\");\n   \"silence\">::\n     ae \"Fine. Be that way!\" (response_for \"\");\n   \"prolonged silence\">::\n     ae \"Fine. Be that way!\" (response_for \"   \");\n   \"non-letters with question\">::\n     ae \"Sure.\" (response_for \":) ?\");\n   \"multiple line questons\">::\n     ae \"Whatever.\"\n       (response_for \"\\nDoes this cryogenic chamber make me look fat? \\nno\");\n   \"other whitespace\">::\n     (* No unicode whitespace as OCaml Core doesn't seem to handle Unicode.\n      * Not it seems does it see ASCII 11 (\\v) as whitespace.\n     *)\n     ae \"Fine. Be that way!\" (response_for \"\\n\\r \\t\");\n   \"only numbers\">::\n     ae \"Whatever.\" (response_for \"1, 2, 3\");\n   \"question with only numbers\">::\n     ae \"Sure.\" (response_for \"4?\");\n  ]\n\nlet () =\n  run_test_tt_main (\"bob tests\" >::: tests)\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Woah, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying anything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the first test to pass, go to the first pending or skipped test, and make that pass as well. When all of the tests are passing, feel free to submit.\n\nRemember that passing code is just the first step. The goal is to work towards a solution that is as readable and expressive as you can make it.\n\nPlease make your solution as general as possible. Good code doesn't just pass the test suite, it works with any input that fits the specification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "perl5",
      "slug": "accumulate",
      "files": {
        "accumulate.t": "use strict;\nuse warnings;\n\nuse Test::More;\n\nmy $module = $ENV{EXERCISM} ? 'Example' : 'Accumulate';\n\nmy @cases = (\n    {\n        name      => \"test empty\",\n        function  =>  sub { $_[0] / 2 },\n        input     => [],\n        expected  => [],\n    },\n    {\n        name      => \"raise to 2\",\n        function  => sub { $_[0] * $_[0] },\n        input     => [1, 2, 3, 4, 5],\n        expected  => [1, 4, 9, 16, 25],\n    },\n    {\n        name      => \"divmod\",\n        function  => sub { [int($_[0] / 7), int($_[0] % 7)] },\n        input     => [10, 17, 23],\n        expected  => [[1, 3], [2, 3], [3, 2]],\n    },\n    {\n        name      => \"composition\",\n        function  => [sub { my $n  = shift; [int($n / 7), int($n % 7)] }, \n                      sub { my $ar = shift;  7 * $ar->[0] + $ar->[1]   } ],\n        input     => [10, 17, 23],\n        expected  => [10, 17, 23],\n    },\n    {\n        name      => \"capitalize\",\n        function  => sub { uc $_[0] },\n        input     => ['hello', 'exercism'],\n        expected  => ['HELLO', 'EXERCISM'],\n    },\n    {\n        name      => \"recursive\",\n        function  => sub { \n                           my $inp = shift; \n                           {\n                               no strict 'refs';\n                               my $accumulate = \"${module}::accumulate\"; \n                               $accumulate->( [1, 2, 3], sub { $inp . $_[0] } )\n                           }\n                         },\n        input     => ['a', 'b', 'c'],\n        expected  => [['a1', 'a2', 'a3'], ['b1', 'b2', 'b3'], ['c1', 'c2', 'c3']],\n    }    \n);\n\nplan tests => 3 + @cases;\n\nok -e \"$module.pm\", \"missing $module.pm\"\n    or BAIL_OUT(\"You need to create a class called $module.pm with a constructor called new.\");\n\neval \"use $module\";\nok !$@, \"Cannot load $module.pm\"\n    or BAIL_OUT(\"Does $module.pm compile?  Does it end with 1; ? ($@)\");\n\ncan_ok($module, 'accumulate') \n    or BAIL_OUT(\"Missing package $module; or missing sub accumulate()\");\n\nforeach my $c (@cases) {\n    my $accumulate = \"${module}::accumulate\"; \n\n    no strict 'refs';\n\n    if ( ref $c->{function} eq 'CODE' ) {\n        is_deeply $accumulate->($c->{input}, $c->{function}), $c->{expected}, $c->{name};\n    }\n    # test case: composition\n    if ( ref $c->{function} eq 'ARRAY' ) {\n        my ($fn1, $fn2) = @{$c->{function}};\n        is_deeply $accumulate->( $accumulate->($c->{input}, $fn1), $fn2 ),\n                  $c->{expected}, $c->{name};\n    }\n}\n",
        "README.md": "# Accumulate\n\nImplement the `accumulate` operation, which, given a collection and an operation to perform on each element of the collection, returns a new collection containing the result of applying that operation to each element of the input collection.\n\nFor example, given the collection of numbers:\n\n- 1, 2, 3, 4, 5\n\nAnd the operation:\n\n- square a number\n\nYour code should be able to produce the collection of squares:\n\n- 1, 4, 9, 16, 25\n\n## Restrictions\n\nKeep your hands off that collect/map/fmap/whatchamacallit functionality\nprovided by your standard library!\nSolve this one yourself using other basic tools instead.\n\nElixir specific: it's perfectly fine to use `Enum.reduce` or\n`Enumerable.reduce`.\n\n\n## Source\n\nConversation with James Edward Gray II [view source](https://twitter.com/jeg2)\n"
      },
      "fresh": true,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "python",
      "slug": "bob",
      "files": {
        "bob_test.py": "try:\n    import bob\nexcept ImportError:\n    raise SystemExit('Could not find bob.py. Does it exist?')\n\nimport unittest\n\n\nclass BobTests(unittest.TestCase):\n    def setUp(self):\n        self.bob = bob.Bob()\n\n    def test_stating_something(self):\n        self.assertEqual(\n            'Whatever.',\n            self.bob.hey('Tom-ay-to, tom-aaaah-to.')\n        )\n\n    def test_shouting(self):\n        self.assertEqual(\n            'Woah, chill out!',\n            self.bob.hey('WATCH OUT!')\n        )\n\n    def test_asking_a_question(self):\n        self.assertEqual(\n            'Sure.',\n            self.bob.hey('Does this cryogenic chamber make me look fat?')\n        )\n\n    def test_asking_a_numeric_question(self):\n        self.assertEqual(\n            'Sure.',\n            self.bob.hey('You are, what, like 15?')\n        )\n\n    def test_talking_forcefully(self):\n        self.assertEqual(\n            'Whatever.',\n            self.bob.hey(\"Let's go make out behind the gym!\")\n        )\n\n    def test_using_acronyms_in_regular_speech(self):\n        self.assertEqual(\n            'Whatever.', self.bob.hey(\"It's OK if you don't want to go to the DMV.\")\n        )\n\n    def test_forceful_questions(self):\n        self.assertEqual(\n            'Woah, chill out!', self.bob.hey('WHAT THE HELL WERE YOU THINKING?')\n        )\n\n    def test_shouting_numbers(self):\n        self.assertEqual(\n            'Woah, chill out!', self.bob.hey('1, 2, 3 GO!')\n        )\n\n    def test_only_numbers(self):\n        self.assertEqual(\n            'Whatever.', self.bob.hey('1, 2, 3')\n        )\n\n    def test_question_with_only_numbers(self):\n        self.assertEqual(\n            'Sure.', self.bob.hey('4?')\n        )\n\n    def test_shouting_with_special_characters(self):\n        self.assertEqual(\n            'Woah, chill out!', self.bob.hey('ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!')\n        )\n\n    def test_shouting_with_umlauts(self):\n        self.assertEqual(\n            'Woah, chill out!', self.bob.hey(u\"\\xdcML\\xc4\\xdcTS!\")\n        )\n\n    def test_calmly_speaking_with_umlauts(self):\n        self.assertEqual(\n            'Whatever.', self.bob.hey(u\"\\xdcML\\xe4\\xdcTS!\")\n        )\n\n    def test_shouting_with_no_exclamation_mark(self):\n        self.assertEqual(\n            'Woah, chill out!', self.bob.hey('I HATE YOU')\n        )\n\n    def test_statement_containing_question_mark(self):\n        self.assertEqual(\n            'Whatever.', self.bob.hey('Ending with ? means a question.')\n        )\n\n    def test_prattling_on(self):\n        self.assertEqual(\n            'Sure.', self.bob.hey(\"Wait! Hang on. Are you going to be OK?\")\n        )\n\n    def test_silence(self):\n        self.assertEqual(\n            'Fine. Be that way!', self.bob.hey('')\n        )\n\n    def test_prolonged_silence(self):\n        self.assertEqual(\n            'Fine. Be that way!', self.bob.hey('    ')\n        )\n\nif __name__ == '__main__':\n    unittest.main()\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Woah, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying anything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the first test to pass, go to the first pending or skipped test, and make that pass as well. When all of the tests are passing, feel free to submit.\n\nRemember that passing code is just the first step. The goal is to work towards a solution that is as readable and expressive as you can make it.\n\nPlease make your solution as general as possible. Good code doesn't just pass the test suite, it works with any input that fits the specification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "ruby",
      "slug": "anagram",
      "files": {
        "anagram_test.rb": "require 'minitest/autorun'\nrequire_relative 'anagram'\n\nclass AnagramTest < MiniTest::Unit::TestCase\n\n  def test_no_matches\n    detector = Anagram.new('diaper')\n    assert_equal [], detector.match(%w(hello world zombies pants))\n  end\n\n  def test_detect_simple_anagram\n    skip\n    detector = Anagram.new('ant')\n    anagrams = detector.match(['tan', 'stand', 'at'])\n    assert_equal ['tan'], anagrams\n  end\n\n  def test_detect_multiple_anagrams\n    skip\n    detector = Anagram.new('master')\n    anagrams = detector.match(['stream', 'pigeon', 'maters'])\n    assert_equal ['maters', 'stream'], anagrams.sort\n  end\n\n  def test_does_not_confuse_different_duplicates\n    skip\n    detector = Anagram.new('galea')\n    assert_equal [], detector.match(['eagle'])\n  end\n\n  def test_identical_word_is_not_anagram\n    skip\n    detector = Anagram.new('corn')\n    anagrams = detector.match %w(corn dark Corn rank CORN cron park)\n    assert_equal ['cron'], anagrams\n  end\n\n  def test_eliminate_anagrams_with_same_checksum\n    skip\n    detector = Anagram.new('mass')\n    assert_equal [], detector.match(['last'])\n  end\n\n  def test_eliminate_anagram_subsets\n    skip\n    detector = Anagram.new('good')\n    assert_equal [], detector.match(['dog', 'goody'])\n  end\n\n  def test_detect_anagram\n    skip\n    detector = Anagram.new('listen')\n    anagrams = detector.match %w(enlists google inlets banana)\n    assert_equal ['inlets'], anagrams\n  end\n\n  def test_multiple_anagrams\n    skip\n    detector = Anagram.new('allergy')\n    anagrams = detector.match %w(gallery ballerina regally clergy largely leading)\n    assert_equal ['gallery', 'largely', 'regally'], anagrams.sort\n  end\n\n  def test_anagrams_are_case_insensitive\n    skip\n    detector = Anagram.new('Orchestra')\n    anagrams = detector.match %w(cashregister Carthorse radishes)\n    assert_equal ['Carthorse'], anagrams\n  end\nend\n",
        "README.md": "# Anagram\n\nWrite a program that, given a word and a list of possible anagrams, selects the correct sublist.\n\nGiven `\"listen\"` and a list of candidates like `\"enlists\" \"google\" \"inlets\" \"banana\"` the program should return a list containing `\"inlets\"`.\n\n\n## Source\n\nInspired by the Extreme Startup game [view source](https://github.com/rchatley/extreme_startup)\n"
      },
      "fresh": false,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "ruby",
      "slug": "bob",
      "files": {
        "GETTING_STARTED.md": "# Getting Started\n\nThese exercises lean on Test-Driven Development (TDD), but they're not an\nexact match.\n\nThe following steps assume that you are in the same directory as the test\nsuite.\n\n## Step 1\n\nRun the test suite. It's in Minitest, and can be run with ruby:\n\n    $ ruby bob_test.rb\n\nThis will fail, complaining that there is no file called `bob`.\n\nTo fix the error create an empty file called `bob.rb` in the same\ndirectory as the `bob_test.rb` file.\n\n## Step 2\n\nRun the test again. It will give you a new error.\n\n\n    1) Error:\n    BobTest#test_stating_something:\n    NameError: uninitialized constant Bob\n        bob_test.rb:12:in `test_stating_something'\n\nWithin the first test, we are telling ruby to create a new Bob object,\nbut it doesn't know anything about any Bob, so we need to make one.\n\nOpen up the bob.rb file and add the following code:\n\n    class Bob\n    end\n\n## Step 3\n\nRun the test again.\n\n    1) Error:\n    BobTest#test_stating_something:\n    NoMethodError: undefined method `hey' for #<Bob:0x007fa531343e50>\n        bob_test.rb:12:in `test_stating_something'\n\n\nThis time we have a Bob, but we're trying to call a method named \"hey\" on him.\n\nOpen up bob.rb and add a method definition inside the class:\n\n    class Bob\n      def hey\n      end\n    end\n\n## Step 4\n\nRun the test again.\n\n    1) Error:\n    BobTest#test_stating_something:\n    ArgumentError: wrong number of arguments (1 for 0)\n      in `hey' bob_test.rb:12:in `test_stating_something'\n\nThe method \"hey\" needs to take an argument.\n\nThese are examples of method definitions that take arguments:\n\n    def greet(name)\n    end\n\n    def drink(beverage)\n    end\n\nChange the \"hey\" method definition so it takes an argument.\n\n## Step 5\n\nRun the test again.\n\n    1) Failure:\n    BobTest#test_stating_something [bob_test.rb:12]:\n    Expected: \"Whatever.\"\n      Actual: nil\n\nUp until now we've been getting errors, this time we get a failure.\n\nAn error means that ruby cannot even run properly because things like missing\nfiles or referencing classes or methods that don't exist, or because of syntax\nerrors.\n\nA failure is different—when you have a failure the ruby is running just fine,\nbut the test is expecting one outcome, but getting another.\n\nThe test is expecting the hey method to return the string \"Whatever\". The\neasiest way to make it pass, is to simply stick the string \"Whatever\" inside\nthe method definition.\n\n## Step 6\n\nRun the test again.\n\nIf it fails you're going to need to read the error message carefully to figure\nout what went wrong, and then try again.\n\nIf it passes, then you're ready to move to the next step.\n\nOpen the bob_test.rb file, and find the word \"skip\". All but the first test\nstart with \"skip\", which tells Minitest to ignore the test. This is so that\nyou don't have to deal with all the failures at once.\n\nTo activate the next test, delete the \"skip\", and run the test suite again.\n\n## Wash, Rince, Repeat\n\nDelete one \"skip\" at a time, and make each test pass before you move to the\nnext one.\n\n## Submit\n\nWhen everything is passing, you can submit your code with the following\ncommand:\n\n    $ exercism submit bob.rb\n\n",
        "bob_test.rb": "require 'minitest/autorun'\nbegin\n  require_relative 'bob'\nrescue LoadError => e\n  puts \"\\n\\n#{e.backtrace.first} #{e.message}\"\n  puts DATA.read\n  exit 1\nend\n\nclass BobTest < MiniTest::Unit::TestCase\n  def test_stating_something\n    assert_equal 'Whatever.', ::Bob.new.hey('Tom-ay-to, tom-aaaah-to.')\n  end\n\n  def test_shouting\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('WATCH OUT!')\n  end\n\n  def test_shouting_gibberish\n    skip\n    gibberish = ('A'..'Z').to_a.shuffle[0,10].join\n    assert_equal 'Woah, chill out!', ::Bob.new.hey(gibberish)\n  end\n\n  def test_asking_a_question\n    skip\n    assert_equal 'Sure.', ::Bob.new.hey('Does this cryogenic chamber make me look fat?')\n  end\n\n  def test_asking_a_numeric_question\n    skip\n    assert_equal 'Sure.', ::Bob.new.hey('You are, what, like 15?')\n  end\n\n  def test_asking_gibberish\n    skip\n    gibberish = ('a'..'z').to_a.shuffle[0,10].join\n    assert_equal 'Sure.', ::Bob.new.hey(\"#{gibberish}?\")\n  end\n\n  def test_talking_forcefully\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey(\"Let's go make out behind the gym!\")\n  end\n\n  def test_using_acronyms_in_regular_speech\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey(\"It's OK if you don't want to go to the DMV.\")\n  end\n\n  def test_forceful_questions\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('WHAT THE HELL WERE YOU THINKING?')\n  end\n\n  def test_shouting_numbers\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('1, 2, 3 GO!')\n  end\n\n  def test_only_numbers\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey('1, 2, 3')\n  end\n\n  def test_question_with_only_numbers\n    skip\n    assert_equal 'Sure.', ::Bob.new.hey('4?')\n  end\n\n  def test_shouting_with_special_characters\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!')\n  end\n\n  def test_shouting_with_no_exclamation_mark\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('I HATE YOU')\n  end\n\n  def test_statement_containing_question_mark\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey('Ending with ? means a question.')\n  end\n\n  def test_prattling_on\n    skip\n    assert_equal 'Sure.', ::Bob.new.hey(\"Wait! Hang on. Are you going to be OK?\")\n  end\n\n  def test_silence\n    skip\n    assert_equal 'Fine. Be that way!', ::Bob.new.hey('')\n  end\n\n  def test_prolonged_silence\n    skip\n    silence = \" \" * rand(1..10)\n    assert_equal 'Fine. Be that way!', ::Bob.new.hey(silence)\n  end\n\n  def test_on_multiple_line_questions\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey(%{\nDoes this cryogenic chamber make me look fat?\nno})\n  end\nend\n\n__END__\n\n*****************************************************\nYou got an error, which is exactly as it should be.\nThis is the first step in the Test-Driven Development\n(TDD) process.\n\nThe most important part of the error is\n\n      cannot load such file\n\nIt's looking for a file named bob.rb that doesn't\nexist yet.\n\nTo fix the error, create an empty file named bob.rb\nin the same directory as the bob_test.rb file.\n\nThen run the test again.\n\nFor more guidance as you work on this exercise, see\nGETTING_STARTED.md.\n*****************************************************\n\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Woah, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying anything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the first test to pass, go to the first pending or skipped test, and make that pass as well. When all of the tests are passing, feel free to submit.\n\nRemember that passing code is just the first step. The goal is to work towards a solution that is as readable and expressive as you can make it.\n\nPlease make your solution as general as possible. Good code doesn't just pass the test suite, it works with any input that fits the specification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "ruby",
      "slug": "word-count",
      "files": {
        "word_count_test.rb": "require 'minitest/autorun'\nrequire_relative 'phrase'\n\nclass PhraseTest < MiniTest::Unit::TestCase\n\n  def test_count_one_word\n    phrase = Phrase.new(\"word\")\n    counts = {\"word\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_one_of_each\n    skip\n    phrase = Phrase.new(\"one of each\")\n    counts = {\"one\" => 1, \"of\" => 1, \"each\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_multiple_occurrences\n    skip\n    phrase = Phrase.new(\"one fish two fish red fish blue fish\")\n    counts = {\"one\" => 1, \"fish\" => 4, \"two\" => 1, \"red\" => 1, \"blue\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_everything_just_once\n    skip\n    phrase = Phrase.new(\"all the kings horses and all the kings men\")\n    phrase.word_count # count it an extra time\n    counts = {\n      \"all\" => 2, \"the\" => 2, \"kings\" => 2, \"horses\" => 1, \"and\" => 1, \"men\" => 1\n    }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_ignore_punctuation\n    skip\n    phrase = Phrase.new(\"car : carpet as java : javascript!!&@$%^&\")\n    counts = {\"car\" => 1, \"carpet\" => 1, \"as\" => 1, \"java\" => 1, \"javascript\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_handles_cramped_lists\n    skip\n    phrase = Phrase.new(\"one,two,three\")\n    counts = {\"one\" => 1, \"two\" => 1, \"three\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_include_numbers\n    skip\n    phrase = Phrase.new(\"testing, 1, 2 testing\")\n    counts = {\"testing\" => 2, \"1\" => 1, \"2\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_normalize_case\n    skip\n    phrase = Phrase.new(\"go Go GO\")\n    counts = {\"go\" => 3}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_with_apostrophes\n    skip\n    phrase = Phrase.new(\"First: don't laugh. Then: don't cry.\")\n    counts = {\"first\"=>1, \"don't\"=>2, \"laugh\"=>1, \"then\"=>1, \"cry\"=>1}\n    assert_equal counts, phrase.word_count\n  end\nend\n",
        "README.md": "# Word Count\n\nWrite a program that given a phrase can count the occurrences of each word in that phrase.\n\nFor example for the input `\"olly olly in come free\"`\n\n```plain\nolly: 2\nin: 1\ncome: 1\nfree: 1\n```\n\n\n\n## Source\n\nThe golang tour [view source](http://tour.golang.org)\n"
      },
      "fresh": false,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    },
    {
      "track": "scala",
      "slug": "bob",
      "files": {
        "build.sbt": "scalaVersion := \"2.10.3\"\n\nlibraryDependencies += \"org.scalatest\" % \"scalatest_2.10\" % \"2.0\" % \"test\"\n",
        "src/test/scala/bob_test.scala": "import org.scalatest._\n\nclass BobSpecs extends FlatSpec with Matchers {\n  def teenager = new Bob\n\n  it should \"respond to a statement\" in {\n    val response = teenager.hey(\"Tom-ay-to, tom-aaaah-to.\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"respond to shouting\" in {\n    pending\n    val response = teenager.hey(\"WATCH OUT!\")\n    response should be (\"Woah, chill out!\")\n  }\n\n  it should \"respond to questions\" in {\n    pending\n    val response = teenager.hey(\"Does this cryogenic chamber make me look fat?\")\n    response should be (\"Sure.\")\n  }\n\n  it should \"allow questions to end with numbers\" in {\n    pending\n    val response = teenager.hey(\"You are what, like 15?\")\n    response should be (\"Sure.\")\n  }\n\n  it should \"respond to talking forcefully\" in {\n    pending\n    val response = teenager.hey(\"Let's go work out at the gym!\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"allow acroynms in regular speech\" in {\n    pending\n    val response = teenager.hey(\"It's OK if you don't want to go to the DMV.\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"see forceful questions as shouting\" in {\n    pending\n    val response = teenager.hey(\"WHAT THE HELL WERE YOU THINKING?\")\n    response should be (\"Woah, chill out!\")\n  }\n\n  it should \"allow numbers when shouting\" in {\n    pending\n    val response = teenager.hey(\"1, 2, 3, GO!\")\n    response should be (\"Woah, chill out!\")\n  }\n\n  it should \"see only numbers as speech\" in {\n    pending\n    val response = teenager.hey(\"1, 2, 3\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"respond to questions with only numbers\" in {\n    pending\n    val response = teenager.hey(\"4?\")\n    response should be (\"Sure.\")\n  }\n\n  it should \"respond to shouting with no exclamation mark\" in {\n    pending\n    val response = teenager.hey(\"I HATE YOU\")\n    response should be (\"Woah, chill out!\")\n  }\n\n  it should \"respond to statements with ? in the middle\" in {\n    pending\n    val response = teenager.hey(\"Ending with ? means a question.\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"respond to prattling on\" in {\n    pending\n    val response = teenager.hey(\"Wait! Hang on. Are you going to be OK?\")\n    response should be (\"Sure.\")\n  }\n\n  it should \"respond to silence\" in {\n    pending\n    val response = teenager.hey(\"\")\n    response should be (\"Fine. Be that way!\")\n  }\n\n  it should \"respond to prolonged silence\" in {\n    pending\n    val response = teenager.hey(\"       \")\n    response should be (\"Fine. Be that way!\")\n  }\n\n  it should \"respond to multiple line questions\" in {\n    pending\n    val response = teenager.hey(\"\"\"\nDoes this cryogenic chamber make me look fat?\nno\"\"\")\n    response should be (\"Whatever.\")\n  }\n}\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Woah, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying anything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the first test to pass, go to the first pending or skipped test, and make that pass as well. When all of the tests are passing, feel free to submit.\n\nRemember that passing code is just the first step. The goal is to work towards a solution that is as readable and expressive as you can make it.\n\nPlease make your solution as general as possible. Good code doesn't just pass the test suite, it works with any input that fits the specification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true,
      "readme": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io",
      "test_file": "PLEASE_UPGRADE.txt",
      "tests": "Please upgrade to the latest version of the exercism command-line client. See: http://cli.exercism.io"
    }
  ]
}
