{
  "assignments": [
    {
      "track": "ruby",
      "slug": "anagram",
      "files": {
        "anagram_test.rb": "require 'minitest/autorun'\nrequire_relative 'anagram'\n\nclass AnagramTest < MiniTest::Unit::TestCase\n\n  def test_no_matches\n    detector = Anagram.new('diaper')\n    assert_equal [], detector.match(%w(hello world zombies pants))\n  end\n\n  def test_detect_simple_anagram\n    skip\n    detector = Anagram.new('ant')\n    anagrams = detector.match(['tan', 'stand', 'at'])\n    assert_equal ['tan'], anagrams\n  end\n\n  def test_detect_multiple_anagrams\n    skip\n    detector = Anagram.new('master')\n    anagrams = detector.match(['stream', 'pigeon', 'maters'])\n    assert_equal ['maters', 'stream'], anagrams.sort\n  end\n\n  def test_does_not_confuse_different_duplicates\n    skip\n    detector = Anagram.new('galea')\n    assert_equal [], detector.match(['eagle'])\n  end\n\n  def test_identical_word_is_not_anagram\n    skip\n    detector = Anagram.new('corn')\n    anagrams = detector.match %w(corn dark Corn rank CORN cron park)\n    assert_equal ['cron'], anagrams\n  end\n\n  def test_eliminate_anagrams_with_same_checksum\n    skip\n    detector = Anagram.new('mass')\n    assert_equal [], detector.match(['last'])\n  end\n\n  def test_eliminate_anagram_subsets\n    skip\n    detector = Anagram.new('good')\n    assert_equal [], detector.match(['dog', 'goody'])\n  end\n\n  def test_detect_anagram\n    skip\n    detector = Anagram.new('listen')\n    anagrams = detector.match %w(enlists google inlets banana)\n    assert_equal ['inlets'], anagrams\n  end\n\n  def test_multiple_anagrams\n    skip\n    detector = Anagram.new('allergy')\n    anagrams = detector.match %w(gallery ballerina regally clergy largely leading)\n    assert_equal ['gallery', 'largely', 'regally'], anagrams.sort\n  end\n\n  def test_anagrams_are_case_insensitive\n    skip\n    detector = Anagram.new('Orchestra')\n    anagrams = detector.match %w(cashregister Carthorse radishes)\n    assert_equal ['Carthorse'], anagrams\n  end\nend\n",
        "README.md": "# Anagram\n\nWrite a program that, given a word and a list of possible anagrams, selects the correct sublist.\n\nGiven `\"listen\"` and a list of candidates like `\"enlists\" \"google\" \"inlets\" \"banana\"` the program should return a list containing `\"inlets\"`.\n\n\n## Source\n\nInspired by the Extreme Startup game [view source](https://github.com/rchatley/extreme_startup)\n"
      },
      "fresh": false
    },
    {
      "track": "ruby",
      "slug": "word-count",
      "files": {
        "word_count_test.rb": "require 'minitest/autorun'\nrequire_relative 'phrase'\n\nclass PhraseTest < MiniTest::Unit::TestCase\n\n  def test_count_one_word\n    phrase = Phrase.new(\"word\")\n    counts = {\"word\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_one_of_each\n    skip\n    phrase = Phrase.new(\"one of each\")\n    counts = {\"one\" => 1, \"of\" => 1, \"each\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_multiple_occurrences\n    skip\n    phrase = Phrase.new(\"one fish two fish red fish blue fish\")\n    counts = {\"one\" => 1, \"fish\" => 4, \"two\" => 1, \"red\" => 1, \"blue\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_everything_just_once\n    skip\n    phrase = Phrase.new(\"all the kings horses and all the kings men\")\n    phrase.word_count # count it an extra time\n    counts = {\n      \"all\" => 2, \"the\" => 2, \"kings\" => 2, \"horses\" => 1, \"and\" => 1, \"men\" => 1\n    }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_ignore_punctuation\n    skip\n    phrase = Phrase.new(\"car : carpet as java : javascript!!&@$%^&\")\n    counts = {\"car\" => 1, \"carpet\" => 1, \"as\" => 1, \"java\" => 1, \"javascript\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_handles_cramped_lists\n    skip\n    phrase = Phrase.new(\"one,two,three\")\n    counts = {\"one\" => 1, \"two\" => 1, \"three\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_include_numbers\n    skip\n    phrase = Phrase.new(\"testing, 1, 2 testing\")\n    counts = {\"testing\" => 2, \"1\" => 1, \"2\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_normalize_case\n    skip\n    phrase = Phrase.new(\"go Go GO\")\n    counts = {\"go\" => 3}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_with_apostrophes\n    skip\n    phrase = Phrase.new(\"First: don't laugh. Then: don't cry.\")\n    counts = {\"first\"=>1, \"don't\"=>2, \"laugh\"=>1, \"then\"=>1, \"cry\"=>1}\n    assert_equal counts, phrase.word_count\n  end\nend\n",
        "README.md": "# Word Count\n\nWrite a program that given a phrase can count the occurrences of each word in that phrase.\n\nFor example for the input `\"olly olly in come free\"`\n\n```plain\nolly: 2\nin: 1\ncome: 1\nfree: 1\n```\n\n\n\n## Source\n\nThe golang tour [view source](http://tour.golang.org)\n"
      },
      "fresh": false
    },
    {
      "track": "ruby",
      "slug": "bob",
      "files": {
        "GETTING_STARTED.md": "# Getting Started\n\nThese exercises lean on Test-Driven Development (TDD), but they're not an\nexact match.\n\nThe following steps assume that you are in the same directory as the test\nsuite.\n\n## Step 1\n\nRun the test suite. It's in Minitest, and can be run with ruby:\n\n    $ ruby bob_test.rb\n\nThis will fail, complaining that there is no file called `bob`.\n\nTo fix the error create an empty file called `bob.rb` in the same\ndirectory as the `bob_test.rb` file.\n\n## Step 2\n\nRun the test again. It will give you a new error.\n\n\n    1) Error:\n    BobTest#test_stating_something:\n    NameError: uninitialized constant Bob\n        bob_test.rb:12:in `test_stating_something'\n\nWithin the first test, we are telling ruby to create a new Bob object,\nbut it doesn't know anything about any Bob, so we need to make one.\n\nOpen up the bob.rb file and add the following code:\n\n    class Bob\n    end\n\n## Step 3\n\nRun the test again.\n\n    1) Error:\n    BobTest#test_stating_something:\n    NoMethodError: undefined method `hey' for #<Bob:0x007fa531343e50>\n        bob_test.rb:12:in `test_stating_something'\n\n\nThis time we have a Bob, but we're trying to call a method named \"hey\" on him.\n\nOpen up bob.rb and add a method definition inside the class:\n\n    class Bob\n      def hey\n      end\n    end\n\n## Step 4\n\nRun the test again.\n\n    1) Error:\n    BobTest#test_stating_something:\n    ArgumentError: wrong number of arguments (1 for 0)\n      in `hey' bob_test.rb:12:in `test_stating_something'\n\nThe method \"hey\" needs to take an argument.\n\nThese are examples of method definitions that take arguments:\n\n    def greet(name)\n    end\n\n    def drink(beverage)\n    end\n\nChange the \"hey\" method definition so it takes an argument.\n\n## Step 5\n\nRun the test again.\n\n    1) Failure:\n    BobTest#test_stating_something [bob_test.rb:12]:\n    Expected: \"Whatever.\"\n      Actual: nil\n\nUp until now we've been getting errors, this time we get a failure.\n\nAn error means that ruby cannot even run properly because things like missing\nfiles or referencing classes or methods that don't exist, or because of syntax\nerrors.\n\nA failure is differentâ€”when you have a failure the ruby is running just fine,\nbut the test is expecting one outcome, but getting another.\n\nThe test is expecting the hey method to return the string \"Whatever\". The\neasiest way to make it pass, is to simply stick the string \"Whatever\" inside\nthe method definition.\n\n## Step 6\n\nRun the test again.\n\nIf it fails you're going to need to read the error message carefully to figure\nout what went wrong, and then try again.\n\nIf it passes, then you're ready to move to the next step.\n\nOpen the bob_test.rb file, and find the word \"skip\". All but the first test\nstart with \"skip\", which tells Minitest to ignore the test. This is so that\nyou don't have to deal with all the failures at once.\n\nTo activate the next test, delete the \"skip\", and run the test suite again.\n\n## Wash, Rince, Repeat\n\nDelete one \"skip\" at a time, and make each test pass before you move to the\nnext one.\n\n## Submit\n\nWhen everything is passing, you can submit your code with the following\ncommand:\n\n    $ exercism submit bob.rb\n\n",
        "bob_test.rb": "require 'minitest/autorun'\nbegin\n  require_relative 'bob'\nrescue LoadError => e\n  puts \"\\n\\n#{e.backtrace.first} #{e.message}\"\n  puts DATA.read\n  exit 1\nend\n\nclass BobTest < MiniTest::Unit::TestCase\n  def test_stating_something\n    assert_equal 'Whatever.', ::Bob.new.hey('Tom-ay-to, tom-aaaah-to.')\n  end\n\n  def test_shouting\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('WATCH OUT!')\n  end\n\n  def test_shouting_gibberish\n    skip\n    gibberish = ('A'..'Z').to_a.shuffle[0,10].join\n    assert_equal 'Woah, chill out!', ::Bob.new.hey(gibberish)\n  end\n\n  def test_asking_a_question\n    skip\n    assert_equal 'Sure.', ::Bob.new.hey('Does this cryogenic chamber make me look fat?')\n  end\n\n  def test_asking_a_numeric_question\n    skip\n    assert_equal 'Sure.', ::Bob.new.hey('You are, what, like 15?')\n  end\n\n  def test_asking_gibberish\n    skip\n    gibberish = ('a'..'z').to_a.shuffle[0,10].join\n    assert_equal 'Sure.', ::Bob.new.hey(\"#{gibberish}?\")\n  end\n\n  def test_talking_forcefully\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey(\"Let's go make out behind the gym!\")\n  end\n\n  def test_using_acronyms_in_regular_speech\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey(\"It's OK if you don't want to go to the DMV.\")\n  end\n\n  def test_forceful_questions\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('WHAT THE HELL WERE YOU THINKING?')\n  end\n\n  def test_shouting_numbers\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('1, 2, 3 GO!')\n  end\n\n  def test_only_numbers\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey('1, 2, 3')\n  end\n\n  def test_question_with_only_numbers\n    skip\n    assert_equal 'Sure.', ::Bob.new.hey('4?')\n  end\n\n  def test_shouting_with_special_characters\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!')\n  end\n\n  def test_shouting_with_no_exclamation_mark\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('I HATE YOU')\n  end\n\n  def test_statement_containing_question_mark\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey('Ending with ? means a question.')\n  end\n\n  def test_prattling_on\n    skip\n    assert_equal 'Sure.', ::Bob.new.hey(\"Wait! Hang on. Are you going to be OK?\")\n  end\n\n  def test_silence\n    skip\n    assert_equal 'Fine. Be that way!', ::Bob.new.hey('')\n  end\n\n  def test_prolonged_silence\n    skip\n    silence = \" \" * rand(1..10)\n    assert_equal 'Fine. Be that way!', ::Bob.new.hey(silence)\n  end\n\n  def test_on_multiple_line_questions\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey(%{\nDoes this cryogenic chamber make me look fat?\nno})\n  end\nend\n\n__END__\n\n*****************************************************\nYou got an error, which is exactly as it should be.\nThis is the first step in the Test-Driven Development\n(TDD) process.\n\nThe most important part of the error is\n\n      cannot load such file\n\nIt's looking for a file named bob.rb that doesn't\nexist yet.\n\nTo fix the error, create an empty file named bob.rb\nin the same directory as the bob_test.rb file.\n\nThen run the test again.\n\nFor more guidance as you work on this exercise, see\nGETTING_STARTED.md.\n*****************************************************\n\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Woah, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying anything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the first test to pass, go to the first pending or skipped test, and make that pass as well. When all of the tests are passing, feel free to submit.\n\nRemember that passing code is just the first step. The goal is to work towards a solution that is as readable and expressive as you can make it.\n\nPlease make your solution as general as possible. Good code doesn't just pass the test suite, it works with any input that fits the specification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true
    }
  ]
}
