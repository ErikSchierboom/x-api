{
  "assignments": [
    {
      "track_id": "haskell",
      "id": "list-ops",
      "track": "haskell",
      "slug": "list-ops",
      "files": {
        "ListOps.hs": "module ListOps\n  ( length\n  , reverse\n  , map\n  , filter\n  , foldr\n  , foldl'\n  , (++)\n  , concat\n  ) where\n\nimport Prelude hiding\n  ( length, reverse, map, filter, foldr, (++), concat )\n\nfoldl' :: (b -> a -> b) -> b -> [a] -> b\nfoldl' = undefined\n\nfoldr :: (a -> b -> b) -> b -> [a] -> b\nfoldr = undefined\n\nlength :: [a] -> Int\nlength = undefined\n\nreverse :: [a] -> [a]\nreverse = undefined\n\nmap :: (a -> b) -> [a] -> [b]\nmap = undefined\n\nfilter :: (a -> Bool) -> [a] -> [a]\nfilter = undefined\n\n(++) :: [a] -> [a] -> [a]\nxs ++ ys = undefined\n\nconcat :: [[a]] -> [a]\nconcat = undefined\n",
        "list-ops_test.hs": "{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Test.HUnit (Assertion, (@=?), runTestTT, Test(..), Counts(..))\nimport System.Exit (ExitCode(..), exitWith)\nimport qualified ListOps as L\nimport Control.Exception (Exception, throw, evaluate, try)\nimport Data.Typeable (Typeable)\n\ndata FoldlIsStrictException = FoldlIsStrictException deriving (Eq, Show, Typeable)\ninstance Exception FoldlIsStrictException\n\nexitProperly :: IO Counts -> IO ()\nexitProperly m = do\n  counts <- m\n  exitWith $ if failures counts /= 0 || errors counts /= 0 then ExitFailure 1 else ExitSuccess\n\ntestCase :: String -> Assertion -> Test\ntestCase label assertion = TestLabel label (TestCase assertion)\n\nmain :: IO ()\nmain = exitProperly $ runTestTT $ TestList\n       [ TestList listOpsTests ]\n\n\nbig :: Int\nbig = 100000\n\nlistOpsTests :: [Test]\nlistOpsTests =\n  [ testCase \"length of empty list\" $ do\n    0 @=? L.length ([] :: [Int])\n  , testCase \"length of non-empty list\" $ do\n    4 @=? L.length [1 .. 4 :: Int]\n  , testCase \"length of large list\" $ do\n    big @=? L.length [1 .. big :: Int]\n  , testCase \"reverse of empty list\" $ do\n    [] @=? L.reverse ([] :: [Int])\n  , testCase \"reverse of non-empty list\" $ do\n    [100 , 99 .. 1] @=? L.reverse [1 .. 100 :: Int]\n  , testCase \"map of empty list\" $ do\n    [] @=? L.map (+1) ([] :: [Int])\n  , testCase \"map of non-empty list\" $ do\n    [2, 4 .. 8] @=? L.map (+1) [1, 3 .. 7 :: Int]\n  , testCase \"filter of empty list\" $ do\n    [] @=? L.filter undefined ([] :: [Int])\n  , testCase \"filter of normal list\" $ do\n    [1, 3] @=? L.filter odd [1 .. 4 :: Int]\n  , testCase \"foldl' of empty list\" $ do\n    0 @=? L.foldl' (+) (0 :: Int) []\n  , testCase \"foldl' of non-empty list\" $ do\n    7 @=? L.foldl' (+) (-3) [1 .. 4 :: Int]\n  , testCase \"foldl' of huge list\" $ do\n    big * (big + 1) `div` 2 @=? L.foldl' (+) 0 [1 .. big]\n  , testCase \"foldl' with non-commutative function\" $ do\n    0 @=? L.foldl' (-) 10 [1 .. 4 :: Int]\n  , testCase \"foldl' is not just foldr . flip\" $ do\n    \"fdsa\" @=? L.foldl' (flip (:)) [] \"asdf\"\n  , testCase \"foldl' is accumulator-strict (use seq or BangPatterns)\" $ do\n    r <- try . evaluate $\n      L.foldl' (flip const) () [throw FoldlIsStrictException, ()]\n    Left FoldlIsStrictException @=? (r :: Either FoldlIsStrictException ())\n  , testCase \"foldr as id\" $ do\n    [1 .. big] @=? L.foldr (:) [] [1 .. big]\n  , testCase \"foldr as append\" $ do\n    [1 .. big] @=? L.foldr (:) [100 .. big] [1 .. 99]\n  , testCase \"++ of empty lists\" $ do\n    [] @=? [] L.++ ([] :: [Int])\n  , testCase \"++ of empty and non-empty lists\" $ do\n    [1 .. 4] @=? [] L.++ [1 .. 4 :: Int]\n  , testCase \"++ of non-empty and empty lists\" $ do\n    [1 .. 4] @=? [1 .. 4 :: Int] L.++ []\n  , testCase \"++ of non-empty lists\" $ do\n    [1 .. 5] @=? [1 .. 3] L.++ [4, 5 :: Int]\n  , testCase \"++ of large lists\" $ do\n    [1 .. big] @=? [1 .. big `div` 2] L.++ [1 + big `div` 2 .. big]\n  , testCase \"concat of no lists\" $ do\n    [] @=? L.concat ([] :: [[Int]])\n  , testCase \"concat of list of lists\" $ do\n    [1 .. 6] @=? L.concat [[1, 2], [3], [], [4, 5, 6 :: Int]]\n  , testCase \"concat of large list of small lists\" $ do\n    [1 .. big] @=? L.concat (map (:[]) [1 .. big])\n  ]\n",
        "README.md": "# List Ops\n\nImplement basic list operations\n\nIn functional languages list operations like `length`, `map`, and\n`reduce` are very common. Implement a series of basic list operations,\nwithout using existing functions.\n\nCheck out [Exercism\nHelp](http://help.exercism.io/getting-started-with-haskell.html) for\ninstructions to get started writing Haskell.\n\n## Running Tests\n\nUse `runhaskell` (included in the Haskell Platform) to compile and run your\nHaskell code.\n\n    $ runhaskell -Wall bob_test.hs\n\n## Source\n\n [view source]()\n"
      },
      "fresh": false
    },
    {
      "track_id": "haskell",
      "id": "word-count",
      "track": "haskell",
      "slug": "word-count",
      "files": {
        "word-count_test.hs": "import Test.HUnit (Assertion, (@=?), runTestTT, Test(..), Counts(..))\nimport System.Exit (ExitCode(..), exitWith)\nimport Data.Map (fromList)\nimport WordCount (wordCount)\n\nexitProperly :: IO Counts -> IO ()\nexitProperly m = do\n  counts <- m\n  exitWith $ if failures counts /= 0 || errors counts /= 0 then ExitFailure 1 else ExitSuccess\n\ntestCase :: String -> Assertion -> Test\ntestCase label assertion = TestLabel label (TestCase assertion)\n\nwordCountTests :: [Test]\nwordCountTests =\n  [ testCase \"count one word\" $\n    fromList [(\"word\", 1)] @=? wordCount \"word\"\n  , testCase \"count one of each\" $\n    fromList [(\"one\", 1), (\"of\", 1), (\"each\", 1)] @=? wordCount \"one of each\"\n  , testCase \"count multiple occurrences\" $\n    fromList [(\"one\", 1), (\"fish\", 4), (\"two\", 1),\n              (\"red\", 1), (\"blue\", 1)] @=?\n    wordCount \"one fish two fish red fish blue fish\"\n  , testCase \"ignore punctuation\" $\n    fromList [(\"car\", 1), (\"carpet\", 1), (\"as\", 1),\n              (\"java\", 1), (\"javascript\", 1)] @=?\n    wordCount \"car : carpet as java : javascript!!&@$%^&\"\n  , testCase \"include numbers\" $\n    fromList [(\"testing\", 2), (\"1\", 1), (\"2\", 1)] @=?\n    wordCount \"testing, 1, 2 testing\"\n  , testCase \"normalize case\" $\n    fromList [(\"go\", 3)] @=? wordCount \"go Go GO\"\n  , testCase \"prefix punctuation\" $\n    fromList [(\"testing\", 2), (\"1\", 1), (\"2\", 1)] @=?\n    wordCount \"!%%#testing, 1, 2 testing\"\n  , testCase \"symbols are separators\" $\n    fromList [(\"hey\", 1), (\"my\", 1), (\"spacebar\", 1),\n              (\"is\", 1), (\"broken\", 1)] @=?\n    wordCount \"hey,my_spacebar_is_broken.\"\n  ]\n\nmain :: IO ()\nmain = exitProperly (runTestTT (TestList wordCountTests))\n",
        "README.md": "# Word Count\n\nWrite a program that given a phrase can count the occurrences of each word in that phrase.\n\nFor example for the input `\"olly olly in come free\"`\n\n```plain\nolly: 2\nin: 1\ncome: 1\nfree: 1\n```\n\n\nCheck out [Exercism\nHelp](http://help.exercism.io/getting-started-with-haskell.html) for\ninstructions to get started writing Haskell.\n\n## Running Tests\n\nUse `runhaskell` (included in the Haskell Platform) to compile and run your\nHaskell code.\n\n    $ runhaskell -Wall bob_test.hs\n\n## Source\n\nThe golang tour [view source](http://tour.golang.org)\n"
      },
      "fresh": false
    },
    {
      "track_id": "haskell",
      "id": "leap",
      "track": "haskell",
      "slug": "leap",
      "files": {
        "leap_test.hs": "import Test.HUnit (Assertion, (@=?), runTestTT, Test(..), Counts(..))\nimport System.Exit (ExitCode(..), exitWith)\nimport LeapYear (isLeapYear)\n\nexitProperly :: IO Counts -> IO ()\nexitProperly m = do\n  counts <- m\n  exitWith $ if failures counts /= 0 || errors counts /= 0 then ExitFailure 1 else ExitSuccess\n\ntestCase :: String -> Assertion -> Test\ntestCase label assertion = TestLabel label (TestCase assertion)\n\nmain :: IO ()\nmain = exitProperly $ runTestTT $ TestList\n       [ TestList isLeapYearTests ]\n\nisLeapYearTests :: [Test]\nisLeapYearTests =\n  [ testCase \"vanilla leap year\" $\n    True @=? isLeapYear 1996\n  , testCase \"any old year\" $\n    False @=? isLeapYear 1997\n  , testCase \"century\" $\n    False @=? isLeapYear 1900\n  , testCase \"exceptional century\" $\n    True @=? isLeapYear 2400\n  ]\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\nCheck out [Exercism\nHelp](http://help.exercism.io/getting-started-with-haskell.html) for\ninstructions to get started writing Haskell.\n\n## Running Tests\n\nUse `runhaskell` (included in the Haskell Platform) to compile and run your\nHaskell code.\n\n    $ runhaskell -Wall bob_test.hs\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    }
  ]
}
