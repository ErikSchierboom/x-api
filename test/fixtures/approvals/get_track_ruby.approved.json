{
  "track": {
    "id": "ruby",
    "problems": [
      {
        "id": "ruby/hamming",
        "track_id": "ruby",
        "slug": "hamming",
        "files": {
          "hamming_test.rb": "require 'minitest/autorun'\nrequire_relative 'hamming'\n\nclass HammingTest < MiniTest::Unit::TestCase\n  def test_no_difference_between_identical_strands\n    assert_equal 0, Hamming.compute('A', 'A')\n  end\n\n  def test_complete_hamming_distance_of_for_single_nucleotide_strand\n    skip\n    assert_equal 1, Hamming.compute('A','G')\n  end\n\n  def test_complete_hamming_distance_of_for_small_strand\n    skip\n    assert_equal 2, Hamming.compute('AG','CT')\n  end\n\n  def test_small_hamming_distance\n    skip\n    assert_equal 1, Hamming.compute('AT','CT')\n  end\n\n  def test_small_hamming_distance_in_longer_strand\n    skip\n    assert_equal 1, Hamming.compute('GGACG', 'GGTCG')\n  end\n\n  def test_ignores_extra_length_on_first_strand_when_longer\n    skip\n    assert_equal 1, Hamming.compute('AGAGACTTA', 'AAA')\n  end\n\n  def test_ignores_extra_length_on_other_strand_when_longer\n    skip\n    assert_equal 2, Hamming.compute('AGG', 'AAAACTGACCCACCCCAGG')\n  end\n\n  def test_large_hamming_distance\n    skip\n    assert_equal 4, Hamming.compute('GATACA', 'GCATAA')\n  end\n\n  def test_hamming_distance_in_very_long_strand\n    skip\n    assert_equal 9, Hamming.compute('GGACGGATTCTG', 'AGGACGGATTCT')\n  end\nend\n",
          "README.md": "# Hamming\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or copying of a nucleic acid, in particular DNA. Because nucleic acids are vital to cellular functions, mutations tend to cause a ripple effect throughout the cell. Although mutations are technically mistakes, a very rare mutation may equip the cell with a beneficial attribute. In fact, the macro effects of evolution are attributable by the accumulated result of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point mutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands taken from different genomes with a common ancestor, we get a measure of the minimum number of point mutations that could have occurred on the evolutionary path between the two strands.\n\nThis is called the 'Hamming distance'\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/gigasecond",
        "track_id": "ruby",
        "slug": "gigasecond",
        "files": {
          "gigasecond_test.rb": "require 'minitest/autorun'\nrequire 'date'\nrequire 'time'\nrequire_relative 'gigasecond'\n\nclass GigasecondTest < MiniTest::Unit::TestCase\n\n  def test_1\n    gs = Gigasecond.new(Date.new(2011, 4, 25))\n    assert_equal Date.new(2043, 1, 1), gs.date\n  end\n\n  def test_2\n    skip\n    gs = Gigasecond.new(Date.new(1977, 6, 13))\n    assert_equal Date.new(2009, 2, 19), gs.date\n  end\n\n  def test_3\n    skip\n    gs = Gigasecond.new(Date.new(1959, 7, 19))\n    assert_equal Date.new(1991, 3, 27), gs.date\n  end\n\n  def test_yourself\n    skip\n    your_birthday = Date.new(year, month, day)\n    gs = Gigasecond.new(your_birthday)\n    assert_equal Date.new(2009, 1, 31), gs.date\n  end\n\nend\n",
          "README.md": "# Gigasecond\n\nWrite a program that will calculate the date that someone turned or will celebrate their 1 Gs anniversary.\n\nA gigasecond is one billion (10**9) seconds.\n\n\n## Source\n\nChapter 9 in Chris Pine's online Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=09)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/rna-transcription",
        "track_id": "ruby",
        "slug": "rna-transcription",
        "files": {
          "complement_test.rb": "require 'minitest/autorun'\nrequire_relative 'complement'\n\nclass ComplementTest < MiniTest::Unit::TestCase\n  def test_rna_complement_of_cytosine_is_guanine\n    assert_equal 'G', Complement.of_dna('C')\n  end\n\n  def test_rna_complement_of_guanine_is_cytosine\n    skip\n    assert_equal 'C', Complement.of_dna('G')\n  end\n\n  def test_rna_complement_of_thymine_is_adenine\n    skip\n    assert_equal 'A', Complement.of_dna('T')\n  end\n\n  def test_rna_complement_of_adenine_is_uracil\n    skip\n    assert_equal 'U', Complement.of_dna('A')\n  end\n\n  def test_rna_complement\n    skip\n    assert_equal 'UGCACCAGAAUU', Complement.of_dna('ACGTGGTCTTAA')\n  end\n\n  def test_dna_complement_of_cytosine_is_guanine\n    skip\n    assert_equal 'G', Complement.of_rna('C')\n  end\n\n  def test_dna_complement_of_guanine_is_cytosine\n    skip\n    assert_equal 'C', Complement.of_rna('G')\n  end\n\n  def test_dna_complement_of_uracil_is_adenine\n    skip\n    assert_equal 'A', Complement.of_rna('U')\n  end\n\n  def test_dna_complement_of_adenine_is_thymine\n    skip\n    assert_equal 'T', Complement.of_rna('A')\n  end\n\n  def test_dna_complement\n    skip\n    assert_equal 'ACTTGGGCTGTAC', Complement.of_rna('UGAACCCGACAUG')\n  end\nend\n",
          "README.md": "# Rna Transcription\n\nWrite a program that, given a DNA strand, returns its RNA complement (per RNA transcription).\n\nBoth DNA and RNA strands are a sequence of nucleotides.\n\nThe four nucleotides found in DNA are adenine (**A**), cytosine (**C**), guanine (**G**) and thymidine (**T**).\n\nThe four nucleotides found in RNA are adenine (**A**), cytosine (**C**), guanine (**G**) and uracil (**U**).\n\nGiven a DNA strand, its transcribed RNA strand is formed by replacing each nucleotide with its complement:\n\n* `G` -> `C`\n* `C` -> `G`\n* `T` -> `A`\n* `A` -> `U`\n\n\n\n## Source\n\nRosalind [view source](http://rosalind.info/problems/rna)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/raindrops",
        "track_id": "ruby",
        "slug": "raindrops",
        "files": {
          "raindrops_test.rb": "require 'minitest/autorun'\nrequire_relative 'raindrops'\n\nclass RaindropsTest < MiniTest::Unit::TestCase\n\n  def test_1\n    assert_equal \"1\", Raindrops.convert(1)\n  end\n\n  def test_3\n    skip\n    assert_equal \"Pling\", Raindrops.convert(3)\n  end\n\n  def test_5\n    skip\n    assert_equal \"Plang\", Raindrops.convert(5)\n  end\n\n  def test_7\n    skip\n    assert_equal \"Plong\", Raindrops.convert(7)\n  end\n\n  def test_6\n    skip\n    assert_equal \"Pling\", Raindrops.convert(6)\n  end\n\n  def test_9\n    skip\n    assert_equal \"Pling\", Raindrops.convert(9)\n  end\n\n  def test_10\n    skip\n    assert_equal \"Plang\", Raindrops.convert(10)\n  end\n\n  def test_14\n    skip\n    assert_equal \"Plong\", Raindrops.convert(14)\n  end\n\n  def test_15\n    skip\n    assert_equal \"PlingPlang\", Raindrops.convert(15)\n  end\n\n  def test_21\n    skip\n    assert_equal \"PlingPlong\", Raindrops.convert(21)\n  end\n\n  def test_25\n    skip\n    assert_equal \"Plang\", Raindrops.convert(25)\n  end\n\n  def test_35\n    skip\n    assert_equal \"PlangPlong\", Raindrops.convert(35)\n  end\n\n  def test_49\n    skip\n    assert_equal \"Plong\", Raindrops.convert(49)\n  end\n\n  def test_52\n    skip\n    assert_equal \"52\", Raindrops.convert(52)\n  end\n\n  def test_105\n    skip\n    assert_equal \"PlingPlangPlong\", Raindrops.convert(105)\n  end\n\n  def test_12121\n    skip\n    assert_equal \"12121\", Raindrops.convert(12121)\n  end\n\nend\n",
          "README.md": "# Raindrops\n\nWrite a program that converts a number to a string, the contents of which depends on the number's prime factors.\n\n- If the number contains 3 as a prime factor, output 'Pling'.\n- If the number contains 5 as a prime factor, output 'Plang'.\n- If the number contains 7 as a prime factor, output 'Plong'.\n- If the number does not contain 3, 5, or 7 as a prime factor,\n  just pass the number's digits straight through.\n\n## Examples\n- 28's prime-factorization is 2, 2, 7.\n  - In raindrop-speak, this would be a simple \"Plong\".\n- 1755 prime-factorization is 3, 3, 3, 5, 13.\n  - In raindrop-speak, this would be a \"PlingPlang\".\n- The prime factors of 34 are 2 and 17.\n  - Raindrop-speak doesn't know what to make of that,\n    so it just goes with the straightforward \"34\".\n\n\n## Source\n\nA variation on a famous interview question intended to weed out the obviously incompetent. [view source](http://jumpstartlab.com)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/difference-of-squares",
        "track_id": "ruby",
        "slug": "difference-of-squares",
        "files": {
          "difference_of_squares_test.rb": "require 'minitest/autorun'\nrequire_relative 'squares'\n\nclass SquaresTest < MiniTest::Unit::TestCase\n\n  def test_square_of_sums_to_5\n    assert_equal 225, Squares.new(5).square_of_sums\n  end\n\n  def test_sum_of_squares_to_5\n    skip\n    assert_equal 55, Squares.new(5).sum_of_squares\n  end\n\n  def test_difference_of_sums_to_5\n    skip\n    assert_equal 170, Squares.new(5).difference\n  end\n\n  def test_square_of_sums_to_10\n    skip\n    assert_equal 3025, Squares.new(10).square_of_sums\n  end\n\n  def test_sum_of_squares_to_10\n    skip\n    assert_equal 385, Squares.new(10).sum_of_squares\n  end\n\n  def test_difference_of_sums_to_10\n    skip\n    assert_equal 2640, Squares.new(10).difference\n  end\n\n  def test_square_of_sums_to_100\n    skip\n    assert_equal 25502500, Squares.new(100).square_of_sums\n  end\n\n  def test_sum_of_squares_to_100\n    skip\n    assert_equal 338350, Squares.new(100).sum_of_squares\n  end\n\n  def test_difference_of_sums_to_100\n    skip\n    assert_equal 25164150, Squares.new(100).difference\n  end\n\nend\n",
          "README.md": "# Difference Of Squares\n\nFind the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.\n\nThe sum of the squares of the first ten natural numbers is,\n\n1**2 + 2**2 + ... + 10**2 = 385\n\nThe square of the sum of the first ten natural numbers is,\n\n(1 + 2 + ... + 10)**2 = 55**2 = 3025\n\nHence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.\n\n\n## Source\n\nProblem 6 at Project Euler [view source](http://projecteuler.net/problem=6)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/roman-numerals",
        "track_id": "ruby",
        "slug": "roman-numerals",
        "files": {
          "roman_numerals_test.rb": "require 'minitest/autorun'\nrequire_relative 'roman'\n\nclass RomanTest < MiniTest::Unit::TestCase\n\n  def test_1\n    assert_equal 'I', 1.to_roman\n  end\n\n  def test_2\n    skip\n    assert_equal 'II', 2.to_roman\n  end\n\n  def test_3\n    skip\n    assert_equal 'III', 3.to_roman\n  end\n\n  def test_4\n    skip\n    assert_equal 'IV', 4.to_roman\n  end\n\n  def test_5\n    skip\n    assert_equal 'V', 5.to_roman\n  end\n\n  def test_6\n    skip\n    assert_equal 'VI', 6.to_roman\n  end\n\n  def test_9\n    skip\n    assert_equal 'IX', 9.to_roman\n  end\n\n\n  def test_27\n    skip\n    assert_equal 'XXVII', 27.to_roman\n  end\n\n  def test_48\n    skip\n    assert_equal 'XLVIII', 48.to_roman\n  end\n\n  def test_59\n    skip\n    assert_equal 'LIX', 59.to_roman\n  end\n\n  def test_93\n    skip\n    assert_equal 'XCIII', 93.to_roman\n  end\n\n  def test_141\n    skip\n    assert_equal 'CXLI', 141.to_roman\n  end\n\n  def test_163\n    skip\n    assert_equal 'CLXIII', 163.to_roman\n  end\n\n  def test_402\n    skip\n    assert_equal 'CDII', 402.to_roman\n  end\n\n  def test_575\n    skip\n    assert_equal 'DLXXV', 575.to_roman\n  end\n\n  def test_911\n    skip\n    assert_equal 'CMXI', 911.to_roman\n  end\n\n  def test_1024\n    skip\n    assert_equal 'MXXIV', 1024.to_roman\n  end\n\n  def test_3000\n    skip\n    assert_equal 'MMM', 3000.to_roman\n  end\n\nend\n",
          "README.md": "# Roman Numerals\n\nWrite a function to convert from normal numbers to Roman Numerals: e.g.\n\nThe Romans were a clever bunch. They conquered most of Europe and ruled it for hundreds of years. They invented concrete and straight roads and even bikinis. One thing they never discovered though was the number zero. This made writing and dating extensive histories of their exploits slightly more challenging, but the system of numbers they came up with is still in use today. For example the BBC uses Roman numerals to date their programmes.\n\nThe Romans wrote numbers using letters - I, V, X, L, C, D, M. (notice these letters have lots of straight lines and are hence easy to hack into stone tablets).\n\n```\n 1  => I\n10  => X\n 7  => VII\n```\n\nThere is no need to be able to convert numbers larger than about 3000. (The Romans themselves didn't tend to go any higher)\n\nWikipedia says: Modern Roman numerals ... are written by expressing each digit separately starting with the left most digit and skipping any digit with a value of zero.\n\nTo see this in practice, consider the example of 1990.\n\nIn Roman numerals 1990 is MCMXC:\n\n1000=M\n900=CM\n90=XC\n\n2008 is written as MMVIII:\n\n2000=MM\n8=VIII\n\nSee also: http://www.novaroma.org/via_romana/numbers.html\n\n\n## Source\n\nThe Roman Numeral Kata [view source](http://codingdojo.org/cgi-bin/wiki.pl?KataRomanNumerals)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/robot-name",
        "track_id": "ruby",
        "slug": "robot-name",
        "files": {
          "robot_name_test.rb": "require 'minitest/autorun'\nrequire_relative 'robot'\n\nclass RobotTest < MiniTest::Unit::TestCase\n  def test_has_name\n    assert_match /\\w{2}\\d{3}/, Robot.new.name\n  end\n\n  def test_name_sticks\n    skip\n    robot = Robot.new\n    robot.name\n    assert_equal robot.name, robot.name\n  end\n\n  def test_different_robots_have_different_names\n    skip\n    assert Robot.new.name != Robot.new.name\n  end\n\n  def test_reset_name\n    skip\n    robot = Robot.new\n    name = robot.name\n    robot.reset\n    name2 = robot.name\n    assert name != name2\n    assert_match /\\w{2}\\d{3}/, name2\n  end\nend\n",
          "README.md": "# Robot Name\n\nWrite a program that manages robot factory settings.\n\nWhen robots come off the factory floor, they have no name.\n\nThe first time you boot them up, a random name is generated, such as RX837 or BC811.\n\nEvery once in a while we need to reset a robot to its factory settings, which means that their name gets wiped. The next time you ask, it gets a new name.\n\n\n## For bonus points\n\nDid you get the tests passing and the code clean? If you want to, these are some additional things you could try:\n\n* Random names means a risk of collisions. Make sure the same name is never used twice. Feel free to introduce additional tests.\n\nThen please share your thoughts in a comment on the submission. Did this experiment make the code better? Worse? Did you learn anything from it?\n\n\n## Source\n\nA debugging session with Paul Blackwell at gSchool. [view source](http://gschool.it)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/nth-prime",
        "track_id": "ruby",
        "slug": "nth-prime",
        "files": {
          "nth_prime_test.rb": "require 'minitest/autorun'\nrequire_relative 'prime'\n\nclass TestPrimes < MiniTest::Unit::TestCase\n\n  def test_first\n    assert_equal 2, Prime.nth(1)\n  end\n\n  def test_second\n    skip\n    assert_equal 3, Prime.nth(2)\n  end\n\n  def test_sixth_prime\n    skip\n    assert_equal 13, Prime.nth(6)\n  end\n\n  def test_big_prime\n    skip\n    assert_equal 104743, Prime.nth(10001)\n  end\n\n  def test_weird_case\n    skip\n    assert_raises ArgumentError do\n      Prime.nth(0)\n    end\n  end\nend\n",
          "README.md": "# Nth Prime\n\nWrite a program that can tell you what the nth prime is.\n\nBy listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.\n\n\n## Source\n\nA variation on Problem 7 at Project Euler [view source](http://projecteuler.net/problem=7)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/leap",
        "track_id": "ruby",
        "slug": "leap",
        "files": {
          "leap_test.rb": "require 'date'\nrequire 'minitest/autorun'\nrequire_relative 'year'\n\nclass Date\n  def leap?\n    throw \"Try to implement this yourself instead of using Ruby's implementation.\"\n  end\n\n  alias :gregorian_leap? :leap?\n  alias :julian_leap? :leap?\nend\n\nclass YearTest < MiniTest::Unit::TestCase\n  def test_leap_year\n    assert Year.leap?(1996)\n  end\n\n  def test_non_leap_year\n    skip\n    refute Year.leap?(1997)\n  end\n\n  def test_non_leap_even_year\n    skip\n    refute Year.leap?(1998)\n  end\n\n  def test_century\n    skip\n    refute Year.leap?(1900)\n  end\n\n  def test_fourth_century\n    skip\n    assert Year.leap?(2400)\n  end\nend\n",
          "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.\n1900 is not a leap year, but 2000 is.\n\nIf your language provides a method in the standard library that does this\nlook-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year phenomenon, go watch [this youtube video](http://www.youtube.com/watch?v=xX96xng7sAE).\n\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/grains",
        "track_id": "ruby",
        "slug": "grains",
        "files": {
          "grains_test.rb": "require 'minitest/autorun'\nrequire_relative 'grains'\n\nclass GrainsTest < MiniTest::Unit::TestCase\n\n  def test_square_1\n    assert_equal 1, Grains.new.square(1)\n  end\n\n  def test_square_2\n    skip\n    assert_equal 2, Grains.new.square(2)\n  end\n\n  def test_square_3\n    skip\n    assert_equal 4, Grains.new.square(3)\n  end\n\n  def test_square_4\n    skip\n    assert_equal 8, Grains.new.square(4)\n  end\n\n  def test_square_16\n    skip\n    assert_equal 32768, Grains.new.square(16)\n  end\n\n  def test_square_32\n    skip\n    assert_equal 2147483648, Grains.new.square(32)\n  end\n\n  def test_square_64\n    skip\n    assert_equal 9223372036854775808, Grains.new.square(64)\n  end\n\n  def test_total_grains\n    skip\n    assert_equal 18446744073709551615, Grains.new.total\n  end\n\nend\n",
          "README.md": "# Grains\n\nWrite a program that calculates the number of grains of wheat on a chessboard given that the number on each square doubles.\n\nThere once was a wise servant who saved the life of a prince. The king promised to pay whatever the servant could dream up. Knowing that the king loved chess, the servant told the king he would like to have grains of wheat. One grain on the first square of a chess board. Two grains on the next. Four on the third, and so on.\n\nThere are 64 squares on a chessboard.\n\nWrite a program that shows\n- how many grains were on each square, and\n- the total number of grains\n\n\n## For bonus points\n\nDid you get the tests passing and the code clean? If you want to, these are some additional things you could try:\n\n* Optimize for speed.\n* Optimize for readability.\n\nThen please share your thoughts in a comment on the submission. Did this experiment make the code better? Worse? Did you learn anything from it?\n\n\n## Source\n\nJavaRanch Cattle Drive, exercise 6 [view source](http://www.javaranch.com/grains.jsp)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/word-count",
        "track_id": "ruby",
        "slug": "word-count",
        "files": {
          "word_count_test.rb": "require 'minitest/autorun'\nrequire_relative 'phrase'\n\nclass PhraseTest < MiniTest::Unit::TestCase\n\n  def test_count_one_word\n    phrase = Phrase.new(\"word\")\n    counts = {\"word\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_one_of_each\n    skip\n    phrase = Phrase.new(\"one of each\")\n    counts = {\"one\" => 1, \"of\" => 1, \"each\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_multiple_occurrences\n    skip\n    phrase = Phrase.new(\"one fish two fish red fish blue fish\")\n    counts = {\"one\" => 1, \"fish\" => 4, \"two\" => 1, \"red\" => 1, \"blue\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_everything_just_once\n    skip\n    phrase = Phrase.new(\"all the kings horses and all the kings men\")\n    phrase.word_count # count it an extra time\n    counts = {\n      \"all\" => 2, \"the\" => 2, \"kings\" => 2, \"horses\" => 1, \"and\" => 1, \"men\" => 1\n    }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_ignore_punctuation\n    skip\n    phrase = Phrase.new(\"car : carpet as java : javascript!!&@$%^&\")\n    counts = {\"car\" => 1, \"carpet\" => 1, \"as\" => 1, \"java\" => 1, \"javascript\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_handles_cramped_lists\n    skip\n    phrase = Phrase.new(\"one,two,three\")\n    counts = {\"one\" => 1, \"two\" => 1, \"three\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_include_numbers\n    skip\n    phrase = Phrase.new(\"testing, 1, 2 testing\")\n    counts = {\"testing\" => 2, \"1\" => 1, \"2\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_normalize_case\n    skip\n    phrase = Phrase.new(\"go Go GO\")\n    counts = {\"go\" => 3}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_with_apostrophes\n    skip\n    phrase = Phrase.new(\"First: don't laugh. Then: don't cry.\")\n    counts = {\"first\"=>1, \"don't\"=>2, \"laugh\"=>1, \"then\"=>1, \"cry\"=>1}\n    assert_equal counts, phrase.word_count\n  end\nend\n",
          "README.md": "# Word Count\n\nWrite a program that given a phrase can count the occurrences of each word in that phrase.\n\nFor example for the input `\"olly olly in come free\"`\n\n```plain\nolly: 2\nin: 1\ncome: 1\nfree: 1\n```\n\n\n\n## Source\n\nThe golang tour [view source](http://tour.golang.org)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/bob",
        "track_id": "ruby",
        "slug": "bob",
        "files": {
          "GETTING_STARTED.md": "# Getting Started\n\nThese exercises lean on Test-Driven Development (TDD), but they're not an\nexact match.\n\nThe following steps assume that you are in the same directory as the test\nsuite.\n\n## Step 1\n\nRun the test suite. It's in Minitest, and can be run with ruby:\n\n    $ ruby bob_test.rb\n\nThis will fail, complaining that there is no file called `bob`.\n\nTo fix the error create an empty file called `bob.rb` in the same\ndirectory as the `bob_test.rb` file.\n\n## Step 2\n\nRun the test again. It will give you a new error.\n\n\n    1) Error:\n    BobTest#test_stating_something:\n    NameError: uninitialized constant Bob\n        bob_test.rb:12:in `test_stating_something'\n\nWithin the first test, we are telling ruby to create a new Bob object,\nbut it doesn't know anything about any Bob, so we need to make one.\n\nOpen up the bob.rb file and add the following code:\n\n    class Bob\n    end\n\n## Step 3\n\nRun the test again.\n\n    1) Error:\n    BobTest#test_stating_something:\n    NoMethodError: undefined method `hey' for #<Bob:0x007fa531343e50>\n        bob_test.rb:12:in `test_stating_something'\n\n\nThis time we have a Bob, but we're trying to call a method named \"hey\" on him.\n\nOpen up bob.rb and add a method definition inside the class:\n\n    class Bob\n      def hey\n      end\n    end\n\n## Step 4\n\nRun the test again.\n\n    1) Error:\n    BobTest#test_stating_something:\n    ArgumentError: wrong number of arguments (1 for 0)\n      in `hey' bob_test.rb:12:in `test_stating_something'\n\nThe method \"hey\" needs to take an argument.\n\nThese are examples of method definitions that take arguments:\n\n    def greet(name)\n    end\n\n    def drink(beverage)\n    end\n\nChange the \"hey\" method definition so it takes an argument.\n\n## Step 5\n\nRun the test again.\n\n    1) Failure:\n    BobTest#test_stating_something [bob_test.rb:12]:\n    Expected: \"Whatever.\"\n      Actual: nil\n\nUp until now we've been getting errors, this time we get a failure.\n\nAn error means that ruby cannot even run properly because things like missing\nfiles or referencing classes or methods that don't exist, or because of syntax\nerrors.\n\nA failure is different—when you have a failure the ruby is running just fine,\nbut the test is expecting one outcome, but getting another.\n\nThe test is expecting the hey method to return the string \"Whatever\". The\neasiest way to make it pass, is to simply stick the string \"Whatever\" inside\nthe method definition.\n\n## Step 6\n\nRun the test again.\n\nIf it fails you're going to need to read the error message carefully to figure\nout what went wrong, and then try again.\n\nIf it passes, then you're ready to move to the next step.\n\nOpen the bob_test.rb file, and find the word \"skip\". All but the first test\nstart with \"skip\", which tells Minitest to ignore the test. This is so that\nyou don't have to deal with all the failures at once.\n\nTo activate the next test, delete the \"skip\", and run the test suite again.\n\n## Wash, Rinse, Repeat\n\nDelete one \"skip\" at a time, and make each test pass before you move to the\nnext one.\n\n## Submit\n\nWhen everything is passing, you can submit your code with the following\ncommand:\n\n    $ exercism submit bob.rb\n\n",
          "bob_test.rb": "require 'minitest/autorun'\nbegin\n  require_relative 'bob'\nrescue LoadError => e\n  puts \"\\n\\n#{e.backtrace.first} #{e.message}\"\n  puts DATA.read\n  exit 1\nend\n\nclass BobTest < MiniTest::Unit::TestCase\n  def test_stating_something\n    assert_equal 'Whatever.', ::Bob.new.hey('Tom-ay-to, tom-aaaah-to.')\n  end\n\n  def test_shouting\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('WATCH OUT!')\n  end\n\n  def test_shouting_gibberish\n    skip\n    gibberish = ('A'..'Z').to_a.shuffle[0,10].join\n    assert_equal 'Woah, chill out!', ::Bob.new.hey(gibberish)\n  end\n\n  def test_asking_a_question\n    skip\n    assert_equal 'Sure.', ::Bob.new.hey('Does this cryogenic chamber make me look fat?')\n  end\n\n  def test_asking_a_numeric_question\n    skip\n    assert_equal 'Sure.', ::Bob.new.hey('You are, what, like 15?')\n  end\n\n  def test_asking_gibberish\n    skip\n    gibberish = ('a'..'z').to_a.shuffle[0,10].join\n    assert_equal 'Sure.', ::Bob.new.hey(\"#{gibberish}?\")\n  end\n\n  def test_talking_forcefully\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey(\"Let's go make out behind the gym!\")\n  end\n\n  def test_using_acronyms_in_regular_speech\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey(\"It's OK if you don't want to go to the DMV.\")\n  end\n\n  def test_forceful_questions\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('WHAT THE HELL WERE YOU THINKING?')\n  end\n\n  def test_shouting_numbers\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('1, 2, 3 GO!')\n  end\n\n  def test_only_numbers\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey('1, 2, 3')\n  end\n\n  def test_question_with_only_numbers\n    skip\n    assert_equal 'Sure.', ::Bob.new.hey('4?')\n  end\n\n  def test_shouting_with_special_characters\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!')\n  end\n\n  def test_shouting_with_no_exclamation_mark\n    skip\n    assert_equal 'Woah, chill out!', ::Bob.new.hey('I HATE YOU')\n  end\n\n  def test_statement_containing_question_mark\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey('Ending with ? means a question.')\n  end\n\n  def test_prattling_on\n    skip\n    assert_equal 'Sure.', ::Bob.new.hey(\"Wait! Hang on. Are you going to be OK?\")\n  end\n\n  def test_silence\n    skip\n    assert_equal 'Fine. Be that way!', ::Bob.new.hey('')\n  end\n\n  def test_prolonged_silence\n    skip\n    silence = \" \" * rand(1..10)\n    assert_equal 'Fine. Be that way!', ::Bob.new.hey(silence)\n  end\n\n  def test_on_multiple_line_questions\n    skip\n    assert_equal 'Whatever.', ::Bob.new.hey(%{\nDoes this cryogenic chamber make me look fat?\nno})\n  end\nend\n\n__END__\n\n*****************************************************\nYou got an error, which is exactly as it should be.\nThis is the first step in the Test-Driven Development\n(TDD) process.\n\nThe most important part of the error is\n\n      cannot load such file\n\nIt's looking for a file named bob.rb that doesn't\nexist yet.\n\nTo fix the error, create an empty file named bob.rb\nin the same directory as the bob_test.rb file.\n\nThen run the test again.\n\nFor more guidance as you work on this exercise, see\nGETTING_STARTED.md.\n*****************************************************\n\n",
          "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Woah, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying anything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the first test to pass, go to the first pending or skipped test, and make that pass as well. When all of the tests are passing, feel free to submit.\n\nRemember that passing code is just the first step. The goal is to work towards a solution that is as readable and expressive as you can make it.\n\nPlease make your solution as general as possible. Good code doesn't just pass the test suite, it works with any input that fits the specification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/food-chain",
        "track_id": "ruby",
        "slug": "food-chain",
        "files": {
          "food_chain_test.rb": "require 'minitest/autorun'\nrequire_relative 'food_chain'\n\nclass FoodChainTest < MiniTest::Unit::TestCase\n  attr_reader :song\n  def song\n    @song = ::FoodChainSong.new\n  end\n\n  def teardown\n    @song = nil\n  end\n\n  def test_fly\n    expected = \"I know an old lady who swallowed a fly.\\nI don't know why she swallowed the fly. Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(1)\n  end\n\n  def test_spider\n    skip\n    expected = \"I know an old lady who swallowed a spider.\\nIt wriggled and jiggled and tickled inside her.\\n\" +\n      \"She swallowed the spider to catch the fly.\\n\" +\n      \"I don't know why she swallowed the fly. Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(2)\n  end\n\n  def test_bird\n    skip\n    expected = \"I know an old lady who swallowed a bird.\\n\" +\n      \"How absurd to swallow a bird!\\n\" +\n      \"She swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\\n\" +\n      \"She swallowed the spider to catch the fly.\\n\" +\n      \"I don't know why she swallowed the fly. Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(3)\n  end\n\n  def test_cat\n    skip\n    expected = \"I know an old lady who swallowed a cat.\\n\" +\n      \"Imagine that, to swallow a cat!\\n\" +\n      \"She swallowed the cat to catch the bird.\\n\" +\n      \"She swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\\n\" +\n      \"She swallowed the spider to catch the fly.\\n\" +\n      \"I don't know why she swallowed the fly. \" +\n      \"Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(4)\n  end\n\n  def test_dog\n    skip\n    expected = \"I know an old lady who swallowed a dog.\\n\" +\n      \"What a hog, to swallow a dog!\\n\" +\n      \"She swallowed the dog to catch the cat.\\n\" +\n      \"She swallowed the cat to catch the bird.\\n\" +\n      \"She swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\\n\" +\n      \"She swallowed the spider to catch the fly.\\n\" +\n      \"I don't know why she swallowed the fly. \" +\n      \"Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(5)\n  end\n\n  def test_goat\n    skip\n    expected = \"I know an old lady who swallowed a goat.\\n\" +\n      \"Just opened her throat and swallowed a goat!\\n\" +\n      \"She swallowed the goat to catch the dog.\\n\" +\n      \"She swallowed the dog to catch the cat.\\n\" +\n      \"She swallowed the cat to catch the bird.\\n\" +\n      \"She swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\\n\" +\n      \"She swallowed the spider to catch the fly.\\n\" +\n      \"I don't know why she swallowed the fly. \" +\n      \"Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(6)\n  end\n\n  def test_cow\n    skip\n    expected = \"I know an old lady who swallowed a cow.\\n\" +\n      \"I don't know how she swallowed a cow!\\n\" +\n      \"She swallowed the cow to catch the goat.\\n\" +\n      \"She swallowed the goat to catch the dog.\\n\" +\n      \"She swallowed the dog to catch the cat.\\n\" +\n      \"She swallowed the cat to catch the bird.\\n\" +\n      \"She swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\\n\" +\n      \"She swallowed the spider to catch the fly.\\n\" +\n      \"I don't know why she swallowed the fly. \" +\n      \"Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(7)\n  end\n\n  def test_horse\n    skip\n    expected = \"I know an old lady who swallowed a horse.\\n\" +\n      \"She's dead, of course!\\n\"\n    assert_equal expected, song.verse(8)\n  end\n\n  def test_multiple_verses\n    skip\n    expected = \"\"\n    expected << \"I know an old lady who swallowed a fly.\\nI don't know why she swallowed the fly. Perhaps she'll die.\\n\\n\"\n    expected << \"I know an old lady who swallowed a spider.\\nIt wriggled and jiggled and tickled inside her.\\n\" +\n      \"She swallowed the spider to catch the fly.\\n\" +\n      \"I don't know why she swallowed the fly. Perhaps she'll die.\\n\\n\"\n    assert_equal expected, song.verses(1, 2)\n  end\n\n  def test_the_whole_song\n    skip\n    assert_equal song.verses(1, 8), song.sing\n  end\nend\n",
          "README.md": "# Food Chain\n\nWrite a program that outputs the lyrics of the song 'I Know an Old Lady Who Swallowed a Fly'\n\nThis is a [cumulative song](http://en.wikipedia.org/wiki/Cumulative_song) of unknown origin.\n\nThis is one of many common variants.\n\n```plain\nI know an old lady who swallowed a fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a spider.\nIt wriggled and jiggled and tickled inside her.\nShe swallowed the spider to catch the fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a bird.\nHow absurd to swallow a bird!\nShe swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\nShe swallowed the spider to catch the fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a cat.\nImagine that, to swallow a cat!\nShe swallowed the cat to catch the bird.\nShe swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\nShe swallowed the spider to catch the fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a dog.\nWhat a hog, to swallow a dog!\nShe swallowed the dog to catch the cat.\nShe swallowed the cat to catch the bird.\nShe swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\nShe swallowed the spider to catch the fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a goat.\nJust opened her throat and swallowed a goat!\nShe swallowed the goat to catch the dog.\nShe swallowed the dog to catch the cat.\nShe swallowed the cat to catch the bird.\nShe swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\nShe swallowed the spider to catch the fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a cow.\nI don't know how she swallowed a cow!\nShe swallowed the cow to catch the goat.\nShe swallowed the goat to catch the dog.\nShe swallowed the dog to catch the cat.\nShe swallowed the cat to catch the bird.\nShe swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\nShe swallowed the spider to catch the fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a horse.\nShe's dead, of course!\n```\n\n\n## Source\n\nWikipedia [view source](http://en.wikipedia.org/wiki/There_Was_an_Old_Lady_Who_Swallowed_a_Fly)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/sieve",
        "track_id": "ruby",
        "slug": "sieve",
        "files": {
          "sieve_test.rb": "require 'minitest/autorun'\nrequire_relative 'sieve'\n\nclass SieveTest < MiniTest::Unit::TestCase\n\n  def test_a_few_primes\n    expected = [2, 3, 5, 7]\n    assert_equal expected, Sieve.new(10).primes\n  end\n\n  def test_primes\n    skip\n    expected = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n    assert_equal expected, Sieve.new(1000).primes\n  end\n\nend\n",
          "README.md": "# Sieve\n\nWrite a program that uses the Sieve of Eratosthenes to find all the primes from 2 up to a given number.\n\nThe Sieve of Eratosthenes is a simple, ancient algorithm for finding all prime numbers up to any given limit.\n\nCreate your range, starting at two and ending at the given limit.\n\nThe algorithm consists of repeating the following over and over:\n\n- take the next available unmarked number in your list (it is prime)\n- remove all the multiples of that number (they are not prime)\n\nRepeat until you don't have any possible primes left in your range.\n\nWhen the algorithm terminates, all the numbers in the list that have not been removed are prime.\n\n\n## Source\n\nSieve of Eratosthenes at Wikipedia [view source](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/binary",
        "track_id": "ruby",
        "slug": "binary",
        "files": {
          "binary_test.rb": "require 'minitest/autorun'\nrequire_relative 'binary'\n\nclass BinaryTest < MiniTest::Unit::TestCase\n  def test_binary_1_is_decimal_1\n    assert_equal 1, Binary.new(\"1\").to_decimal\n  end\n\n  def test_binary_10_is_decimal_2\n    skip\n    assert_equal 2, Binary.new(\"10\").to_decimal\n  end\n\n  def test_binary_11_is_decimal_3\n    skip\n    assert_equal 3, Binary.new(\"11\").to_decimal\n  end\n\n  def test_binary_100_is_decimal_4\n    skip\n    assert_equal 4, Binary.new(\"100\").to_decimal\n  end\n\n  def test_binary_1001_is_decimal_9\n    skip\n    assert_equal 9, Binary.new(\"1001\").to_decimal\n  end\n\n  def test_binary_11010_is_decimal_26\n    skip\n    assert_equal 26, Binary.new(\"11010\").to_decimal\n  end\n\n  def test_binary_10001101000_is_decimal_1128\n    skip\n    assert_equal 1128, Binary.new(\"10001101000\").to_decimal\n  end\n\n  def test_invalid_binary_is_decimal_0\n    skip\n    assert_equal 0, Binary.new(\"carrot123\").to_decimal\n  end\nend\n",
          "README.md": "# Binary\n\nWrite a program that will convert a binary number, represented as a string (e.g. '101010'), to its decimal equivalent using first principles\n\nWrite a program passing the tests.\n\nYou will be guided to implement binary to decimal conversion.\nGiven a binary input string, your program should be able to produce a decimal\noutput.\n\n## Note\n- Implement the conversion yourself.\n  Do not use something else to perform the conversion for you.\n- Treat invalid input as binary 0.\n\n## About Binary (Base-2)\nDecimal is a base-10 system.\n\nA number 23 in base 10 notation can be understood\nas a linear combination of powers of 10:\n\n- The rightmost digit gets multiplied by 10^0 = 1\n- The next number gets multiplied by 10^1 = 10\n- …\n- The *n*th number gets multiplied by 10^*(n-1)*.\n- All these values are summed.\n\nSo: `23 => 2*10^1 + 3*10^0 => 2*10 + 3*1 = 23 base 10`\n\nBinary is similar, but uses powers of 2 rather than powers of 10.\n\nSo: `101 => 1*2^2 + 0*2^1 + 1*2^0 => 1*4 + 0*2 + 1*1 => 4 + 1 => 5 base 10`.\n\n\n## Source\n\nAll of Computer Science [view source](http://www.wolframalpha.com/input/?i=binary&a=*C.binary-_*MathWorld-)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/accumulate",
        "track_id": "ruby",
        "slug": "accumulate",
        "files": {
          "accumulate_test.rb": "require 'minitest/autorun'\nrequire_relative 'array'\n\nclass ArrayTest < MiniTest::Unit::TestCase\n\n  def test_empty_accumulation\n    assert_equal [], [].accumulate {|e| e * e}\n  end\n\n  def test_accumulate_squares\n    skip\n    result = [1, 2, 3].accumulate { |number|\n      number * number\n    }\n    assert_equal [1, 4, 9], result\n  end\n\n  def test_accumulate_upcases\n    skip\n    result = %w(hello world).accumulate { |word|\n      word.upcase\n    }\n    assert_equal %w(HELLO WORLD), result\n  end\n\n  def test_accumulate_reversed_strings\n    skip\n    result = %w(the quick brown fox etc).accumulate { |word|\n      word.reverse\n    }\n    assert_equal %w(eht kciuq nworb xof cte), result\n  end\n\n  def test_accumulate_recursively\n    skip\n    result = %w(a b c).accumulate { |char|\n      %w(1 2 3).accumulate { |digit|\n        \"#{char}#{digit}\"\n      }\n    }\n    assert_equal [%w(a1 a2 a3), %w(b1 b2 b3), %w(c1 c2 c3)], result\n  end\n\nend\n",
          "README.md": "# Accumulate\n\nImplement the `accumulate` operation, which, given a collection and an operation to perform on each element of the collection, returns a new collection containing the result of applying that operation to each element of the input collection.\n\nFor example, given the collection of numbers:\n\n- 1, 2, 3, 4, 5\n\nAnd the operation:\n\n- square a number\n\nYour code should be able to produce the collection of squares:\n\n- 1, 4, 9, 16, 25\n\n## Restrictions\n\nKeep your hands off that collect/map/fmap/whatchamacallit functionality\nprovided by your standard library!\nSolve this one yourself using other basic tools instead.\n\nElixir specific: it's perfectly fine to use `Enum.reduce` or\n`Enumerable.reduce`.\n\n\n## Source\n\nConversation with James Edward Gray II [view source](https://twitter.com/jeg2)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/sum-of-multiples",
        "track_id": "ruby",
        "slug": "sum-of-multiples",
        "files": {
          "sum_of_multiples_test.rb": "require 'minitest/autorun'\nrequire_relative 'sum'\n\nclass SumTest < MiniTest::Unit::TestCase\n\n  def test_sum_to_1\n    assert_equal 0, SumOfMultiples.to(1)\n  end\n\n  def test_sum_to_3\n    skip\n    assert_equal 3, SumOfMultiples.to(4)\n  end\n\n  def test_sum_to_10\n    skip\n    assert_equal 23, SumOfMultiples.to(10)\n  end\n\n  def test_sum_to_1000\n    skip\n    assert_equal 233168, SumOfMultiples.to(1000)\n  end\n\n  def test_configurable_7_13_17_to_20\n    skip\n    assert_equal 51, SumOfMultiples.new(7, 13, 17).to(20)\n  end\n\n  def test_configurable_43_47_to_10000\n    skip\n    assert_equal 2203160, SumOfMultiples.new(43, 47).to(10_000)\n  end\n\nend\n",
          "README.md": "# Sum Of Multiples\n\nWrite a program that, given a number, can find the sum of all the multiples of 3 or 5 up to but not including that number.\n\nIf we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nAllow the program to be configured to find the sum of multiples of numbers other than 3 and 5.\n\n\n## Source\n\nA variation on Problem 1 at Project Euler [view source](http://projecteuler.net/problem=1)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/grade-school",
        "track_id": "ruby",
        "slug": "grade-school",
        "files": {
          "grade_school_test.rb": "require 'minitest/autorun'\nrequire_relative 'school'\n\nclass SchoolTest < MiniTest::Unit::TestCase\n\n  def school\n    @school\n  end\n\n  def setup\n    @school = School.new\n  end\n\n  def test_an_empty_school\n    assert_equal({}, school.to_hash)\n  end\n\n  def test_add_student\n    skip\n    school.add(\"Aimee\", 2)\n    assert_equal({2 => [\"Aimee\"]}, school.to_hash)\n  end\n\n  def test_add_more_students_in_same_class\n    skip\n    school.add(\"Blair\", 2)\n    school.add(\"James\", 2)\n    school.add(\"Paul\", 2)\n    assert_equal({2 => [\"Blair\", \"James\", \"Paul\"]}, school.to_hash)\n  end\n\n  def test_add_students_to_different_grades\n    skip\n    school.add(\"Chelsea\", 3)\n    school.add(\"Logan\", 7)\n    assert_equal({3 => [\"Chelsea\"], 7 => [\"Logan\"]}, school.to_hash)\n  end\n\n  def test_get_students_in_a_grade\n    skip\n    school.add(\"Bradley\", 5)\n    school.add(\"Franklin\", 5)\n    school.add(\"Jeff\", 1)\n    assert_equal [\"Bradley\", \"Franklin\"], school.grade(5)\n  end\n\n  def test_get_students_sorted_in_a_grade\n    skip\n    school.add(\"Franklin\", 5)\n    school.add(\"Bradley\", 5)\n    school.add(\"Jeff\", 1)\n    assert_equal [\"Bradley\", \"Franklin\"], school.grade(5)\n  end\n\n  def test_get_students_in_a_non_existant_grade\n    skip\n    assert_equal [], school.grade(1)\n  end\n\n  def test_sort_school\n    skip\n    school.add(\"Jennifer\", 4)\n    school.add(\"Kareem\", 6)\n    school.add(\"Christopher\", 4)\n    school.add(\"Kyle\", 3)\n    sorted = {\n      3 => [\"Kyle\"],\n      4 => [\"Christopher\", \"Jennifer\"],\n      6 => [\"Kareem\"]\n    }\n    assert_equal sorted, school.to_hash\n    assert_equal [3, 4, 6], school.to_hash.keys\n  end\nend\n",
          "README.md": "# Grade School\n\nWrite a small archiving program that stores students' names along with the grade that they are in.\n\nIn the end, you should be able to:\n\n- Add a student's name to the roster for a grade\n  - \"Add Jim to grade 2.\"\n  - \"OK.\"\n- Get a list of all students enrolled in a grade\n  - \"Which students are in grade 2?\"\n  - \"We've only got Jim just now.\"\n- Get a sorted list of all students in all grades.\n  Grades should sort as 1, 2, 3, etc.,\n  and students within a grade should be sorted alphabetically by name.\n  - \"Who all is enrolled in school right now?\"\n  - \"Grade 1: Anna, Barb, and Charlie. Grade 2: Alex, Peter, and Zoe. Grade 3…\"\n\nNote that all our students only have one name.\n(It's a small town, what do you want?)\n\n\n## For bonus points\n\nDid you get the tests passing and the code clean? If you want to, these are some additional things you could try:\n\n* If your implementation allows outside code to mutate the school's internal DB directly, see if you can prevent this. Feel free to introduce additional tests.\n\nThen please share your thoughts in a comment on the submission. Did this experiment make the code better? Worse? Did you learn anything from it?\n\n\n## Source\n\nA pairing session with Phil Battos at gSchool [view source](http://gschool.it)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/series",
        "track_id": "ruby",
        "slug": "series",
        "files": {
          "series_test.rb": "require 'minitest/autorun'\nrequire_relative 'series'\n\nclass SeriesTest < MiniTest::Unit::TestCase\n\n  def test_simple_slices_of_one\n    series = Series.new(\"01234\")\n    assert_equal [[0], [1], [2], [3], [4]], series.slices(1)\n  end\n\n  def test_simple_slices_of_one_again\n    skip\n    series = Series.new(\"92834\")\n    assert_equal [[9], [2], [8], [3], [4]], series.slices(1)\n  end\n\n  def test_simple_slices_of_two\n    skip\n    series = Series.new(\"01234\")\n    assert_equal [[0, 1], [1, 2], [2, 3], [3, 4]], series.slices(2)\n  end\n\n  def test_other_slices_of_two\n    skip\n    series = Series.new(\"98273463\")\n    expected = [[9, 8], [8, 2], [2, 7], [7, 3], [3, 4], [4, 6], [6, 3]]\n    assert_equal expected, series.slices(2)\n  end\n\n  def test_simple_slices_of_two_again\n    skip\n    series = Series.new(\"37103\")\n    assert_equal [[3, 7], [7, 1], [1, 0], [0, 3]], series.slices(2)\n  end\n\n  def test_simple_slices_of_three\n    skip\n    series = Series.new(\"01234\")\n    assert_equal [[0, 1, 2], [1, 2, 3], [2, 3, 4]], series.slices(3)\n  end\n\n  def test_simple_slices_of_three_again\n    skip\n    series = Series.new(\"31001\")\n    assert_equal [[3, 1, 0], [1, 0, 0], [0, 0, 1]], series.slices(3)\n  end\n\n  def test_other_slices_of_three\n    skip\n    series = Series.new(\"982347\")\n    expected = [[9, 8, 2], [8, 2, 3], [2, 3, 4], [3, 4, 7]]\n    assert_equal expected, series.slices(3)\n  end\n\n  def test_simple_slices_of_four\n    skip\n    series = Series.new(\"01234\")\n    assert_equal [[0, 1, 2, 3], [1, 2, 3, 4]], series.slices(4)\n  end\n\n  def test_simple_slices_of_four_again\n    skip\n    series = Series.new(\"91274\")\n    assert_equal [[9, 1, 2, 7], [1, 2, 7, 4]], series.slices(4)\n  end\n\n  def test_simple_slices_of_five\n    skip\n    series = Series.new(\"01234\")\n    assert_equal [[0, 1, 2, 3, 4]], series.slices(5)\n  end\n\n  def test_simple_slices_of_five_again\n    skip\n    series = Series.new(\"81228\")\n    assert_equal [[8, 1, 2, 2, 8]], series.slices(5)\n  end\n\n  def test_simple_slice_that_blows_up\n    skip\n    series = Series.new(\"01234\")\n    assert_raises ArgumentError do\n      series.slices(6)\n    end\n  end\n\n  def test_more_complicated_slice_that_blows_up\n    skip\n    slice_string = \"01032987583\"\n\n    series = Series.new(slice_string)\n    assert_raises ArgumentError do\n      series.slices(slice_string.length + 1)\n    end\n  end\nend\n",
          "README.md": "# Series\n\nWrite a program that will take a string of digits and give you all the possible consecutive number series of length `n` in that string.\n\nFor example, the string \"01234\" has the following 3-digit series:\n\n* 012\n* 123\n* 234\n\nAnd the following 4-digit series:\n\n* 0123\n* 1234\n\nAnd if you ask for a 6-digit series from a 5-digit string,\nyou deserve whatever you get.\n\n\n## Source\n\nA subset of the Problem 8 at Project Euler [view source](http://projecteuler.net/problem=8)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/phone-number",
        "track_id": "ruby",
        "slug": "phone-number",
        "files": {
          "phone_number_test.rb": "require 'minitest/autorun'\nrequire_relative 'phone_number'\n\nclass PhoneNumberTest < MiniTest::Unit::TestCase\n\n  def test_cleans_number\n    number = PhoneNumber.new(\"(123) 456-7890\").number\n    assert_equal \"1234567890\", number\n  end\n\n  def test_cleans_a_different_number\n    skip\n    number = PhoneNumber.new(\"(987) 654-3210\").number\n    assert_equal \"9876543210\", number\n  end\n\n  def test_cleans_number_with_dots\n    skip\n    number = PhoneNumber.new(\"456.123.7890\").number\n    assert_equal \"4561237890\", number\n  end\n\n  def test_invalid_with_letters_in_place_of_numbers\n    skip\n    number = PhoneNumber.new(\"123-abc-1234\").number\n    assert_equal \"0000000000\", number\n  end\n\n  def test_invalid_when_9_digits\n    skip\n    number = PhoneNumber.new(\"123456789\").number\n    assert_equal \"0000000000\", number\n  end\n\n  def test_valid_when_11_digits_and_first_is_1\n    skip\n    number = PhoneNumber.new(\"19876543210\").number\n    assert_equal \"9876543210\", number\n  end\n\n  def test_invalid_when_11_digits\n    skip\n    number = PhoneNumber.new(\"21234567890\").number\n    assert_equal \"0000000000\", number\n  end\n\n  def test_invalid_when_12_digits_and_first_is_1\n    skip\n    number = PhoneNumber.new(\"112345678901\").number\n    assert_equal \"0000000000\", number\n  end\n\n  def test_invalid_when_10_digits_with_extra_letters\n    skip\n    number = PhoneNumber.new(\"1a2a3a4a5a6a7a8a9a0a\").number\n    assert_equal \"0000000000\", number\n  end\n\n  def test_area_code\n    skip\n    number = PhoneNumber.new(\"1234567890\")\n    assert_equal \"123\", number.area_code\n  end\n\n  def test_different_area_code\n    skip\n    number = PhoneNumber.new(\"9876543210\")\n    assert_equal \"987\", number.area_code\n  end\n\n  def test_pretty_print\n    skip\n    number = PhoneNumber.new(\"5551234567\")\n    assert_equal \"(555) 123-4567\", number.to_s\n  end\n\n  def test_pretty_print_with_full_us_phone_number\n    skip\n    number = PhoneNumber.new(\"11234567890\")\n    assert_equal \"(123) 456-7890\", number.to_s\n  end\nend\n",
          "README.md": "# Phone Number\n\nWrite a program that cleans up user-entered phone numbers so that they can be sent SMS messages.\n\nThe rules are as follows:\n\n* If the phone number is less than 10 digits assume that it is bad number\n* If the phone number is 10 digits assume that it is good\n* If the phone number is 11 digits and the first number is 1, trim the 1 and use the first 10 digits\n* If the phone number is 11 digits and the first number is not 1, then it is a bad number\n* If the phone number is more than 11 digits assume that it is a bad number\n\nWe've provided tests, now make them pass.\n\nHint: Only make one test pass at a time.\nDisable the others, then flip each on in turn\nafter you get the current failing one to pass.\n\n\n## Source\n\nEvent Manager by JumpstartLab [view source](http://tutorials.jumpstartlab.com/projects/eventmanager.html)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/prime-factors",
        "track_id": "ruby",
        "slug": "prime-factors",
        "files": {
          "prime_factors_test.rb": "require 'minitest/autorun'\nrequire_relative 'prime_factors'\n\nclass PrimeFactorsTest < MiniTest::Unit::TestCase\n\n  def test_1\n    assert_equal [], PrimeFactors.for(1)\n  end\n\n  def test_2\n    skip\n    assert_equal [2], PrimeFactors.for(2)\n  end\n\n  def test_3\n    skip\n    assert_equal [3], PrimeFactors.for(3)\n  end\n\n  def test_4\n    skip\n    assert_equal [2, 2], PrimeFactors.for(4)\n  end\n\n  def test_6\n    skip\n    assert_equal [2, 3], PrimeFactors.for(6)\n  end\n\n  def test_8\n    skip\n    assert_equal [2, 2, 2], PrimeFactors.for(8)\n  end\n\n  def test_9\n    skip\n    assert_equal [3, 3], PrimeFactors.for(9)\n  end\n\n  def test_27\n    skip\n    assert_equal [3, 3, 3], PrimeFactors.for(27)\n  end\n\n  def test_625\n    skip\n    assert_equal [5, 5, 5, 5], PrimeFactors.for(625)\n  end\n\n  def test_901255\n    skip\n    assert_equal [5, 17, 23, 461], PrimeFactors.for(901255)\n  end\n\n  def test_93819012551\n    skip\n    assert_equal [11, 9539, 894119], PrimeFactors.for(93819012551)\n  end\n\nend\n",
          "README.md": "# Prime Factors\n\nCompute the prime factors of a given natural number.\n\nA prime number is only evenly divisible by itself and 1.\n\nNote that 1 is not a prime number.\n\n## Example\n\nWhat are the prime factors of 60?\n\n- Our first divisor is 2. 2 goes into 60, leaving 30.\n- 2 goes into 30, leaving 15.\n  - 2 doesn't go cleanly into 15. So let's move on to our next divisor, 3.\n- 3 goes cleanly into 15, leaving 5.\n  - 3 does not go cleanly into 5. The next possible factor is 4.\n  - 4 does not go cleanly into 5. The next possible factor is 5.\n- 5 does go cleanly into 5.\n- We're left only with 1, so now, we're done.\n\nOur successful divisors in that computation\nrepresent the list of prime factors of 60: 2, 2, 3, and 5.\n\nYou can check this yourself:\n\n- 2 * 2 * 3 * 5\n- = 4 * 15\n- = 60\n- Success!\n\n\n## Source\n\nThe Prime Factors Kata by Uncle Bob [view source](http://butunclebob.com/ArticleS.UncleBob.ThePrimeFactorsKata)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/strain",
        "track_id": "ruby",
        "slug": "strain",
        "files": {
          "strain_test.rb": "require 'minitest/autorun'\nrequire_relative 'array'\n\nclass ArrayTest < MiniTest::Unit::TestCase\n\n  def test_empty_keep\n    assert_equal [], [].keep {|e| e < 10}\n  end\n\n  def test_keep_everything\n    skip\n    assert_equal [1, 2, 3], [1, 2, 3].keep {|e| e < 10}\n  end\n\n  def test_keep_first_and_last\n    skip\n    assert_equal [1, 3], [1, 2, 3].keep {|e| e.odd?}\n  end\n\n  def test_keep_neither_first_nor_last\n    skip\n    assert_equal [2, 4], [1, 2, 3, 4, 5].keep {|e| e.even?}\n  end\n\n  def test_keep_strings\n    skip\n    words = %w(apple zebra banana zombies cherimoya zelot)\n    result = words.keep {|word| word.start_with?('z')}\n    assert_equal %w(zebra zombies zelot), result\n  end\n\n  def test_keep_arrays\n    skip\n    rows = [\n      [1, 2, 3],\n      [5, 5, 5],\n      [5, 1, 2],\n      [2, 1, 2],\n      [1, 5, 2],\n      [2, 2, 1],\n      [1, 2, 5]\n    ]\n    result = rows.keep {|row| row.include?(5)}\n    assert_equal [[5, 5, 5], [5, 1, 2], [1, 5, 2], [1, 2, 5]], result\n  end\n\n  def test_empty_discard\n    skip\n    assert_equal [], [].discard {|e| e < 10}\n  end\n\n  def test_discard_nothing\n    skip\n    assert_equal [1, 2, 3], [1, 2, 3].discard {|e| e > 10}\n  end\n\n  def test_discard_first_and_last\n    skip\n    assert_equal [2], [1, 2, 3].discard {|e| e.odd?}\n  end\n\n  def test_discard_neither_first_nor_last\n    skip\n    assert_equal [1, 3, 5], [1, 2, 3, 4, 5].discard {|e| e.even?}\n  end\n\n  def test_discard_strings\n    skip\n    words = %w(apple zebra banana zombies cherimoya zelot)\n    result = words.discard {|word| word.start_with?('z')}\n    assert_equal %w(apple banana cherimoya), result\n  end\n\n  def test_discard_arrays\n    skip\n    rows = [\n      [1, 2, 3],\n      [5, 5, 5],\n      [5, 1, 2],\n      [2, 1, 2],\n      [1, 5, 2],\n      [2, 2, 1],\n      [1, 2, 5]\n    ]\n    result = rows.discard {|row| row.include?(5)}\n    assert_equal [[1, 2, 3], [2, 1, 2], [2, 2, 1]], result\n  end\n\nend\n",
          "README.md": "# Strain\n\nImplement the `keep` and `discard` operation on collections. Given a collection and a predicate on the collection's elements, `keep` returns a new collection containing those elements where the predicate is true, while `discard` returns a new collection containing those elements where the predicate is false.\n\nFor example, given the collection of numbers:\n\n- 1, 2, 3, 4, 5\n\nAnd the predicate:\n\n- is the number even?\n\nThen your `keep` operation should produce:\n\n- 2, 4\n\nWhile your `discard` operation should produce:\n\n- 1, 3, 5\n\nNote that the union of `keep` and `discard` is all the elements.\n\n## Restrictions\n\nKeep your hands off that filter/reject/whatchamacallit functionality\nprovided by your standard library!\nSolve this one yourself using other basic tools instead.\n\n\n## Source\n\nConversation with James Edward Gray II [view source](https://twitter.com/jeg2)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/etl",
        "track_id": "ruby",
        "slug": "etl",
        "files": {
          "etl_test.rb": "require 'minitest/autorun'\nrequire_relative 'etl'\n\nclass TransformTest < MiniTest::Unit::TestCase\n\n  def test_transform_one_value\n    old = { 1 => ['A'] }\n    expected = { 'a' => 1 }\n\n    assert_equal expected, ETL.transform(old)\n  end\n\n  def test_transform_more_values\n    skip\n    old = { 1 => ['A', 'E', 'I', 'O', 'U'] }\n    expected = { 'a' => 1, 'e' => 1, 'i' => 1, 'o' => 1, 'u' => 1 }\n\n    assert_equal expected, ETL.transform(old)\n  end\n\n  def test_more_keys\n    skip\n    old = { 1 => ['A', 'E'], 2 => ['D', 'G'] }\n    expected = {\n      'a' => 1,\n      'e' => 1,\n      'd' => 2,\n      'g' => 2\n    }\n\n    assert_equal expected, ETL.transform(old)\n  end\n\n  def test_full_dataset\n    skip\n    old = {\n      1 => %W(A E I O U L N R S T),\n      2 => %W(D G),\n      3 => %W(B C M P),\n      4 => %W(F H V W Y),\n      5 => %W(K),\n      8 => %W(J X),\n      10 => %W(Q Z),\n    }\n\n    expected = {\n      \"a\" => 1, \"b\" => 3, \"c\" => 3, \"d\" => 2, \"e\" => 1,\n      \"f\" => 4, \"g\" => 2, \"h\" => 4, \"i\" => 1, \"j\" => 8,\n      \"k\" => 5, \"l\" => 1, \"m\" => 3, \"n\" => 1, \"o\" => 1,\n      \"p\" => 3, \"q\" => 10, \"r\" => 1, \"s\" => 1, \"t\" => 1,\n      \"u\" => 1, \"v\" => 4, \"w\" => 4, \"x\" => 8, \"y\" => 4,\n      \"z\" => 10\n    }\n\n    assert_equal expected, ETL.transform(old)\n  end\n\nend\n",
          "README.md": "# Etl\n\nWe are going to do the `Transform` step of an Extract-Transform-Load.\n\nThis is a fancy way of saying, \"We have some crufty, legacy data over in this\nsystem, and now we need it in this shiny new system over here, so we're going\nto migrate this.\"\n\n(Typically, this is followed by, \"We're only going to need to run this once.\"\nThat's then typically followed by much forehead slapping and moaning about\nhow stupid we could possibly be.)\n\nWe're going to extract some scrabble scores from a legacy system.\n\nThe old system stored a list of letters per score:\n\n- 1 point: \"A\", \"E\", \"I\", \"O\", \"U\", \"L\", \"N\", \"R\", \"S\", \"T\",\n- 2 points: \"D\", \"G\",\n- 3 points: \"B\", \"C\", \"M\", \"P\",\n- 4 points: \"F\", \"H\", \"V\", \"W\", \"Y\",\n- 5 points: \"K\",\n- 8 points: \"J\", \"X\",\n- 10 points: \"Q\", \"Z\",\n\nThe shiny new scrabble system instead stores the score per letter,\nwhich makes it much faster and easier to calculate the score for a\nword. It also stores the letters in lower-case regardless of the\ncase of the input letters:\n\n- \"a\" is worth 1 point.\n- \"b\" is worth 3 points.\n- \"c\" is worth 3 points.\n- \"d\" is worth 2 points.\n- Etc.\n\nYour mission, should you choose to accept it, is to write a program that\ntransforms the legacy data format to the shiny new format.\n\nNote that both the old and the new system use strings to represent\nletters, even in languages that have a separate data type for characters.\n\n\n## Source\n\nThe Jumpstart Lab team [view source](http://jumpstartlab.com)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/trinary",
        "track_id": "ruby",
        "slug": "trinary",
        "files": {
          "trinary_test.rb": "require 'minitest/autorun'\nrequire_relative 'trinary'\n\nclass TrinaryTest < MiniTest::Unit::TestCase\n  def test_trinary_1_is_decimal_1\n    assert_equal 1, Trinary.new(\"1\").to_decimal\n  end\n\n  def test_trinary_2_is_decimal_2\n    skip\n    assert_equal 2, Trinary.new(\"2\").to_decimal\n  end\n\n  def test_trinary_10_is_decimal_3\n    skip\n    assert_equal 3, Trinary.new(\"10\").to_decimal\n  end\n\n  def test_trinary_11_is_decimal_4\n    skip\n    assert_equal 4, Trinary.new(\"11\").to_decimal\n  end\n\n  def test_trinary_100_is_decimal_9\n    skip\n    assert_equal 9, Trinary.new(\"100\").to_decimal\n  end\n\n  def test_trinary_112_is_decimal_14\n    skip\n    assert_equal 14, Trinary.new(\"112\").to_decimal\n  end\n\n  def test_trinary_222_is_26\n    skip\n    assert_equal 26, Trinary.new(\"222\").to_decimal\n  end\n\n  def test_trinary_1122000120_is_32091\n    skip\n    assert_equal 32091, Trinary.new(\"1122000120\").to_decimal\n  end\n\n  def test_invalid_trinary_is_decimal_0\n    skip\n    assert_equal 0, Trinary.new(\"carrot\").to_decimal\n  end\nend\n",
          "README.md": "# Trinary\n\nWrite a program that will convert a trinary number, represented as a string (e.g. '102012'), to its decimal equivalent using first principles.\n\nThe program should consider strings specifying an invalid trinary as the value 0.\n\nTrinary numbers contain three symbols: 0, 1, and 2.\n\nThe last place in a trinary number is the 1's place. The second to last is the 3's place, the third to last is the 9's place, etc.\n\n```bash\n# \"102012\"\n    1       0       2       0       1       2    # the number\n1*3^5 + 0*3^4 + 2*3^3 + 0*3^2 + 1*3^1 + 2*3^0    # the value\n  243 +     0 +    54 +     0 +     3 +     2 =  302\n```\n\n\n## Source\n\nAll of Computer Science [view source](http://www.wolframalpha.com/input/?i=binary&a=*C.binary-_*MathWorld-)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/beer-song",
        "track_id": "ruby",
        "slug": "beer-song",
        "files": {
          "beer_song_test.rb": "require 'minitest/autorun'\nrequire_relative 'beer_song'\n\nclass BeerSongTest < MiniTest::Unit::TestCase\n\n  def song\n    @song = ::BeerSong.new\n  end\n\n  def teardown\n    @song = nil\n  end\n\n  def test_a_typical_verse\n    expected = \"8 bottles of beer on the wall, 8 bottles of beer.\\nTake one down and pass it around, 7 bottles of beer on the wall.\\n\"\n    assert_equal expected, song.verse(8)\n  end\n\n  def test_another_typical_verse\n    skip\n    expected = \"3 bottles of beer on the wall, 3 bottles of beer.\\nTake one down and pass it around, 2 bottles of beer on the wall.\\n\"\n    assert_equal expected, song.verse(3)\n  end\n\n  def test_verse_1\n    skip\n    expected = \"1 bottle of beer on the wall, 1 bottle of beer.\\nTake it down and pass it around, no more bottles of beer on the wall.\\n\"\n    assert_equal expected, song.verse(1)\n  end\n\n  def test_verse_2\n    skip\n    expected = \"2 bottles of beer on the wall, 2 bottles of beer.\\nTake one down and pass it around, 1 bottle of beer on the wall.\\n\"\n    assert_equal expected, song.verse(2)\n  end\n\n  def test_verse_0\n    skip\n    expected = \"No more bottles of beer on the wall, no more bottles of beer.\\nGo to the store and buy some more, 99 bottles of beer on the wall.\\n\"\n    assert_equal expected, song.verse(0)\n  end\n\n  def test_several_verses\n    skip\n    expected = \"8 bottles of beer on the wall, 8 bottles of beer.\\nTake one down and pass it around, 7 bottles of beer on the wall.\\n\\n7 bottles of beer on the wall, 7 bottles of beer.\\nTake one down and pass it around, 6 bottles of beer on the wall.\\n\\n6 bottles of beer on the wall, 6 bottles of beer.\\nTake one down and pass it around, 5 bottles of beer on the wall.\\n\\n\"\n    assert_equal expected, song.verses(8, 6)\n  end\n\n  def test_the_whole_song\n    skip\n    assert_equal song.verses(99, 0), song.sing\n  end\nend\n",
          "README.md": "# Beer Song\n\nWrite a program which produces the lyrics to that beloved classic, that field-trip favorite: 99 Bottles of Beer on the Wall.\n\nNote that not all verses are identical.\n\n```plain\n99 bottles of beer on the wall, 99 bottles of beer.\nTake one down and pass it around, 98 bottles of beer on the wall.\n\n98 bottles of beer on the wall, 98 bottles of beer.\nTake one down and pass it around, 97 bottles of beer on the wall.\n\n97 bottles of beer on the wall, 97 bottles of beer.\nTake one down and pass it around, 96 bottles of beer on the wall.\n\n96 bottles of beer on the wall, 96 bottles of beer.\nTake one down and pass it around, 95 bottles of beer on the wall.\n\n95 bottles of beer on the wall, 95 bottles of beer.\nTake one down and pass it around, 94 bottles of beer on the wall.\n\n94 bottles of beer on the wall, 94 bottles of beer.\nTake one down and pass it around, 93 bottles of beer on the wall.\n\n93 bottles of beer on the wall, 93 bottles of beer.\nTake one down and pass it around, 92 bottles of beer on the wall.\n\n92 bottles of beer on the wall, 92 bottles of beer.\nTake one down and pass it around, 91 bottles of beer on the wall.\n\n91 bottles of beer on the wall, 91 bottles of beer.\nTake one down and pass it around, 90 bottles of beer on the wall.\n\n90 bottles of beer on the wall, 90 bottles of beer.\nTake one down and pass it around, 89 bottles of beer on the wall.\n\n89 bottles of beer on the wall, 89 bottles of beer.\nTake one down and pass it around, 88 bottles of beer on the wall.\n\n88 bottles of beer on the wall, 88 bottles of beer.\nTake one down and pass it around, 87 bottles of beer on the wall.\n\n87 bottles of beer on the wall, 87 bottles of beer.\nTake one down and pass it around, 86 bottles of beer on the wall.\n\n86 bottles of beer on the wall, 86 bottles of beer.\nTake one down and pass it around, 85 bottles of beer on the wall.\n\n85 bottles of beer on the wall, 85 bottles of beer.\nTake one down and pass it around, 84 bottles of beer on the wall.\n\n84 bottles of beer on the wall, 84 bottles of beer.\nTake one down and pass it around, 83 bottles of beer on the wall.\n\n83 bottles of beer on the wall, 83 bottles of beer.\nTake one down and pass it around, 82 bottles of beer on the wall.\n\n82 bottles of beer on the wall, 82 bottles of beer.\nTake one down and pass it around, 81 bottles of beer on the wall.\n\n81 bottles of beer on the wall, 81 bottles of beer.\nTake one down and pass it around, 80 bottles of beer on the wall.\n\n80 bottles of beer on the wall, 80 bottles of beer.\nTake one down and pass it around, 79 bottles of beer on the wall.\n\n79 bottles of beer on the wall, 79 bottles of beer.\nTake one down and pass it around, 78 bottles of beer on the wall.\n\n78 bottles of beer on the wall, 78 bottles of beer.\nTake one down and pass it around, 77 bottles of beer on the wall.\n\n77 bottles of beer on the wall, 77 bottles of beer.\nTake one down and pass it around, 76 bottles of beer on the wall.\n\n76 bottles of beer on the wall, 76 bottles of beer.\nTake one down and pass it around, 75 bottles of beer on the wall.\n\n75 bottles of beer on the wall, 75 bottles of beer.\nTake one down and pass it around, 74 bottles of beer on the wall.\n\n74 bottles of beer on the wall, 74 bottles of beer.\nTake one down and pass it around, 73 bottles of beer on the wall.\n\n73 bottles of beer on the wall, 73 bottles of beer.\nTake one down and pass it around, 72 bottles of beer on the wall.\n\n72 bottles of beer on the wall, 72 bottles of beer.\nTake one down and pass it around, 71 bottles of beer on the wall.\n\n71 bottles of beer on the wall, 71 bottles of beer.\nTake one down and pass it around, 70 bottles of beer on the wall.\n\n70 bottles of beer on the wall, 70 bottles of beer.\nTake one down and pass it around, 69 bottles of beer on the wall.\n\n69 bottles of beer on the wall, 69 bottles of beer.\nTake one down and pass it around, 68 bottles of beer on the wall.\n\n68 bottles of beer on the wall, 68 bottles of beer.\nTake one down and pass it around, 67 bottles of beer on the wall.\n\n67 bottles of beer on the wall, 67 bottles of beer.\nTake one down and pass it around, 66 bottles of beer on the wall.\n\n66 bottles of beer on the wall, 66 bottles of beer.\nTake one down and pass it around, 65 bottles of beer on the wall.\n\n65 bottles of beer on the wall, 65 bottles of beer.\nTake one down and pass it around, 64 bottles of beer on the wall.\n\n64 bottles of beer on the wall, 64 bottles of beer.\nTake one down and pass it around, 63 bottles of beer on the wall.\n\n63 bottles of beer on the wall, 63 bottles of beer.\nTake one down and pass it around, 62 bottles of beer on the wall.\n\n62 bottles of beer on the wall, 62 bottles of beer.\nTake one down and pass it around, 61 bottles of beer on the wall.\n\n61 bottles of beer on the wall, 61 bottles of beer.\nTake one down and pass it around, 60 bottles of beer on the wall.\n\n60 bottles of beer on the wall, 60 bottles of beer.\nTake one down and pass it around, 59 bottles of beer on the wall.\n\n59 bottles of beer on the wall, 59 bottles of beer.\nTake one down and pass it around, 58 bottles of beer on the wall.\n\n58 bottles of beer on the wall, 58 bottles of beer.\nTake one down and pass it around, 57 bottles of beer on the wall.\n\n57 bottles of beer on the wall, 57 bottles of beer.\nTake one down and pass it around, 56 bottles of beer on the wall.\n\n56 bottles of beer on the wall, 56 bottles of beer.\nTake one down and pass it around, 55 bottles of beer on the wall.\n\n55 bottles of beer on the wall, 55 bottles of beer.\nTake one down and pass it around, 54 bottles of beer on the wall.\n\n54 bottles of beer on the wall, 54 bottles of beer.\nTake one down and pass it around, 53 bottles of beer on the wall.\n\n53 bottles of beer on the wall, 53 bottles of beer.\nTake one down and pass it around, 52 bottles of beer on the wall.\n\n52 bottles of beer on the wall, 52 bottles of beer.\nTake one down and pass it around, 51 bottles of beer on the wall.\n\n51 bottles of beer on the wall, 51 bottles of beer.\nTake one down and pass it around, 50 bottles of beer on the wall.\n\n50 bottles of beer on the wall, 50 bottles of beer.\nTake one down and pass it around, 49 bottles of beer on the wall.\n\n49 bottles of beer on the wall, 49 bottles of beer.\nTake one down and pass it around, 48 bottles of beer on the wall.\n\n48 bottles of beer on the wall, 48 bottles of beer.\nTake one down and pass it around, 47 bottles of beer on the wall.\n\n47 bottles of beer on the wall, 47 bottles of beer.\nTake one down and pass it around, 46 bottles of beer on the wall.\n\n46 bottles of beer on the wall, 46 bottles of beer.\nTake one down and pass it around, 45 bottles of beer on the wall.\n\n45 bottles of beer on the wall, 45 bottles of beer.\nTake one down and pass it around, 44 bottles of beer on the wall.\n\n44 bottles of beer on the wall, 44 bottles of beer.\nTake one down and pass it around, 43 bottles of beer on the wall.\n\n43 bottles of beer on the wall, 43 bottles of beer.\nTake one down and pass it around, 42 bottles of beer on the wall.\n\n42 bottles of beer on the wall, 42 bottles of beer.\nTake one down and pass it around, 41 bottles of beer on the wall.\n\n41 bottles of beer on the wall, 41 bottles of beer.\nTake one down and pass it around, 40 bottles of beer on the wall.\n\n40 bottles of beer on the wall, 40 bottles of beer.\nTake one down and pass it around, 39 bottles of beer on the wall.\n\n39 bottles of beer on the wall, 39 bottles of beer.\nTake one down and pass it around, 38 bottles of beer on the wall.\n\n38 bottles of beer on the wall, 38 bottles of beer.\nTake one down and pass it around, 37 bottles of beer on the wall.\n\n37 bottles of beer on the wall, 37 bottles of beer.\nTake one down and pass it around, 36 bottles of beer on the wall.\n\n36 bottles of beer on the wall, 36 bottles of beer.\nTake one down and pass it around, 35 bottles of beer on the wall.\n\n35 bottles of beer on the wall, 35 bottles of beer.\nTake one down and pass it around, 34 bottles of beer on the wall.\n\n34 bottles of beer on the wall, 34 bottles of beer.\nTake one down and pass it around, 33 bottles of beer on the wall.\n\n33 bottles of beer on the wall, 33 bottles of beer.\nTake one down and pass it around, 32 bottles of beer on the wall.\n\n32 bottles of beer on the wall, 32 bottles of beer.\nTake one down and pass it around, 31 bottles of beer on the wall.\n\n31 bottles of beer on the wall, 31 bottles of beer.\nTake one down and pass it around, 30 bottles of beer on the wall.\n\n30 bottles of beer on the wall, 30 bottles of beer.\nTake one down and pass it around, 29 bottles of beer on the wall.\n\n29 bottles of beer on the wall, 29 bottles of beer.\nTake one down and pass it around, 28 bottles of beer on the wall.\n\n28 bottles of beer on the wall, 28 bottles of beer.\nTake one down and pass it around, 27 bottles of beer on the wall.\n\n27 bottles of beer on the wall, 27 bottles of beer.\nTake one down and pass it around, 26 bottles of beer on the wall.\n\n26 bottles of beer on the wall, 26 bottles of beer.\nTake one down and pass it around, 25 bottles of beer on the wall.\n\n25 bottles of beer on the wall, 25 bottles of beer.\nTake one down and pass it around, 24 bottles of beer on the wall.\n\n24 bottles of beer on the wall, 24 bottles of beer.\nTake one down and pass it around, 23 bottles of beer on the wall.\n\n23 bottles of beer on the wall, 23 bottles of beer.\nTake one down and pass it around, 22 bottles of beer on the wall.\n\n22 bottles of beer on the wall, 22 bottles of beer.\nTake one down and pass it around, 21 bottles of beer on the wall.\n\n21 bottles of beer on the wall, 21 bottles of beer.\nTake one down and pass it around, 20 bottles of beer on the wall.\n\n20 bottles of beer on the wall, 20 bottles of beer.\nTake one down and pass it around, 19 bottles of beer on the wall.\n\n19 bottles of beer on the wall, 19 bottles of beer.\nTake one down and pass it around, 18 bottles of beer on the wall.\n\n18 bottles of beer on the wall, 18 bottles of beer.\nTake one down and pass it around, 17 bottles of beer on the wall.\n\n17 bottles of beer on the wall, 17 bottles of beer.\nTake one down and pass it around, 16 bottles of beer on the wall.\n\n16 bottles of beer on the wall, 16 bottles of beer.\nTake one down and pass it around, 15 bottles of beer on the wall.\n\n15 bottles of beer on the wall, 15 bottles of beer.\nTake one down and pass it around, 14 bottles of beer on the wall.\n\n14 bottles of beer on the wall, 14 bottles of beer.\nTake one down and pass it around, 13 bottles of beer on the wall.\n\n13 bottles of beer on the wall, 13 bottles of beer.\nTake one down and pass it around, 12 bottles of beer on the wall.\n\n12 bottles of beer on the wall, 12 bottles of beer.\nTake one down and pass it around, 11 bottles of beer on the wall.\n\n11 bottles of beer on the wall, 11 bottles of beer.\nTake one down and pass it around, 10 bottles of beer on the wall.\n\n10 bottles of beer on the wall, 10 bottles of beer.\nTake one down and pass it around, 9 bottles of beer on the wall.\n\n9 bottles of beer on the wall, 9 bottles of beer.\nTake one down and pass it around, 8 bottles of beer on the wall.\n\n8 bottles of beer on the wall, 8 bottles of beer.\nTake one down and pass it around, 7 bottles of beer on the wall.\n\n7 bottles of beer on the wall, 7 bottles of beer.\nTake one down and pass it around, 6 bottles of beer on the wall.\n\n6 bottles of beer on the wall, 6 bottles of beer.\nTake one down and pass it around, 5 bottles of beer on the wall.\n\n5 bottles of beer on the wall, 5 bottles of beer.\nTake one down and pass it around, 4 bottles of beer on the wall.\n\n4 bottles of beer on the wall, 4 bottles of beer.\nTake one down and pass it around, 3 bottles of beer on the wall.\n\n3 bottles of beer on the wall, 3 bottles of beer.\nTake one down and pass it around, 2 bottles of beer on the wall.\n\n2 bottles of beer on the wall, 2 bottles of beer.\nTake one down and pass it around, 1 bottle of beer on the wall.\n\n1 bottle of beer on the wall, 1 bottle of beer.\nTake it down and pass it around, no more bottles of beer on the wall.\n\nNo more bottles of beer on the wall, no more bottles of beer.\nGo to the store and buy some more, 99 bottles of beer on the wall.\n```\n\n## For bonus points\n\nDid you get the tests passing and the code clean? If you want to, these are some additional things you could try:\n\n* Remove as much duplication as you possibly can.\n* Optimize for readability, even if it means introducing duplication.\n* If you've removed all the duplication, do you have a lot of conditionals? Try replacing the conditionals with polymorphism, if it applies in this language. How readable is it?\n\nThen please share your thoughts in a comment on the submission. Did this experiment make the code better? Worse? Did you learn anything from it?\n\n\n\n## Source\n\nLearn to Program by Chris Pine [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/space-age",
        "track_id": "ruby",
        "slug": "space-age",
        "files": {
          "space_age_test.rb": "require 'minitest/autorun'\nrequire_relative 'space_age'\n\nclass SpaceAgeTest < MiniTest::Unit::TestCase\n\n  def test_age_in_seconds\n    age = SpaceAge.new(1_000_000)\n    assert_equal 1_000_000, age.seconds\n  end\n\n  def test_age_in_earth_years\n    skip\n    age = SpaceAge.new(1_000_000_000)\n    assert_equal 31.69, age.on_earth\n  end\n\n  def test_age_in_mercury_years\n    skip\n    age = SpaceAge.new(2_134_835_688)\n    assert_equal 67.65, age.on_earth\n    assert_equal 280.88, age.on_mercury\n  end\n\n  def test_age_in_venus_years\n    skip\n    age = SpaceAge.new(189_839_836)\n    assert_equal 6.02, age.on_earth\n    assert_equal 9.78, age.on_venus\n  end\n\n  def test_age_on_mars\n    skip\n    age = SpaceAge.new(2_329_871_239)\n    assert_equal 73.83, age.on_earth\n    assert_equal 39.25, age.on_mars\n  end\n\n  def test_age_on_jupiter\n    skip\n    age = SpaceAge.new(901_876_382)\n    assert_equal 28.58, age.on_earth\n    assert_equal 2.41, age.on_jupiter\n  end\n\n  def test_age_on_saturn\n    skip\n    age = SpaceAge.new(3_000_000_000)\n    assert_equal 95.06, age.on_earth\n    assert_equal 3.23, age.on_saturn\n  end\n\n  def test_age_on_uranus\n    skip\n    age = SpaceAge.new(3_210_123_456)\n    assert_equal 101.72, age.on_earth\n    assert_equal 1.21, age.on_uranus\n  end\n\n  def test_age_on_neptune\n    skip\n    age = SpaceAge.new(8_210_123_456)\n    assert_equal 260.16, age.on_earth\n    assert_equal 1.58, age.on_neptune\n  end\n\nend\n",
          "README.md": "# Space Age\n\nWrite a program that, given an age in seconds, calculates how old someone is in terms of a given planet's solar years.\n\nGiven an age in seconds, calculate how old someone would be on:\n\n   - Earth: orbital period 365.25 Earth days, or 31557600 seconds\n   - Mercury: orbital period 0.2408467 Earth years\n   - Venus: orbital period 0.61519726 Earth years\n   - Mars: orbital period 1.8808158 Earth years\n   - Jupiter: orbital period 11.862615 Earth years\n   - Saturn: orbital period 29.447498 Earth years\n   - Uranus: orbital period 84.016846 Earth years\n   - Neptune: orbital period 164.79132 Earth years\n\nSo if you were told someone were 1,000,000,000 seconds old,\nyou should be able to say that they're 31 Earth-years old.\n\nIf you're wondering why Pluto didn't make the cut,\ngo watch [this youtube video](http://www.youtube.com/watch?v=Z_2gbGXzFbs).\n\n\n## Source\n\nPartially inspired by Chapter 1 in Chris Pine's online Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=01)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/anagram",
        "track_id": "ruby",
        "slug": "anagram",
        "files": {
          "anagram_test.rb": "require 'minitest/autorun'\nrequire_relative 'anagram'\n\nclass AnagramTest < MiniTest::Unit::TestCase\n\n  def test_no_matches\n    detector = Anagram.new('diaper')\n    assert_equal [], detector.match(%w(hello world zombies pants))\n  end\n\n  def test_detect_simple_anagram\n    skip\n    detector = Anagram.new('ant')\n    anagrams = detector.match(['tan', 'stand', 'at'])\n    assert_equal ['tan'], anagrams\n  end\n\n  def test_detect_multiple_anagrams\n    skip\n    detector = Anagram.new('master')\n    anagrams = detector.match(['stream', 'pigeon', 'maters'])\n    assert_equal ['maters', 'stream'], anagrams.sort\n  end\n\n  def test_does_not_confuse_different_duplicates\n    skip\n    detector = Anagram.new('galea')\n    assert_equal [], detector.match(['eagle'])\n  end\n\n  def test_identical_word_is_not_anagram\n    skip\n    detector = Anagram.new('corn')\n    anagrams = detector.match %w(corn dark Corn rank CORN cron park)\n    assert_equal ['cron'], anagrams\n  end\n\n  def test_eliminate_anagrams_with_same_checksum\n    skip\n    detector = Anagram.new('mass')\n    assert_equal [], detector.match(['last'])\n  end\n\n  def test_eliminate_anagram_subsets\n    skip\n    detector = Anagram.new('good')\n    assert_equal [], detector.match(['dog', 'goody'])\n  end\n\n  def test_detect_anagram\n    skip\n    detector = Anagram.new('listen')\n    anagrams = detector.match %w(enlists google inlets banana)\n    assert_equal ['inlets'], anagrams\n  end\n\n  def test_multiple_anagrams\n    skip\n    detector = Anagram.new('allergy')\n    anagrams = detector.match %w(gallery ballerina regally clergy largely leading)\n    assert_equal ['gallery', 'largely', 'regally'], anagrams.sort\n  end\n\n  def test_anagrams_are_case_insensitive\n    skip\n    detector = Anagram.new('Orchestra')\n    anagrams = detector.match %w(cashregister Carthorse radishes)\n    assert_equal ['Carthorse'], anagrams\n  end\nend\n",
          "README.md": "# Anagram\n\nWrite a program that, given a word and a list of possible anagrams, selects the correct sublist.\n\nGiven `\"listen\"` and a list of candidates like `\"enlists\" \"google\" \"inlets\" \"banana\"` the program should return a list containing `\"inlets\"`.\n\n\n## Source\n\nInspired by the Extreme Startup game [view source](https://github.com/rchatley/extreme_startup)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/binary-search-tree",
        "track_id": "ruby",
        "slug": "binary-search-tree",
        "files": {
          "binary_search_tree_test.rb": "require 'minitest/autorun'\nrequire_relative 'bst'\n\nclass BstTest < MiniTest::Unit::TestCase\n  def test_data_is_retained\n    assert_equal 4, Bst.new(4).data\n  end\n\n  def test_inserting_less\n    skip\n    four = Bst.new 4\n    four.insert 2\n    assert_equal 4, four.data\n    assert_equal 2, four.left.data\n  end\n\n  def test_inserting_same\n    skip\n    four = Bst.new 4\n    four.insert 4\n    assert_equal 4, four.data\n    assert_equal 4, four.left.data\n  end\n\n  def test_inserting_right\n    skip\n    four = Bst.new 4\n    four.insert 5\n    assert_equal 4, four.data\n    assert_equal 5, four.right.data\n  end\n\n  def test_complex_tree\n    skip\n    four = Bst.new 4\n    four.insert 2\n    four.insert 6\n    four.insert 1\n    four.insert 3\n    four.insert 7\n    four.insert 5\n    assert_equal 4, four.data\n    assert_equal 2, four.left.data\n    assert_equal 1, four.left.left.data\n    assert_equal 3, four.left.right.data\n    assert_equal 6, four.right.data\n    assert_equal 5, four.right.left.data\n    assert_equal 7, four.right.right.data\n  end\n\n  def record_all_data(bst)\n    all_data = []\n    bst.each { |data| all_data << data }\n    all_data\n  end\n\n  def test_iterating_one_element\n    skip\n    assert_equal [4], record_all_data(Bst.new 4)\n  end\n\n  def test_iterating_over_smaller_element\n    skip\n    four = Bst.new 4\n    four.insert 2\n    assert_equal [2, 4], record_all_data(four)\n  end\n\n  def test_iterating_over_larger_element\n    skip\n    four = Bst.new 4\n    four.insert 5\n    assert_equal [4, 5], record_all_data(four)\n  end\n\n  def test_iterating_over_complex_tree\n    skip\n    four = Bst.new 4\n    four.insert 2\n    four.insert 1\n    four.insert 3\n    four.insert 6\n    four.insert 7\n    four.insert 5\n    assert_equal [1, 2, 3, 4, 5, 6, 7], record_all_data(four)\n  end\nend\n",
          "README.md": "# Binary Search Tree\n\nWrite a program that inserts numbers and searches in a binary tree.\n\nWhen we need to represent sorted data, an array does not make a good data structure.\n\nSay we have the array `[1, 3, 4, 5]`, and we add 2 to it so it becomes `[1, 3, 4, 5, 2]` now we must sort the entire array again! We can improve on this by realizing that we only need to make space for the new item `[1, nil, 3, 4, 5]`, and then adding the item in the space we added. But this still requires us to shift many elements down by one.\n\nBinary Search Trees, however, can operate on sorted data much more efficiently.\n\nA binary search tree consists of a series of connected nodes. Each node contains a piece of data (e.g. the number 3), a variable named `left`, and a variable named `right`. The `left` and `right` variables point at `nil`, or other nodes. Since these other nodes in turn have other nodes beneath them, we say that the left and right variables are pointing at subtrees. All data in the left subtree is less than or equal to the current node's data, and all data in the right subtree is greater than the current node's data.\n\nFor example, if we had a node containing the data 4, and we added the data 2, our tree would look like this:\n\n      4\n     /\n    2\n\nIf we then added 6, it would look like this:\n\n      4\n     / \\\n    2   6\n\nIf we then added 3, it would look like this\n\n       4\n     /   \\\n    2     6\n     \\\n      3\n\nAnd if we then added 1, 5, and 7, it would look like this\n\n          4\n        /   \\\n       /     \\\n      2       6\n     / \\     / \\\n    1   3   5   7\n\n\n## Source\n\nJosh Cheek [view source](https://twitter.com/josh_cheek)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/crypto-square",
        "track_id": "ruby",
        "slug": "crypto-square",
        "files": {
          "crypto_square_test.rb": "require 'minitest/autorun'\nrequire_relative 'crypto'\n\nclass CryptoTest < MiniTest::Unit::TestCase\n  def test_normalize_strange_characters\n    crypto = Crypto.new('s#$%^&plunk')\n    assert_equal \"splunk\", crypto.normalize_plaintext\n  end\n\n  def test_normalize_with_numbers\n    skip\n    crypto = Crypto.new('1, 2, 3 GO!')\n    assert_equal \"123go\", crypto.normalize_plaintext\n  end\n\n  def test_size_of_small_square\n    skip\n    crypto = Crypto.new('1234')\n    assert_equal 2, crypto.size\n  end\n\n  def test_size_of_slightly_larger_square\n    skip\n    crypto = Crypto.new('123456789')\n    assert_equal 3, crypto.size\n  end\n\n  def test_size_of_non_perfect_square\n    skip\n    crypto = Crypto.new('123456789abc')\n    assert_equal 4, crypto.size\n  end\n\n  def test_plaintext_segments\n    skip\n    crypto = Crypto.new('Never vex thine heart with idle woes')\n    assert_equal [\"neverv\", \"exthin\", \"eheart\", \"withid\", \"lewoes\"], crypto.plaintext_segments\n  end\n\n  def test_other_plaintext_segments\n    skip\n    crypto = Crypto.new('ZOMG! ZOMBIES!!!')\n    assert_equal [\"zomg\", \"zomb\", \"ies\"], crypto.plaintext_segments\n  end\n\n  def test_ciphertext\n    skip\n    crypto = Crypto.new('Time is an illusion. Lunchtime doubly so.')\n    assert_equal \"tasneyinicdsmiohooelntuillibsuuml\", crypto.ciphertext\n  end\n\n  def test_another_ciphertext\n    skip\n    crypto = Crypto.new('We all know interspecies romance is weird.')\n    assert_equal \"wneiaweoreneawssciliprerlneoidktcms\", crypto.ciphertext\n  end\n\n  def test_normalized_ciphertext\n    skip\n    crypto = Crypto.new('Madness, and then illumination.')\n    assert_equal 'msemo aanin dninn dlaet ltshu i', crypto.normalize_ciphertext\n  end\n\n  def test_more_normalized_ciphertext\n    skip\n    crypto = Crypto.new('Vampires are people too!')\n    assert_equal 'vrela epems etpao oirpo', crypto.normalize_ciphertext\n  end\nend\n",
          "README.md": "# Crypto Square\n\nImplement the classic method for composing secret messages called a square code.\n\nThe input is first normalized: The spaces and punctuation are removed from the\nEnglish text and the message is downcased.\n\nThen, the normalized characters are broken into rows.\nThese rows can be regarded as forming a rectangle\nwhen printed with intervening newlines.\n\nFor example, the sentence\n\n> If man was meant to stay on the ground god would have given us roots\n\nis 54 characters long.\n\nBroken into 8-character columns, it yields 7 rows.\n\nThose 7 rows produce this rectangle when printed one per line:\n\n```plain\nifmanwas\nmeanttos\ntayonthe\ngroundgo\ndwouldha\nvegivenu\nsroots\n```\n\nThe coded message is obtained by reading down the columns going left to right.\n\nFor example, the message above is coded as:\n\n```plain\nimtgd vsfea rwerm ayoog\noanou uiont nnlvt wttdd\nesaoh ghnss eoau\n```\n\nWrite a program that, given an English text, outputs the encoded version of\nthat text.\n\nThe size of the square (number of columns) should be decided by the length of the message.\n\nIf the message is a length that creates a perfect square (e.g. 4, 9, 16, 25,\n36, etc), use that number of columns.\n\nIf the message doesn't fit neatly into a square, choose the number of columns\nthat corresponds to the smallest square that is larger than the number of\ncharacters in the message.\n\nFor example, a message 4 characters long should use a 2 x 2 square. A message\nthat is 81 characters long would use a square that is 9 colums wide.\n\nA message between 5 and 8 characters long should use a rectangle 3 characters wide.\n\nOutput the encoded text in groups of five letters.\n\nFor example:\n\n- \"Have a nice day. Feed the dog & chill out!\"\n  - Normalizes to: \"haveanicedayfeedthedogchillout\"\n  - Which has length: 30\n  - And splits into 5 6-character rows:\n    - \"havean\"\n    - \"iceday\"\n    - \"feedth\"\n    - \"edogch\"\n    - \"illout\"\n  - Which yields a ciphertext beginning: \"hifei acedl v…\"\n\n\n## Source\n\nJ Dalbey's Programming Practice problems [view source](http://users.csc.calpoly.edu/~jdalbey/103/Projects/ProgrammingPractice.html)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/clock",
        "track_id": "ruby",
        "slug": "clock",
        "files": {
          "clock_test.rb": "require 'minitest/autorun'\nrequire_relative 'clock'\n\nclass ClockTest < MiniTest::Unit::TestCase\n  def test_on_the_hour\n    assert_equal \"08:00\", Clock.at(8).to_s\n    assert_equal \"09:00\", Clock.at(9).to_s\n  end\n\n  def test_past_the_hour\n    skip\n    assert_equal \"11:09\", Clock.at(11, 9).to_s\n  end\n\n  def test_add_a_few_minutes\n    skip\n    clock = Clock.at(10) + 3\n    assert_equal \"10:03\", clock.to_s\n  end\n\n  def test_add_over_an_hour\n    skip\n    clock = Clock.at(10) + 61\n    assert_equal \"11:01\", clock.to_s\n  end\n\n  def test_wrap_around_at_midnight\n    skip\n    clock = Clock.at(23, 30) + 60\n    assert_equal \"00:30\", clock.to_s\n  end\n\n  def test_subtract_minutes\n    skip\n    clock = Clock.at(10) - 90\n    assert_equal \"08:30\", clock.to_s\n  end\n\n  def test_equivalent_clocks\n    skip\n    clock1 = Clock.at(15, 37)\n    clock2 = Clock.at(15, 37)\n    assert_equal clock1, clock2\n  end\n\n  def test_inequivalent_clocks\n    skip\n    clock1 = Clock.at(15, 37)\n    clock2 = Clock.at(15, 36)\n    clock3 = Clock.at(14, 37)\n    refute_equal clock1, clock2\n    refute_equal clock1, clock3\n  end\n\n  def test_wrap_around_backwards\n    skip\n    clock = Clock.at(0, 30) - 60\n    assert_equal \"23:30\", clock.to_s\n  end\nend\n",
          "README.md": "# Clock\n\nImplement a clock that handles times without dates.\n\nCreate a clock that is independent of date.\n\nYou should be able to add and subtract minutes to it.\n\nTwo clocks that represent the same time should be equal to each other.\n\n\n## Source\n\nPairing session with Erin Drummond [view source](https://twitter.com/ebdrummond)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/scrabble-score",
        "track_id": "ruby",
        "slug": "scrabble-score",
        "files": {
          "scrabble_score_test.rb": "require 'minitest/autorun'\nrequire_relative 'scrabble'\n\nclass ScrabbleTest < MiniTest::Unit::TestCase\n  def test_empty_word_scores_zero\n    assert_equal 0, Scrabble.new(\"\").score\n  end\n\n  def test_whitespace_scores_zero\n    skip\n    assert_equal 0, Scrabble.new(\" \\t\\n\").score\n  end\n\n  def test_nil_scores_zero\n    skip\n    assert_equal 0, Scrabble.new(nil).score\n  end\n\n  def test_scores_very_short_word\n    skip\n    assert_equal 1, Scrabble.new('a').score\n  end\n\n  def test_scores_other_very_short_word\n    skip\n    assert_equal 4, Scrabble.new('f').score\n  end\n\n  def test_simple_word_scores_the_number_of_letters\n    skip\n    assert_equal 6, Scrabble.new(\"street\").score\n  end\n\n  def test_complicated_word_scores_more\n    skip\n    assert_equal 22, Scrabble.new(\"quirky\").score\n  end\n\n  def test_scores_are_case_insensitive\n    skip\n    assert_equal 20, Scrabble.new(\"MULTIBILLIONAIRE\").score\n  end\n\n  def test_convenient_scoring\n    skip\n    assert_equal 13, Scrabble.score(\"alacrity\")\n  end\nend\n",
          "README.md": "# Scrabble Score\n\nWrite a program that, given a word, computes the scrabble score for that word.\n\n## Letter Values\n\nYou'll need these:\n\n```plain\nLetter                           Value\nA, E, I, O, U, L, N, R, S, T       1\nD, G                               2\nB, C, M, P                         3\nF, H, V, W, Y                      4\nK                                  5\nJ, X                               8\nQ, Z                               10\n```\n\n## Examples\n\"cabbage\" should be scored as worth 14 points:\n\n- 3 points for C\n- 1 point for A, twice\n- 3 points for B, twice\n- 2 points for G\n- 1 point for E\n\nAnd to total:\n\n- `3 + 2*1 + 2*3 + 2 + 1`\n- = `3 + 2 + 6 + 3`\n- = `5 + 9`\n- = 14\n\n## Extensions\n* You can play a `:double` or a `:triple` letter.\n* You can play a `:double` or a `:triple` word.\n\n\n## Source\n\nInspired by the Extreme Startup game [view source](https://github.com/rchatley/extreme_startup)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/nucleotide-count",
        "track_id": "ruby",
        "slug": "nucleotide-count",
        "files": {
          "nucleotide_count_test.rb": "require 'minitest/autorun'\nrequire_relative 'dna'\n\nclass DNATest < MiniTest::Unit::TestCase\n  def test_empty_dna_string_has_no_adenosine\n    assert_equal 0, DNA.new('').count('A')\n  end\n\n  def test_empty_dna_string_has_no_nucleotides\n    skip\n    expected = {'A' => 0, 'T' => 0, 'C' => 0, 'G' => 0}\n    assert_equal expected, DNA.new('').nucleotide_counts\n  end\n\n  def test_repetitive_cytidine_gets_counted\n    skip\n    assert_equal 5, DNA.new('CCCCC').count('C')\n  end\n\n  def test_repetitive_sequence_has_only_guanosine\n    skip\n    expected = {'A' => 0, 'T' => 0, 'C' => 0, 'G' => 8}\n    assert_equal expected, DNA.new('GGGGGGGG').nucleotide_counts\n  end\n\n  def test_counts_only_thymidine\n    skip\n    assert_equal 1, DNA.new('GGGGGTAACCCGG').count('T')\n  end\n\n  def test_counts_a_nucleotide_only_once\n    skip\n    dna = DNA.new('CGATTGGG')\n    dna.count('T')\n    assert_equal 2, dna.count('T')\n  end\n\n  def test_validates_nucleotides\n    skip\n    assert_raises ArgumentError do\n      DNA.new('GACT').count('X')\n    end\n  end\n\n  def test_validates_dna\n    skip\n    assert_raises ArgumentError do\n      DNA.new('JOHNNYAPPLESEED')\n    end\n  end\n\n  def test_counts_all_nucleotides\n    skip\n    s = 'AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC'\n    dna = DNA.new(s)\n    expected = {'A' => 20, 'T' => 21, 'G' => 17, 'C' => 12}\n    assert_equal expected, dna.nucleotide_counts\n  end\nend\n",
          "README.md": "# Nucleotide Count\n\nWrite a class `DNA` that takes a DNA string and tells us how many times each nucleotide occurs in the string.\n\nDNA is represented by an alphabet of the following symbols: 'A', 'C', 'G', and 'T'.\n\nEach symbol represents a nucleotide, which is a fancy name for the particular molecules that happen to make up a large part of DNA.\n\nShortest intro to biochemistry EVAR:\n\n* twigs are to birds nests as\n* nucleotides are to DNA and RNA as\n* amino acids are to proteins as\n* sugar is to starch as\n* oh crap lipids\n\nI'm not going to talk about lipids because they're crazy complex.\n\nSo back to nucleotides.\n\nThere are 5 types of nucleotides. 4 of these occur in DNA: `A`, `C`, `G`, and `T`. 4 occur in RNA: `A`, `C`, `G`, `U`.\n\nThere are no other nucleotides.\n\n\n\n## Source\n\nThe Calculating DNA Nucleotides_problem at Rosalind [view source](http://rosalind.info/problems/dna/)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/hexadecimal",
        "track_id": "ruby",
        "slug": "hexadecimal",
        "files": {
          "hexadecimal_test.rb": "require 'minitest/autorun'\nrequire_relative 'hexadecimal'\n\nclass HexadecimalTest < MiniTest::Unit::TestCase\n  def test_hex_1_is_decimal_1\n    assert_equal 1, Hexadecimal.new(\"1\").to_decimal\n  end\n\n  def test_hex_c_is_decimal_12\n    skip\n    assert_equal 12, Hexadecimal.new(\"c\").to_decimal\n  end\n\n  def test_hex_10_is_decimal_16\n    skip\n    assert_equal 16, Hexadecimal.new(\"10\").to_decimal\n  end\n\n  def test_hex_af_is_decimal_175\n    skip\n    assert_equal 175, Hexadecimal.new(\"af\").to_decimal\n  end\n\n  def test_hex_100_is_decimal_256\n    skip\n    assert_equal 256, Hexadecimal.new(\"100\").to_decimal\n  end\n\n  def test_hex_19ace_is_decimal_105166\n    skip\n    assert_equal 105166, Hexadecimal.new(\"19ace\").to_decimal\n  end\n\n  def test_invalid_hex_is_decimal_0\n    skip\n    assert_equal 0, Hexadecimal.new(\"carrot\").to_decimal\n  end\n\n  def test_black\n    skip\n    assert_equal 0, Hexadecimal.new(\"000000\").to_decimal\n  end\n\n  def test_white\n    skip\n    assert_equal 16777215, Hexadecimal.new(\"ffffff\").to_decimal\n  end\n\n  def test_yellow\n    skip\n    assert_equal 16776960, Hexadecimal.new(\"ffff00\").to_decimal\n  end\nend\n",
          "README.md": "# Hexadecimal\n\nWrite a program that will convert a hexadecimal number, represented as a string (e.g. \"10af8c\"), to its decimal equivalent using first principles (i.e. no, you may not use built-in ruby libraries or gems to accomplish the conversion).\n\nOn the web we use hexadecimal to represent colors, e.g. green: 008000, teal: 008080, navy: 000080).\n\nThe program should handle invalid hexadecimal strings.\n\n\n## Source\n\nAll of Computer Science [view source](http://www.wolframalpha.com/examples/NumberBases.html)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/say",
        "track_id": "ruby",
        "slug": "say",
        "files": {
          "say_test.rb": "require 'minitest/autorun'\nrequire_relative 'say'\n\nclass SayTest < MiniTest::Unit::TestCase\n  def test_0\n    assert_equal 'zero', Say.new(0).in_english\n  end\n\n  def test_one\n    skip\n    assert_equal 'one', Say.new(1).in_english\n  end\n\n  def test_14\n    skip\n    assert_equal 'fourteen', Say.new(14).in_english\n  end\n\n  def test_twenty\n    skip\n    # This really shouldn't be twenty-zero\n    assert_equal 'twenty', Say.new(20).in_english\n  end\n\n  def test_twenty_two\n    skip\n    assert_equal 'twenty-two', Say.new(22).in_english\n  end\n\n  def test_100\n    skip\n    assert_equal 'one hundred', Say.new(100).in_english\n  end\n\n  def test_120\n    skip\n    assert_equal 'one hundred twenty', Say.new(120).in_english\n  end\n\n  def test_123\n    skip\n    assert_equal 'one hundred twenty-three', Say.new(123).in_english\n  end\n\n  def test_1_thousand\n    skip\n    assert_equal 'one thousand', Say.new(1000).in_english\n  end\n\n  def test_1_thousand_234\n    skip\n    assert_equal 'one thousand two hundred thirty-four', Say.new(1234).in_english\n  end\n\n  def test_1_million\n    skip\n    assert_equal 'one million', Say.new(10**6).in_english\n  end\n\n  def test_1_million_and_some_crumbs\n    skip\n    assert_equal 'one million two', Say.new(1000002).in_english\n  end\n\n  def test_1_million_2_thousand_345\n    skip\n    expected = 'one million two thousand three hundred forty-five'\n    assert_equal expected, Say.new(1002345).in_english\n  end\n\n  def test_1_billion\n    skip\n    assert_equal 'one billion', Say.new(10**9).in_english\n  end\n\n  def test_really_big_number\n    skip\n    expected = 'nine hundred eighty-seven billion '\n    expected << 'six hundred fifty-four million '\n    expected << 'three hundred twenty-one thousand '\n    expected << 'one hundred twenty-three'\n    assert_equal expected, Say.new(987654321123).in_english\n  end\n\n  def test_lower_bound\n    skip\n    assert_raises ArgumentError do\n      Say.new(-1).in_english\n    end\n  end\n\n  def test_upper_bound\n    skip\n    assert_raises ArgumentError do\n      Say.new(1000000000000).in_english\n    end\n  end\nend\n",
          "README.md": "# Say\n\nWrite a program that will take a number from 0 to 999,999,999,999 and spell out that number in English.\n\n## Step 1\n\nHandle the basic case of 0 through 99.\n\nIf the input to the program is `22`, then the output should be `'twenty-two'`.\n\nYour program should complain loudly if given a number outside the blessed range.\n\nSome good test cases for this program are:\n\n* 0\n* 14\n* 50\n* 98\n* -1\n* 100\n\n### Extension\n\nIf you're on a Mac, shell out to Mac OS X's `say` program to talk out loud.\n\n## Step 2\n\nImplement breaking a number up into chunks of thousands.\n\nSo `1234567890` should yield a list like 1, 234, 567, and 890,\nwhile the far simpler `1000` should yield just 1 and 0.\n\nThe program must also report any values that are out of range.\n\n## Step 3\n\nNow handle inserting the appropriate scale word between those chunks.\n\nSo `1234567890` should yield `'1 billion 234 million 567 thousand 890'`\n\nThe program must also report any values that are out of range.\nIt's fine to stop at \"trillion\".\n\n## Step 4\n\nPut it all together to get nothing but plain English.\n\n`12345` should give `twelve thousand three hundred forty-five`.\n\nThe program must also report any values that are out of range.\n\n### Extensions\n\nUse _and_ (correctly) when spelling out the number in English:\n\n* 14 becomes \"fourteen\".\n* 100 becomes \"one hundred\".\n* 120 becomes \"one hundred and twenty\".\n* 1002 becomes \"one thousand and two\".\n* 1323 becomes \"one thousand three hundred and twenty-three\".\n\n\n## Source\n\nA variation on JavaRanch CattleDrive, exercise 4a [view source](http://www.javaranch.com/say.jsp)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/meetup",
        "track_id": "ruby",
        "slug": "meetup",
        "files": {
          "meetup_test.rb": "require 'minitest/autorun'\nrequire 'date'\nrequire_relative 'meetup'\n\n# Define a class Meetup with a constructor taking a montth and a year\n# and a method day(weekday, schedule)\n# where weekday is one of :monday, :tuesday, etc\n# and schedule is :first, :second, :third, :fourth, :last or :teenth.\n\nclass MeetupTest < MiniTest::Unit::TestCase\n\n  def test_monteenth_of_may_2013\n    assert_equal Date.new(2013, 5, 13), Meetup.new(5, 2013).day(:monday, :teenth)\n  end\n\n  def test_monteenth_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 19), Meetup.new(8, 2013).day(:monday, :teenth)\n  end\n\n  def test_monteenth_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 16), Meetup.new(9, 2013).day(:monday, :teenth)\n  end\n\n  def test_tuesteenth_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 19), Meetup.new(3, 2013).day(:tuesday, :teenth)\n  end\n\n  def test_tuesteenth_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 16), Meetup.new(4, 2013).day(:tuesday, :teenth)\n  end\n\n  def test_tuesteenth_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 13), Meetup.new(8, 2013).day(:tuesday, :teenth)\n  end\n\n  def test_wednesteenth_of_january_2013\n    skip\n    assert_equal Date.new(2013, 1, 16), Meetup.new(1, 2013).day(:wednesday, :teenth)\n  end\n\n  def test_wednesteenth_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 13), Meetup.new(2, 2013).day(:wednesday, :teenth)\n  end\n\n  def test_wednesteenth_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 19), Meetup.new(6, 2013).day(:wednesday, :teenth)\n  end\n\n  def test_thursteenth_of_may_2013\n    skip\n    assert_equal Date.new(2013, 5, 16), Meetup.new(5, 2013).day(:thursday, :teenth)\n  end\n\n  def test_thursteenth_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 13), Meetup.new(6, 2013).day(:thursday, :teenth)\n  end\n\n  def test_thursteenth_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 19), Meetup.new(9, 2013).day(:thursday, :teenth)\n  end\n\n  def test_friteenth_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 19), Meetup.new(4, 2013).day(:friday, :teenth)\n  end\n\n  def test_friteenth_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 16), Meetup.new(8, 2013).day(:friday, :teenth)\n  end\n\n  def test_friteenth_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 13), Meetup.new(9, 2013).day(:friday, :teenth)\n  end\n\n  def test_saturteenth_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 16), Meetup.new(2, 2013).day(:saturday, :teenth)\n  end\n\n  def test_saturteenth_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 13), Meetup.new(4, 2013).day(:saturday, :teenth)\n  end\n\n  def test_saturteenth_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 19), Meetup.new(10, 2013).day(:saturday, :teenth)\n  end\n\n  def test_sunteenth_of_map_2013\n    skip\n    assert_equal Date.new(2013, 5, 19), Meetup.new(5, 2013).day(:sunday, :teenth)\n  end\n\n  def test_sunteenth_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 16), Meetup.new(6, 2013).day(:sunday, :teenth)\n  end\n\n  def test_sunteenth_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 13), Meetup.new(10, 2013).day(:sunday, :teenth)\n  end\n\n  def test_first_monday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 4), Meetup.new(3, 2013).day(:monday, :first)\n  end\n\n  def test_first_monday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 1), Meetup.new(4, 2013).day(:monday, :first)\n  end\n\n  def test_first_tuesday_of_may_2013\n    skip\n    assert_equal Date.new(2013, 5, 7), Meetup.new(5, 2013).day(:tuesday, :first)\n  end\n\n  def test_first_tuesday_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 4), Meetup.new(6, 2013).day(:tuesday, :first)\n  end\n\n  def test_first_wednesday_of_july_2013\n    skip\n    assert_equal Date.new(2013, 7, 3), Meetup.new(7, 2013).day(:wednesday, :first)\n  end\n\n  def test_first_wednesday_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 7), Meetup.new(8, 2013).day(:wednesday, :first)\n  end\n\n  def test_first_thursday_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 5), Meetup.new(9, 2013).day(:thursday, :first)\n  end\n\n  def test_first_thursday_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 3), Meetup.new(10, 2013).day(:thursday, :first)\n  end\n\n  def test_first_friday_of_november_2013\n    skip\n    assert_equal Date.new(2013, 11, 1), Meetup.new(11, 2013).day(:friday, :first)\n  end\n\n  def test_first_friday_of_december_2013\n    skip\n    assert_equal Date.new(2013, 12, 6), Meetup.new(12, 2013).day(:friday, :first)\n  end\n\n  def test_first_saturday_of_january_2013\n    skip\n    assert_equal Date.new(2013, 1, 5), Meetup.new(1, 2013).day(:saturday, :first)\n  end\n\n  def test_first_saturday_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 2), Meetup.new(2, 2013).day(:saturday, :first)\n  end\n\n  def test_first_sunday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 3), Meetup.new(3, 2013).day(:sunday, :first)\n  end\n\n  def test_first_sunday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 7), Meetup.new(4, 2013).day(:sunday, :first)\n  end\n\n  def test_second_monday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 11), Meetup.new(3, 2013).day(:monday, :second)\n  end\n\n  def test_second_monday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 8), Meetup.new(4, 2013).day(:monday, :second)\n  end\n\n  def test_second_tuesday_of_may_2013\n    skip\n    assert_equal Date.new(2013, 5, 14), Meetup.new(5, 2013).day(:tuesday, :second)\n  end\n\n  def test_second_tuesday_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 11), Meetup.new(6, 2013).day(:tuesday, :second)\n  end\n\n  def test_second_wednesday_of_july_2013\n    skip\n    assert_equal Date.new(2013, 7, 10), Meetup.new(7, 2013).day(:wednesday, :second)\n  end\n\n  def test_second_wednesday_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 14), Meetup.new(8, 2013).day(:wednesday, :second)\n  end\n\n  def test_second_thursday_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 12), Meetup.new(9, 2013).day(:thursday, :second)\n  end\n\n  def test_second_thursday_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 10), Meetup.new(10, 2013).day(:thursday, :second)\n  end\n\n  def test_second_friday_of_november_2013\n    skip\n    assert_equal Date.new(2013, 11, 8), Meetup.new(11, 2013).day(:friday, :second)\n  end\n\n  def test_second_friday_of_december_2013\n    skip\n    assert_equal Date.new(2013, 12, 13), Meetup.new(12, 2013).day(:friday, :second)\n  end\n\n  def test_second_saturday_of_january_2013\n    skip\n    assert_equal Date.new(2013, 1, 12), Meetup.new(1, 2013).day(:saturday, :second)\n  end\n\n  def test_second_saturday_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 9), Meetup.new(2, 2013).day(:saturday, :second)\n  end\n\n  def test_second_sunday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 10), Meetup.new(3, 2013).day(:sunday, :second)\n  end\n\n  def test_second_sunday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 14), Meetup.new(4, 2013).day(:sunday, :second)\n  end\n\n  def test_third_monday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 18), Meetup.new(3, 2013).day(:monday, :third)\n  end\n\n  def test_third_monday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 15), Meetup.new(4, 2013).day(:monday, :third)\n  end\n\n  def test_third_tuesday_of_may_2013\n    skip\n    assert_equal Date.new(2013, 5, 21), Meetup.new(5, 2013).day(:tuesday, :third)\n  end\n\n  def test_third_tuesday_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 18), Meetup.new(6, 2013).day(:tuesday, :third)\n  end\n\n  def test_third_wednesday_of_july_2013\n    skip\n    assert_equal Date.new(2013, 7, 17), Meetup.new(7, 2013).day(:wednesday, :third)\n  end\n\n  def test_third_wednesday_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 21), Meetup.new(8, 2013).day(:wednesday, :third)\n  end\n\n  def test_third_thursday_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 19), Meetup.new(9, 2013).day(:thursday, :third)\n  end\n\n  def test_third_thursday_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 17), Meetup.new(10, 2013).day(:thursday, :third)\n  end\n\n  def test_third_friday_of_november_2013\n    skip\n    assert_equal Date.new(2013, 11, 15), Meetup.new(11, 2013).day(:friday, :third)\n  end\n\n  def test_third_friday_of_december_2013\n    skip\n    assert_equal Date.new(2013, 12, 20), Meetup.new(12, 2013).day(:friday, :third)\n  end\n\n  def test_third_saturday_of_january_2013\n    skip\n    assert_equal Date.new(2013, 1, 19), Meetup.new(1, 2013).day(:saturday, :third)\n  end\n\n  def test_third_saturday_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 16), Meetup.new(2, 2013).day(:saturday, :third)\n  end\n\n  def test_third_sunday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 17), Meetup.new(3, 2013).day(:sunday, :third)\n  end\n\n  def test_third_sunday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 21), Meetup.new(4, 2013).day(:sunday, :third)\n  end\n\n  def test_fourth_monday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 25), Meetup.new(3, 2013).day(:monday, :fourth)\n  end\n\n  def test_fourth_monday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 22), Meetup.new(4, 2013).day(:monday, :fourth)\n  end\n\n  def test_fourth_tuesday_of_may_2013\n    skip\n    assert_equal Date.new(2013, 5, 28), Meetup.new(5, 2013).day(:tuesday, :fourth)\n  end\n\n  def test_fourth_tuesday_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 25), Meetup.new(6, 2013).day(:tuesday, :fourth)\n  end\n\n  def test_fourth_wednesday_of_july_2013\n    skip\n    assert_equal Date.new(2013, 7, 24), Meetup.new(7, 2013).day(:wednesday, :fourth)\n  end\n\n  def test_fourth_wednesday_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 28), Meetup.new(8, 2013).day(:wednesday, :fourth)\n  end\n\n  def test_fourth_thursday_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 26), Meetup.new(9, 2013).day(:thursday, :fourth)\n  end\n\n  def test_fourth_thursday_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 24), Meetup.new(10, 2013).day(:thursday, :fourth)\n  end\n\n  def test_fourth_friday_of_november_2013\n    skip\n    assert_equal Date.new(2013, 11, 22), Meetup.new(11, 2013).day(:friday, :fourth)\n  end\n\n  def test_fourth_friday_of_december_2013\n    skip\n    assert_equal Date.new(2013, 12, 27), Meetup.new(12, 2013).day(:friday, :fourth)\n  end\n\n  def test_fourth_saturday_of_january_2013\n    skip\n    assert_equal Date.new(2013, 1, 26), Meetup.new(1, 2013).day(:saturday, :fourth)\n  end\n\n  def test_fourth_saturday_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 23), Meetup.new(2, 2013).day(:saturday, :fourth)\n  end\n\n  def test_fourth_sunday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 24), Meetup.new(3, 2013).day(:sunday, :fourth)\n  end\n\n  def test_fourth_sunday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 28), Meetup.new(4, 2013).day(:sunday, :fourth)\n  end\n\n  def test_last_monday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 25), Meetup.new(3, 2013).day(:monday, :last)\n  end\n\n  def test_last_monday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 29), Meetup.new(4, 2013).day(:monday, :last)\n  end\n\n  def test_last_tuesday_of_may_2013\n    skip\n    assert_equal Date.new(2013, 5, 28), Meetup.new(5, 2013).day(:tuesday, :last)\n  end\n\n  def test_last_tuesday_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 25), Meetup.new(6, 2013).day(:tuesday, :last)\n  end\n\n  def test_last_wednesday_of_july_2013\n    skip\n    assert_equal Date.new(2013, 7, 31), Meetup.new(7, 2013).day(:wednesday, :last)\n  end\n\n  def test_last_wednesday_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 28), Meetup.new(8, 2013).day(:wednesday, :last)\n  end\n\n  def test_last_thursday_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 26), Meetup.new(9, 2013).day(:thursday, :last)\n  end\n\n  def test_last_thursday_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 31), Meetup.new(10, 2013).day(:thursday, :last)\n  end\n\n  def test_last_friday_of_november_2013\n    skip\n    assert_equal Date.new(2013, 11, 29), Meetup.new(11, 2013).day(:friday, :last)\n  end\n\n  def test_last_friday_of_december_2013\n    skip\n    assert_equal Date.new(2013, 12, 27), Meetup.new(12, 2013).day(:friday, :last)\n  end\n\n  def test_last_saturday_of_january_2013\n    skip\n    assert_equal Date.new(2013, 1, 26), Meetup.new(1, 2013).day(:saturday, :last)\n  end\n\n  def test_last_saturday_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 23), Meetup.new(2, 2013).day(:saturday, :last)\n  end\n\n  def test_last_sunday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 31), Meetup.new(3, 2013).day(:sunday, :last)\n  end\n\n  def test_last_sunday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 28), Meetup.new(4, 2013).day(:sunday, :last)\n  end\n\nend\n",
          "README.md": "# Meetup\n\nCalculate the date of meetups.\n\nTypically meetups happen on the same day of the week.\n\nExamples are\n\n* the first Monday\n* the third Tuesday\n* the Wednesteenth\n* the last Thursday\n\nThere are exactly 7 days that end in '-teenth', therefore one is\nguaranteed that each day of the week will have a '-teenth' in every\nmonth.\n\n\n## Source\n\nJeremy Hinegardner mentioned a Boulder meetup that happens on the Wednesteenth of every month [view source](https://twitter.com/copiousfreetime)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/queen-attack",
        "track_id": "ruby",
        "slug": "queen-attack",
        "files": {
          "queen_attack_test.rb": "require 'minitest/autorun'\nrequire_relative 'queens'\n\nclass QueensTest < MiniTest::Unit::TestCase\n\n  def test_default_positions\n    queens = Queens.new\n    assert_equal [0, 3], queens.white\n    assert_equal [7, 3], queens.black\n  end\n\n  def test_specific_placement\n    skip\n    queens = Queens.new(white: [3, 7], black: [6, 1])\n    assert_equal [3, 7], queens.white\n    assert_equal [6, 1], queens.black\n  end\n\n  def test_multiple_boards_simultaneously\n    skip\n    queens1 = Queens.new(white: [3, 7], black: [6, 1])\n    queens2 = Queens.new(white: [5, 4], black: [7, 7])\n    assert_equal [3, 7], queens1.white\n    assert_equal [6, 1], queens1.black\n    assert_equal [5, 4], queens2.white\n    assert_equal [7, 7], queens2.black\n  end\n\n  def test_cannot_occupy_same_space\n    skip\n    assert_raises ArgumentError do\n      Queens.new(white: [2, 4], black: [2, 4])\n    end\n  end\n\n  def test_string_representation\n    skip\n    queens = Queens.new(white: [2, 4], black: [6, 6])\n    board = <<-BOARD.chomp\nO O O O O O O O\nO O O O O O O O\nO O O O W O O O\nO O O O O O O O\nO O O O O O O O\nO O O O O O O O\nO O O O O O B O\nO O O O O O O O\n    BOARD\n    assert_equal board, queens.to_s\n  end\n\n  def test_another_string_representation\n    skip\n    queens = Queens.new(white: [7, 1], black: [0, 0])\n    board = <<-BOARD.chomp\nB O O O O O O O\nO O O O O O O O\nO O O O O O O O\nO O O O O O O O\nO O O O O O O O\nO O O O O O O O\nO O O O O O O O\nO W O O O O O O\n    BOARD\n    assert_equal board, queens.to_s\n  end\n\n  def test_yet_another_string_representation\n    skip\n    queens = Queens.new(white: [4, 3], black: [3, 4])\n    board = <<-BOARD.chomp\nO O O O O O O O\nO O O O O O O O\nO O O O O O O O\nO O O O B O O O\nO O O W O O O O\nO O O O O O O O\nO O O O O O O O\nO O O O O O O O\n    BOARD\n    assert_equal board, queens.to_s\n  end\n\n  def test_cannot_attack\n    skip\n    queens = Queens.new(white: [2, 3], black: [4, 7])\n    assert !queens.attack?\n  end\n\n  def test_can_attack_on_same_row\n    skip\n    queens = Queens.new(white: [2, 4], black: [2, 7])\n    assert queens.attack?\n  end\n\n  def test_can_attack_on_same_column\n    skip\n    queens = Queens.new(white: [5, 4], black: [2, 4])\n    assert queens.attack?\n  end\n\n  def test_can_attack_on_diagonal\n    skip\n    queens = Queens.new(white: [1, 1], black: [6, 6])\n    assert queens.attack?\n  end\n\n  def test_can_attack_on_other_diagonal\n    skip\n    queens = Queens.new(white: [0, 6], black: [1, 7])\n    assert queens.attack?\n  end\n\n  def test_can_attack_on_yet_another_diagonal\n    skip\n    queens = Queens.new(white: [4, 1], black: [6, 3])\n    assert queens.attack?\n  end\n\n  def test_can_attack_on_a_diagonal_slanted_the_other_way\n    skip\n    queens = Queens.new(white: [6, 1], black: [1, 6])\n    assert queens.attack?\n  end\nend\n\n",
          "README.md": "# Queen Attack\n\nWrite a program that positions two queens on a chess board and indicates whether or not they are positioned so that they can attack each other.\n\nIn the game of chess, a queen can attack pieces which are on the same row,\ncolumn, or diagonal.\n\nA chessboard can be represented by an 8 by 8 array.\n\nSo if you're told the white queen is at (2, 3) and the black queen at (5, 6),\nthen you'd know you've got a set-up like so:\n\n```plain\nO O O O O O O O\nO O O O O O O O\nO O O W O O O O\nO O O O O O O O\nO O O O O O O O\nO O O O O O B O\nO O O O O O O O\nO O O O O O O O\n```\n\nYou'd also be able to answer whether the queens can attack each other.\nIn this case, that answer would be yes, they can,\nbecause both pieces share a diagonal.\n\n\n## Source\n\nJ Dalbey's Programming Practice problems [view source](http://users.csc.calpoly.edu/~jdalbey/103/Projects/ProgrammingPractice.html)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/palindrome-products",
        "track_id": "ruby",
        "slug": "palindrome-products",
        "files": {
          "palindrome_products_test.rb": "require 'minitest/autorun'\nrequire_relative 'palindromes'\n\nclass PalindromesTest < MiniTest::Unit::TestCase\n\n  def test_largest_palindrome_from_single_digit_factors\n    palindromes = Palindromes.new(max_factor: 9)\n    palindromes.generate\n    largest = palindromes.largest\n    assert_equal 9, largest.value\n    assert [[[3, 3], [1, 9]], [[1, 9], [3, 3]]].include? largest.factors\n  end\n\n  def test_largest_palindrome_from_double_digit_factors\n    skip\n    palindromes = Palindromes.new(max_factor: 99, min_factor: 10)\n    palindromes.generate\n    largest = palindromes.largest\n    assert_equal 9009, largest.value\n    assert_equal [[91, 99]], largest.factors\n  end\n\n  def test_smallest_palindrome_from_double_digit_factors\n    skip\n    palindromes = Palindromes.new(max_factor: 99, min_factor: 10)\n    palindromes.generate\n    smallest = palindromes.smallest\n    assert_equal 121, smallest.value\n    assert_equal [[11, 11]], smallest.factors\n  end\n\n  def test_largest_palindrome_from_triple_digit_factors\n    skip\n    palindromes = Palindromes.new(max_factor: 999, min_factor: 100)\n    palindromes.generate\n    largest = palindromes.largest\n    assert_equal 906609, largest.value\n    assert_equal [[913, 993]], largest.factors\n  end\n\n  def test_smallest_palindrome_from_triple_digit_factors\n    skip\n    palindromes = Palindromes.new(max_factor: 999, min_factor: 100)\n    palindromes.generate\n    smallest = palindromes.smallest\n    assert_equal 10201, smallest.value\n    assert_equal [[101, 101]], smallest.factors\n  end\n\nend\n",
          "README.md": "# Palindrome Products\n\nWrite a program that can detect palindrome products in a given range.\n\nA palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99.\n\n\n## Source\n\nProblem 4 at Project Euler [view source](http://projecteuler.net/problem=4)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/matrix",
        "track_id": "ruby",
        "slug": "matrix",
        "files": {
          "matrix_test.rb": "require 'minitest/autorun'\nrequire_relative 'matrix'\n\nclass MatrixTest < MiniTest::Unit::TestCase\n\n  def test_extract_a_row\n    matrix = Matrix.new(\"1 2\\n10 20\")\n    assert_equal [1, 2], matrix.rows[0]\n  end\n\n  def test_extract_same_row_again\n    skip\n    matrix = Matrix.new(\"9 7\\n8 6\")\n    assert_equal [9, 7], matrix.rows[0]\n  end\n\n  def test_extract_other_row\n    skip\n    matrix = Matrix.new(\"9 8 7\\n19 18 17\")\n    assert_equal [19, 18, 17], matrix.rows[1]\n  end\n\n  def test_extract_other_row_again\n    skip\n    matrix = Matrix.new(\"1 4 9\\n16 25 36\")\n    assert_equal [16, 25, 36], matrix.rows[1]\n  end\n\n  def test_extract_a_column\n    skip\n    matrix = Matrix.new(\"1 2 3\\n4 5 6\\n7 8 9\\n 8 7 6\")\n    assert_equal [1, 4, 7, 8], matrix.columns[0]\n  end\n\n  def test_extract_another_column\n    skip\n    matrix = Matrix.new(\"89 1903 3\\n18 3 1\\n9 4 800\")\n    assert_equal [1903, 3, 4], matrix.columns[1]\n  end\n\nend\n",
          "README.md": "# Matrix\n\nWrite a program that, given a string representing a matrix of numbers, can return the rows and columns of that matrix.\n\nSo given a string with embedded newlines like:\n\n> 9 8 7\n> 5 3 2\n> 6 6 7\n\nrepresenting this matrix:\n\n```plain\n    0  1  2\n  |---------\n0 | 9  8  7\n1 | 5  3  2\n2 | 6  6  7\n```\n\nyour code should be able to spit out:\n\n- A list of the rows,\n  reading each row left-to-right while moving top-to-bottom across the rows,\n- A list of the columns,\n  reading each column top-to-bottom while moving from left-to-right.\n\nThe rows for our example matrix:\n\n- 9, 8, 7\n- 5, 3, 2\n- 6, 6, 7\n\nAnd its columns:\n\n- 9, 5, 6\n- 8, 3, 6\n- 7, 2, 7\n\n\n## Source\n\nWarmup to the `saddle-points` warmup. [view source](http://jumpstartlab.com)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/saddle-points",
        "track_id": "ruby",
        "slug": "saddle-points",
        "files": {
          "saddle_points_test.rb": "require 'minitest/autorun'\nrequire_relative 'matrix'\n\nclass MatrixTest < MiniTest::Unit::TestCase\n\n  def test_extract_a_row\n    matrix = Matrix.new(\"1 2\\n10 20\")\n    assert_equal [1, 2], matrix.rows[0]\n  end\n\n  def test_extract_same_row_again\n    skip\n    matrix = Matrix.new(\"9 7\\n8 6\")\n    assert_equal [9, 7], matrix.rows[0]\n  end\n\n  def test_extract_other_row\n    skip\n    matrix = Matrix.new(\"9 8 7\\n19 18 17\")\n    assert_equal [19, 18, 17], matrix.rows[1]\n  end\n\n  def test_extract_other_row_again\n    skip\n    matrix = Matrix.new(\"1 4 9\\n16 25 36\")\n    assert_equal [16, 25, 36], matrix.rows[1]\n  end\n\n  def test_extract_a_column\n    skip\n    matrix = Matrix.new(\"1 2 3\\n4 5 6\\n7 8 9\\n 8 7 6\")\n    assert_equal [1, 4, 7, 8], matrix.columns[0]\n  end\n\n  def test_extract_another_column\n    skip\n    matrix = Matrix.new(\"89 1903 3\\n18 3 1\\n9 4 800\")\n    assert_equal [1903, 3, 4], matrix.columns[1]\n  end\n\n  def test_no_saddle_point\n    skip\n    matrix = Matrix.new(\"2 1\\n1 2\")\n    assert_equal [], matrix.saddle_points\n  end\n\n  def test_a_saddle_point\n    skip\n    matrix = Matrix.new(\"1 2\\n3 4\")\n    assert_equal [[0, 1]], matrix.saddle_points\n  end\n\n  def test_another_saddle_point\n    skip\n    matrix = Matrix.new(\"18 3 39 19 91\\n38 10 8 77 320\\n3 4 8 6 7\")\n    assert_equal [[2, 2]], matrix.saddle_points\n  end\n\n  def test_multiple_saddle_points\n    skip\n    matrix = Matrix.new(\"4 5 4\\n3 5 5\\n1 5 4\")\n    assert_equal [[0, 1], [1, 1], [2, 1]], matrix.saddle_points\n  end\n\nend\n",
          "README.md": "# Saddle Points\n\nWrite a program that detects saddle points in a matrix.\n\nSo say you have a matrix like so:\n\n```plain\n    0  1  2\n  |---------\n0 | 9  8  7\n1 | 5  3  2     <--- saddle point at (1,0)\n2 | 6  6  7\n```\n\nIt has a saddle point at (1, 0).\n\nIt's called a \"saddle point\" because it is greater than or equal to every\nelement in its row and the less than or equal to every element in its column.\n\nA matrix may have zero or more saddle points.\n\nYour code should be able to provide the (possibly empty) list of all the\nsaddle points for any given matrix.\n\nNote that you may find other definitions of matrix saddle points online, but\nthe tests for this exercise follow the above unambiguous definition.\n\n\n## Source\n\nJ Dalbey's Programming Practice problems [view source](http://users.csc.calpoly.edu/~jdalbey/103/Projects/ProgrammingPractice.html)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/triangle",
        "track_id": "ruby",
        "slug": "triangle",
        "files": {
          "triangle_test.rb": "require 'minitest/autorun'\nrequire_relative 'triangle'\n\nclass TriangleTest < MiniTest::Unit::TestCase\n  def test_equilateral_triangles_have_equal_sides\n    assert_equal :equilateral, Triangle.new(2, 2, 2).kind\n  end\n\n  def test_larger_equilateral_triangles_also_have_equal_sides\n    skip\n    assert_equal :equilateral, Triangle.new(10, 10, 10).kind\n  end\n\n  def test_isosceles_triangles_have_last_two_sides_equal\n    skip\n    assert_equal :isosceles, Triangle.new(3, 4, 4).kind\n  end\n\n  def test_isosceles_triangles_have_first_and_last_sides_equal\n    skip\n    assert_equal :isosceles, Triangle.new(4, 3, 4).kind\n  end\n\n  def test_isosceles_triangles_have_two_first_sides_equal\n    skip\n    assert_equal :isosceles, Triangle.new(4, 4, 3).kind\n  end\n\n  def test_isosceles_triangles_have_in_fact_exactly_two_sides_equal\n    skip\n    assert_equal :isosceles, Triangle.new(10, 10, 2).kind\n  end\n\n  def test_scalene_triangles_have_no_equal_sides\n    skip\n    assert_equal :scalene, Triangle.new(3, 4, 5).kind\n  end\n\n  def test_scalene_triangles_have_no_equal_sides_at_a_larger_scale_too\n    skip\n    assert_equal :scalene, Triangle.new(10, 11, 12).kind\n  end\n\n  def test_scalene_triangles_have_no_equal_sides_in_descending_order_either\n    skip\n    assert_equal :scalene, Triangle.new(5, 4, 2).kind\n  end\n\n  def test_very_small_triangles_are_legal\n    skip\n    assert_equal :scalene, Triangle.new(0.4, 0.6, 0.3).kind\n  end\n\n  def test_triangles_with_no_size_are_illegal\n    skip\n    assert_raises(TriangleError) do\n      Triangle.new(0, 0, 0).kind\n    end\n  end\n\n  def test_triangles_with_negative_sides_are_illegal\n    skip\n    assert_raises(TriangleError) do\n      Triangle.new(3, 4, -5).kind\n    end\n  end\n\n  def test_triangles_violating_triangle_inequality_are_illegal\n    skip\n    assert_raises(TriangleError) do\n      Triangle.new(1, 1, 3).kind\n    end\n  end\n\n  def test_triangles_violating_triangle_inequality_are_illegal_2\n    skip\n    assert_raises(TriangleError) do\n      Triangle.new(2, 4, 2).kind\n    end\n  end\n\n  def test_triangles_violating_triangle_inequality_are_illegal_3\n    skip\n    assert_raises(TriangleError) do\n      Triangle.new(7, 3, 2).kind\n    end\n  end\n\nend\n",
          "README.md": "# Triangle\n\nWrite a program that can tell you if a triangle is equilateral, isosceles, or scalene.\n\nThe program should raise an error if the triangle cannot exist.\n\nTests are provided, delete one `skip` at a time.\n\n## Hint\n\nThe sum of the lengths of any two sides of a triangle always exceeds the length of the third side, a principle known as the _triangle inequality_.\n\n\n## Source\n\nThe Ruby Koans triangle project, parts 1 & 2 [view source](http://rubykoans.com)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/atbash-cipher",
        "track_id": "ruby",
        "slug": "atbash-cipher",
        "files": {
          "atbash_cipher_test.rb": "require 'minitest/autorun'\nrequire_relative 'atbash'\n\nclass AtbashTest < MiniTest::Unit::TestCase\n\n  def test_encode_no\n    assert_equal 'ml', Atbash.encode('no')\n  end\n\n  def test_encode_yes\n    skip\n    assert_equal 'bvh', Atbash.encode('yes')\n  end\n\n  def test_encode_OMG\n    skip\n    assert_equal 'lnt', Atbash.encode('OMG')\n  end\n\n  def test_encode_O_M_G\n    skip\n    assert_equal 'lnt', Atbash.encode('O M G')\n  end\n\n  def test_encode_long_word\n    skip\n    assert_equal 'nrmwy oldrm tob', Atbash.encode('mindblowingly')\n  end\n\n  def test_encode_numbers\n    skip\n    assert_equal 'gvhgr mt123 gvhgr mt', Atbash.encode('Testing, 1 2 3, testing.')\n  end\n\n  def test_encode_sentence\n    skip\n    assert_equal 'gifgs rhurx grlm', Atbash.encode('Truth is fiction.')\n  end\n\n  def test_encode_all_the_things\n    skip\n    plaintext = 'The quick brown fox jumps over the lazy dog.'\n    cipher = 'gsvjf rxpyi ldmul cqfnk hlevi gsvoz abwlt'\n    assert_equal cipher, Atbash.encode(plaintext)\n  end\n\nend\n",
          "README.md": "# Atbash Cipher\n\nCreate an implementation of the atbash cipher, an ancient encryption system created in the Middle East.\n\nThe Atbash cipher is a simple substitution cipher that relies on transposing all the letters in the alphabet such that the resulting alphabet is backwards. The first letter is replaced with the last letter, the second with the\nsecond-last, and so on.\n\nAn Atbash cipher for the Latin alphabet would be as follows:\n\n```plain\nPlain:  abcdefghijklmnopqrstuvwxyz\nCipher: zyxwvutsrqponmlkjihgfedcba\n```\n\nIt is a very weak cipher because it only has one possible key, and it is a\nsimple monoalphabetic substitution cipher. However, this may not have been an issue in the cipher's time.\n\n## Examples\n- Encoding \"test\" gives \"gvhg\"\n- Decoding \"gvhg\" gives \"test\"\n\n\n## Source\n\nWikipedia [view source](http://en.wikipedia.org/wiki/Atbash)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/house",
        "track_id": "ruby",
        "slug": "house",
        "files": {
          "house_test.rb": "require 'minitest/autorun'\nrequire_relative 'house'\n\nclass HouseTest < MiniTest::Unit::TestCase\n  def test_rhyme\n    expected = <<-RHYME\nThis is the house that Jack built.\n\nThis is the malt\nthat lay in the house that Jack built.\n\nThis is the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the rooster that crowed in the morn\nthat woke the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the farmer sowing his corn\nthat kept the rooster that crowed in the morn\nthat woke the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the horse and the hound and the horn\nthat belonged to the farmer sowing his corn\nthat kept the rooster that crowed in the morn\nthat woke the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n    RHYME\n    assert_equal expected, House.recite\n  end\nend\n",
          "README.md": "# House\n\nWrite a program that outputs the nursery rhyme 'This is the House that Jack Built'.\n\n> [The] process of placing a phrase of clause within another phrase of clause is called embedding. It is through the processes of recursion and embedding that we are able to take a finite number of forms (words and phrases) and construct an infinite number of expressions. Furthermore, embedding also allows us to construct an infinitely long structure, in theory anyway.\n\n- [papyr.com](http://papyr.com/hypertextbooks/grammar/ph_noun.htm)\n\n\nThe nursery rhyme reads as follows:\n\n```plain\nThis is the house that Jack built.\n\nThis is the malt\nthat lay in the house that Jack built.\n\nThis is the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the rooster that crowed in the morn\nthat woke the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the farmer sowing his corn\nthat kept the rooster that crowed in the morn\nthat woke the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the horse and the hound and the horn\nthat belonged to the farmer sowing his corn\nthat kept the rooster that crowed in the morn\nthat woke the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n```\n\n\n\n## Source\n\nBritish nursery rhyme [view source](http://en.wikipedia.org/wiki/This_Is_The_House_That_Jack_Built)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/secret-handshake",
        "track_id": "ruby",
        "slug": "secret-handshake",
        "files": {
          "secret_handshake_test.rb": "require 'minitest/autorun'\nrequire_relative 'secret_handshake'\n\nclass SecretHandshakeTest < MiniTest::Unit::TestCase\n  def test_handshake_1_to_wink\n    handshake = SecretHandshake.new(1)\n    assert_equal [\"wink\"], handshake.commands\n  end\n\n  def test_handshake_10_to_double_blink\n    skip\n    handshake = SecretHandshake.new(2)\n    assert_equal [\"double blink\"], handshake.commands\n  end\n\n  def test_handshake_100_to_close_your_eyes\n    skip\n    handshake = SecretHandshake.new(4)\n    assert_equal [\"close your eyes\"], handshake.commands\n  end\n\n  def test_handshake_1000_to_jump\n    skip\n    handshake = SecretHandshake.new(8)\n    assert_equal [\"jump\"], handshake.commands\n  end\n\n  def test_handshake_11_to_wink_and_double_blink\n    skip\n    handshake = SecretHandshake.new(3)\n    assert_equal [\"wink\",\"double blink\"], handshake.commands\n  end\n\n  def test_handshake_10011_to_double_blink_and_wink\n    skip\n    handshake = SecretHandshake.new(19)\n    assert_equal [\"double blink\",\"wink\"], handshake.commands\n  end\n\n  def test_handshake_11111_to_double_blink_and_wink\n    skip\n    handshake = SecretHandshake.new(31)\n    assert_equal [\"jump\",\"close your eyes\",\"double blink\",\"wink\"], handshake.commands\n  end\n\n  def test_invalid_handshake\n    skip\n    handshake = SecretHandshake.new(\"piggies\")\n    assert_equal [], handshake.commands\n  end\nend\n",
          "README.md": "# Secret Handshake\n\nWrite a program that will take a decimal number, and convert it to the appropriate sequence of events for a secret handshake.\n\n> There are 10 types of people in the world: Those who understand binary, and those who don't.\n\nYou and your fellow cohort of those in the \"know\" when it comes to binary decide to come up with a secret \"handshake\".\n\n```\n1 = wink\n10 = double blink\n100 = close your eyes\n1000 = jump\n\n\n10000 = Reverse the order of the operations in the secret handshake.\n```\n\n```\nhandshake = SecretHandshake.new 9\nhandshake.commands # => [\"wink\",\"jump\"]\n\nhandshake = SecretHandshake.new \"11001\"\nhandshake.commands # => [\"jump\",\"wink\"]\n```\n\nThe program should consider strings specifying an invalid binary as the value 0.\n\n\n## Source\n\nBert, in Mary Poppins [view source](http://www.imdb.com/character/ch0011238/quotes)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/proverb",
        "track_id": "ruby",
        "slug": "proverb",
        "files": {
          "proverb_test.rb": "require 'minitest/autorun'\nrequire_relative 'proverb'\n\nclass ProverbTest < MiniTest::Unit::TestCase\n  def test_a_single_consequence\n    proverb = Proverb.new('nail', 'shoe')\n    expected = \"For want of a nail the shoe was lost.\\n\" +\n      \"And all for the want of a nail.\"\n    assert_equal expected, proverb.to_s\n  end\n\n  def test_a_short_chain_of_consequences\n    skip\n    proverb = Proverb.new('nail', 'shoe', 'horse')\n    expected = \"For want of a nail the shoe was lost.\\n\" +\n      \"For want of a shoe the horse was lost.\\n\" +\n      \"And all for the want of a nail.\"\n    assert_equal expected, proverb.to_s\n  end\n\n  def test_a_longer_chain_of_consequences\n    skip\n    proverb = Proverb.new('nail', 'shoe', 'horse', 'rider')\n    expected = \"For want of a nail the shoe was lost.\\n\" +\n      \"For want of a shoe the horse was lost.\\n\" +\n      \"For want of a horse the rider was lost.\\n\" +\n      \"And all for the want of a nail.\"\n    assert_equal expected, proverb.to_s\n  end\n\n  def test_proverb_does_not_hard_code_the_rhyme_dictionary\n    skip\n    proverb = Proverb.new('key', 'value')\n    expected = \"For want of a key the value was lost.\\n\" +\n      \"And all for the want of a key.\"\n    assert_equal expected, proverb.to_s\n  end\n\n  def test_the_whole_proverb\n    skip\n    chain = [\n      'nail', 'shoe', 'horse', 'rider', 'message', 'battle', 'kingdom'\n    ]\n    proverb = Proverb.new(*chain)\n    expected = \"For want of a nail the shoe was lost.\\n\" +\n      \"For want of a shoe the horse was lost.\\n\" +\n      \"For want of a horse the rider was lost.\\n\" +\n      \"For want of a rider the message was lost.\\n\" +\n      \"For want of a message the battle was lost.\\n\" +\n      \"For want of a battle the kingdom was lost.\\n\" +\n      \"And all for the want of a nail.\"\n    assert_equal expected, proverb.to_s\n  end\n\n  def test_an_optional_qualifier_in_the_final_consequence\n    skip\n    chain = [\n      'nail', 'shoe', 'horse', 'rider', 'message', 'battle', 'kingdom'\n    ]\n    proverb = Proverb.new(*chain, qualifier: 'horseshoe')\n    expected = \"For want of a nail the shoe was lost.\\n\" +\n      \"For want of a shoe the horse was lost.\\n\" +\n      \"For want of a horse the rider was lost.\\n\" +\n      \"For want of a rider the message was lost.\\n\" +\n      \"For want of a message the battle was lost.\\n\" +\n      \"For want of a battle the kingdom was lost.\\n\" +\n      \"And all for the want of a horseshoe nail.\"\n    assert_equal expected, proverb.to_s\n  end\n\n  def test_proverb_is_same_each_time\n    skip\n    proverb = Proverb.new('nail', 'shoe')\n    assert_equal proverb.to_s, proverb.to_s\n  end\nend\n",
          "README.md": "# Proverb\n\nFor want of a horseshoe nail, a kingdom was lost, or so the saying goes. Write a program that outputs the full text of this proverbial rhyme.\n\nFor want of a nail the shoe was lost.\nFor want of a shoe the horse was lost.\nFor want of a horse the rider was lost.\nFor want of a rider the message was lost.\nFor want of a message the battle was lost.\nFor want of a battle the kingdom was lost.\nAnd all for the want of a horseshoe nail.\n\n\n## Source\n\nWikipedia [view source](http://en.wikipedia.org/wiki/For_Want_of_a_Nail)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/ocr-numbers",
        "track_id": "ruby",
        "slug": "ocr-numbers",
        "files": {
          "ocr_numbers_test.rb": "require 'minitest/autorun'\nrequire_relative 'ocr'\n\nclass OCRTest < MiniTest::Unit::TestCase\n\n  def test_recognize_zero\n    text = <<-NUMBER.chomp\n _ \n| |\n|_|\n   \n    NUMBER\n    assert_equal \"0\", OCR.new(text).convert\n  end\n\n  def test_recognize_one\n    skip\n    text = <<-NUMBER.chomp\n   \n  |\n  |\n   \n    NUMBER\n    assert_equal \"1\", OCR.new(text).convert\n  end\n\n  def test_recognize_two\n    skip\n    text = <<-NUMBER.chomp\n _ \n _|\n|_ \n   \n    NUMBER\n    assert_equal \"2\", OCR.new(text).convert\n  end\n\n  def test_recognize_three\n    skip\n    text = <<-NUMBER.chomp\n _ \n _|\n _|\n   \n    NUMBER\n    assert_equal \"3\", OCR.new(text).convert\n  end\n\n  def test_recognize_four\n    skip\n    text = <<-NUMBER.chomp\n   \n|_|\n  |\n   \n    NUMBER\n    assert_equal \"4\", OCR.new(text).convert\n  end\n\n  def test_recognize_five\n    skip\n    text = <<-NUMBER.chomp\n _ \n|_ \n _|\n   \n    NUMBER\n    assert_equal \"5\", OCR.new(text).convert\n  end\n\n  def test_recognize_six\n    skip\n    text = <<-NUMBER.chomp\n _ \n|_ \n|_|\n   \n    NUMBER\n    assert_equal \"6\", OCR.new(text).convert\n  end\n\n  def test_recognize_seven\n    skip\n    text = <<-NUMBER.chomp\n _ \n  |\n  |\n   \n    NUMBER\n    assert_equal \"7\", OCR.new(text).convert\n  end\n\n  def test_recognize_eight\n    skip\n    text = <<-NUMBER.chomp\n _ \n|_|\n|_|\n   \n    NUMBER\n    assert_equal \"8\", OCR.new(text).convert\n  end\n\n  def test_recognize_nine\n    skip\n    text = <<-NUMBER.chomp\n _ \n|_|\n _|\n   \n    NUMBER\n    assert_equal \"9\", OCR.new(text).convert\n  end\n\n  def test_identify_garble\n    skip\n    text = <<-NUMBER.chomp\n   \n| |\n| |\n   \n    NUMBER\n    assert_equal \"?\", OCR.new(text).convert\n  end\n\n  def test_identify_10\n    skip\n    text = <<-NUMBER.chomp\n    _ \n  || |\n  ||_|\n      \n    NUMBER\n    assert_equal \"10\", OCR.new(text).convert\n  end\n\n  def test_identify_110101100\n    skip\n    text = <<-NUMBER.chomp\n       _     _        _  _ \n  |  || |  || |  |  || || |\n  |  ||_|  ||_|  |  ||_||_|\n                           \n    NUMBER\n    assert_equal \"110101100\", OCR.new(text).convert\n  end\n\n  def test_identify_with_garble\n    skip\n    text = <<-NUMBER.chomp\n       _     _           _ \n  |  || |  || |     || || |\n  |  | _|  ||_|  |  ||_||_|\n                           \n    NUMBER\n    assert_equal \"11?10?1?0\", OCR.new(text).convert\n\n  end\n\n  def test_identify_1234567890\n    skip\n    text = <<-NUMBER.chomp\n    _  _     _  _  _  _  _  _ \n  | _| _||_||_ |_   ||_||_|| |\n  ||_  _|  | _||_|  ||_| _||_|\n                              \n    NUMBER\n    assert_equal \"1234567890\", OCR.new(text).convert\n  end\n\n  def test_identify_123_456_789\n    skip\n    text = <<-NUMBER.chomp\n    _  _ \n  | _| _|\n  ||_  _|\n         \n    _  _ \n|_||_ |_ \n  | _||_|\n         \n _  _  _ \n  ||_||_|\n  ||_| _|\n         \nNUMBER\n    assert_equal \"123,456,789\", OCR.new(text).convert\n  end\n\nend\n",
          "README.md": "# Ocr Numbers\n\nWrite a program that, given a 3 x 4 grid of pipes, underscores, and spaces, can determine which number is represented, or whether it is garbled.\n\n## Step 1\n\nA simple binary font has been constructed using only pipes and underscores.\n\nThe number is four rows high, three columns wide:\n\n     _   #\n    | |  # zero.\n    |_|  #\n         # the fourth row is always blank\n\n         #\n      |  # one.\n      |  #\n         # (blank fourth row)\n\nWrite a program that, given a 3 x 4 grid of pipes, underscores, and spaces,\ncan determine whether the the grid represents a zero, a one, or garble.\n\nAnything else is considered garble, and can be represented with a '?'\n\n## Step 2\n\nA simple numeric font has been constructed using only pipes and underscores.\n\nThe number consists of four rows high, three columns wide:\n\n      _  _     _  _  _  _  _  _  #\n    | _| _||_||_ |_   ||_||_|| | # decimal numbers.\n    ||_  _|  | _||_|  ||_| _||_| #\n                                 # fourth line is always blank\n\nThere may be several numbers in the input text, one per line.\n\n\n## Source\n\nInspired by the Bank OCR kata [view source](http://codingdojo.org/cgi-bin/wiki.pl?KataBankOCR)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/pig-latin",
        "track_id": "ruby",
        "slug": "pig-latin",
        "files": {
          "pig_latin_test.rb": "require 'minitest/autorun'\nrequire_relative 'pig_latin'\n\nclass PigLatinTest < MiniTest::Unit::TestCase\n\n  def test_word_beginning_with_a\n    assert_equal \"appleay\", PigLatin.translate(\"apple\")\n  end\n\n  def test_other_word_beginning_e\n    skip\n    assert_equal \"earay\", PigLatin.translate(\"ear\")\n  end\n\n  def test_word_beginning_with_p\n    skip\n    assert_equal \"igpay\", PigLatin.translate(\"pig\")\n  end\n\n  def test_word_beginning_with_k\n    skip\n    assert_equal \"oalakay\", PigLatin.translate(\"koala\")\n  end\n\n  def test_word_beginning_with_ch\n    skip\n    assert_equal \"airchay\", PigLatin.translate(\"chair\")\n  end\n\n  def test_word_beginning_with_qu\n    skip\n    assert_equal \"eenquay\", PigLatin.translate(\"queen\")\n  end\n\n  def test_word_with_consonant_preceding_qu\n    skip\n    assert_equal \"aresquay\", PigLatin.translate(\"square\")\n  end\n\n  def test_word_beginning_with_th\n    skip\n    assert_equal \"erapythay\", PigLatin.translate(\"therapy\")\n  end\n\n  def test_word_beginning_with_thr\n    skip\n    assert_equal \"ushthray\", PigLatin.translate(\"thrush\")\n  end\n\n  def test_word_beginning_with_sch\n    skip\n    assert_equal \"oolschay\", PigLatin.translate(\"school\")\n  end\n\n  def test_translates_phrase\n    skip\n    assert_equal \"ickquay astfay unray\", PigLatin.translate(\"quick fast run\")\n  end\n\n  def test_word_beginning_with_ye\n    skip\n    assert_equal \"ellowyay\", PigLatin.translate(\"yellow\")\n  end\n\n  def test_word_beginning_with_yt\n    skip\n    assert_equal \"yttriaay\", PigLatin.translate(\"yttria\")\n  end\n\n  def test_word_beginning_with_xe\n    skip\n    assert_equal \"enonxay\", PigLatin.translate(\"xenon\")\n  end\n\n  def test_word_beginning_with_xr\n    skip\n    assert_equal \"xrayay\", PigLatin.translate(\"xray\")\n  end\nend\n",
          "README.md": "# Pig Latin\n\nImplement a program that translates from English to Pig Latin\n\nPig Latin is a made-up children's language that's intended to be confusing. It obeys a few simple rules (below) but when it's spoken quickly it's really difficult for non-children (and non-native speakers) to understand.\n\n* **Rule 1**: If a word begins with a vowel sound, add an \"ay\" sound to the end of the word.\n* **Rule 2**: If a word begins with a consonant sound, move it to the end of the word, and then add an \"ay\" sound to the end of the word.\n\nThere are a few more rules for edge cases, and there are regional variants too.\n\nSee <http://en.wikipedia.org/wiki/Pig_latin> for more details.\n\n\n## Source\n\nThe Pig Latin exercise at Test First Teaching by Ultrasaurus [view source](https://github.com/ultrasaurus/test-first-teaching/blob/master/learn_ruby/pig_latin/)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/simple-linked-list",
        "track_id": "ruby",
        "slug": "simple-linked-list",
        "files": {
          "simple_linked_list_test.rb": "require 'minitest/autorun'\n\nrequire_relative 'linked_list'\n\nclass LinkedListTest < MiniTest::Unit::TestCase\n  def setup\n    @one = Element.new(1, nil)\n    @two = Element.new(2, @one)\n  end\n\n  def test_constructor\n    assert_equal 1, @one.datum\n    assert_nil @one.next\n\n    assert_equal 2, @two.datum\n    assert_same @one, @two.next\n  end\n\n  def test_to_a\n    skip\n    assert_equal [], Element.to_a(nil)\n    assert_equal [1], Element.to_a(@one)\n    assert_equal [2, 1], Element.to_a(@two)\n  end\n\n  def test_reverse\n    skip\n    # one_r and @one need not be the same object\n    one_r = @one.reverse\n    assert_equal 1, one_r.datum\n    assert_nil one_r.next\n\n    two_r = @two.reverse\n    assert_equal 1, two_r.datum\n    assert_equal 2, two_r.next.datum\n\n    # ensure that nothing changed about the given objects\n    test_constructor\n  end\n\n  def test_from_a\n    skip\n    assert_nil Element.from_a([])\n\n    one_a = Element.from_a([1])\n    assert_equal 1, one_a.datum\n    assert_nil one_a.next\n\n    two_a = Element.from_a([2, 1])\n    assert_equal 2, two_a.datum\n    assert_equal 1, two_a.next.datum\n    assert_nil two_a.next.next\n\n    one_to_ten = Element.from_a(1..10)\n    assert_equal 10, one_to_ten.next.next.next.next.next.next.next.next.next.datum\n  end\n\n  def test_roundtrip\n    skip\n    assert_equal [1], Element.from_a([1]).to_a\n    assert_equal [2, 1], Element.from_a([2, 1]).to_a\n    assert_equal (1..10).to_a, Element.from_a(1..10).to_a\n  end\nend\n",
          "README.md": "# Simple Linked List\n\nWrite a simple linked list implementation that uses Elements and a loop\n\nThe linked list is a fundamental data structure in computer science, often used in the implementation of other data structures. They're pervasive in functional programming languages, such as Clojure, Erlang, or Haskell, but far less common in imperative languages such as Ruby or Python.\n\nThe simplest kind of linked list is an immutable linked list, which is the kind that's built-in to these functional programming languages. Immutable (or more specifically: persistent) data structures can be copied in constant time (since a reference is equivalent to a copy), and can save loads of time and memory for certain use cases because structure can be shared between versions of the data structure.\n\nThis variant of linked lists is often used to represent sequences or push-down stacks (also called a LIFO stack; Last In, First Out).\n\nAs a first take, lets create a persistent linked list with just Element objects containing the range (1..10), and provide functions to reverse a linked list and convert to and from arrays.\n\nWhen implementing this in a language with built-in linked lists, implement your own abstract data type.\n\nExamples (Ruby):\n\n    Element.to_a(nil) #=> []\n    Element.from_a([]) #=> nil\n    Element.reverse(nil) #=> nil\n    one = Element.new(1, nil)\n    one #=> <Element @datum=1, @next=nil>\n    one.datum #=> 1\n    one.next #=> nil\n    two = Element.new(2, one)\n    two #=> <Element @datum=2, @next=<Element @datum=1 @next=nil>>\n    Element.to_a(two) #=> [2, 1]\n    Element.reverse(two) #=> <Element @datum=1 @next=<Element @datum=2 @next=nil>>\n    range = Element.from_a(1..10)\n    range.datum #=> 1\n    range.next.next.next.next.next.next.next.next.next.next.datum #=> 10\n\n\n## Source\n\nInspired by 'Data Structures and Algorithms with Object-Oriented Design Patterns in Ruby', singly linked-lists. [view source](http://www.brpreiss.com/books/opus8/html/page96.html#SECTION004300000000000000000)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/luhn",
        "track_id": "ruby",
        "slug": "luhn",
        "files": {
          "luhn_test.rb": "require 'minitest/autorun'\nrequire_relative 'luhn'\n\nclass LuhnTest < MiniTest::Unit::TestCase\n\n  def test_addends\n    luhn = Luhn.new(12121)\n    assert_equal [1, 4, 1, 4, 1], luhn.addends\n  end\n\n  def test_too_large_addend\n    skip\n    luhn = Luhn.new(8631)\n    assert_equal [7, 6, 6, 1], luhn.addends\n  end\n\n  def test_checksum\n    skip\n    luhn = Luhn.new(4913)\n    assert_equal 22, luhn.checksum\n  end\n\n  def test_checksum_again\n    skip\n    luhn = Luhn.new(201773)\n    assert_equal 21, luhn.checksum\n  end\n\n  def test_invalid_number\n    skip\n    luhn = Luhn.new(738)\n    assert !luhn.valid?\n  end\n\n  def test_valid_number\n    skip\n    luhn = Luhn.new(8739567)\n    assert luhn.valid?\n  end\n\n  def test_create_valid_number\n    skip\n    number = Luhn.create(123)\n    assert_equal 1230, number\n  end\n\n  def test_create_other_valid_number\n    skip\n    number = Luhn.create(873956)\n    assert_equal 8739567, number\n  end\n\n  def test_create_yet_another_valid_number\n    skip\n    number = Luhn.create(837263756)\n    assert_equal 8372637564, number\n  end\n\nend\n",
          "README.md": "# Luhn\n\nWrite a program that can take a number and determine whether or not it is valid per the Luhn formula.\n\nThe Luhn formula is a simple checksum formula used to validate a variety of identification numbers, such as credit card numbers and Canadian Social Insurance Numbers.\n\nThe formula verifies a number against its included check digit, which is usually appended to a partial number to generate the full number. This number must pass the following test:\n\n- Counting from rightmost digit (which is the check digit) and moving left, double the value of every second digit.\n- For any digits that thus become 10 or more, subtract 9 from the result.\n  - 1111 becomes 2121.\n  - 8763 becomes 7733 (from 2×6=12 → 12-9=3 and 2×8=16 → 16-9=7).\n- Add all these digits together.\n  - 1111 becomes 2121 sums as 2+1+2+1 to give a check digit of 6.\n  - 8763 becomes 7733, and 7+7+3+3 is 20.\n\nIf the total ends in 0 (put another way, if the total modulus 10 is congruent to 0), then the number is valid according to the Luhn formula; else it is not valid. So, 1111 is not valid (as shown above, it comes out to 6), while 8763 is valid (as shown above, it comes out to 20).\n\nWrite a program that, given a number\n\n- Can check if it is valid per the Luhn formula.\n  - This should treat, for example, \"2323 2005 7766 3554\" as valid.\n- Can add a check digit to make the number valid per the Luhn formula.\n  - This should give \"2323 2005 7766 3554\" in response to \"2323 2005 7766 355\".\n\n\n## Source\n\nThe Luhn Algorithm on Wikipedia [view source](http://en.wikipedia.org/wiki/Luhn_algorithm)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/simple-cipher",
        "track_id": "ruby",
        "slug": "simple-cipher",
        "files": {
          "simple_cipher_test.rb": "require 'minitest/autorun'\nrequire_relative 'cipher'\n\nclass RandomKeyCipherTest < MiniTest::Unit::TestCase\n  def setup\n    @cipher = Cipher.new\n  end\n\n  def test_cipher_key_is_letters\n    assert_match(/[a-z]+/, @cipher.key)\n  end\n\n  # Here we take advantage of the fact that plaintext of \"aaa...\" doesn't outputs\n  # the key. This is a critical problem with shift ciphers, some characters\n  # will always output the key verbatim.\n  def test_cipher_encode\n    skip\n    plaintext = \"aaaaaaaaaa\"\n    assert_equal(@cipher.key[0,10], @cipher.encode(plaintext))\n  end\n\n  def test_cipher_decode\n    skip\n    plaintext = \"aaaaaaaaaa\"\n    assert_equal(plaintext, @cipher.decode(@cipher.key[0,10]))\n  end\n\n  def test_cipher_reversible\n    skip\n    plaintext = \"abcdefghij\"\n    assert_equal(plaintext, @cipher.decode(@cipher.encode(plaintext)))\n  end\nend\n\nclass IncorrectKeyCipherTest < MiniTest::Unit::TestCase\n  def test_cipher_with_caps_key\n    skip\n    assert_raises ArgumentError do\n      Cipher.new(\"ABCDEF\")\n    end\n  end\n\n  def test_cipher_with_numeric_key\n    skip\n    assert_raises ArgumentError do\n      Cipher.new(\"12345\")\n    end\n  end\n\n  def test_cipher_with_empty_key\n    skip\n    assert_raises ArgumentError do\n      Cipher.new(\"\")\n    end\n  end\nend\n\nclass SubstitutionCipherTest < MiniTest::Unit::TestCase\n  def setup\n    @key = \"abcdefghij\"\n    @cipher = Cipher.new(@key)\n  end\n\n  def test_cipher_key_is_as_submitted\n    skip\n    assert_equal(@cipher.key, @key)\n  end\n\n  def test_cipher_encode\n    skip\n    plaintext = \"aaaaaaaaaa\"\n    ciphertext = \"abcdefghij\"\n    assert_equal(ciphertext, @cipher.encode(plaintext))\n  end\n\n  def test_cipher_decode\n    skip\n    plaintext = \"aaaaaaaaaa\"\n    ciphertext = \"abcdefghij\"\n    assert_equal(plaintext, @cipher.decode(ciphertext))\n  end\n\n  def test_cipher_reversible\n    skip\n    plaintext = \"abcdefghij\"\n    assert_equal(plaintext, @cipher.decode(@cipher.encode(plaintext)))\n  end\n\n  def test_double_shift_encode\n    skip\n    plaintext = \"iamapandabear\"\n    ciphertext = \"qayaeaagaciai\"\n    assert_equal(ciphertext, Cipher.new(\"iamapandabear\").encode(plaintext))\n  end\n\n  def test_cipher_encode_wrap\n    skip\n    plaintext = \"zzzzzzzzzz\"\n    ciphertext = \"zabcdefghi\"\n    assert_equal(ciphertext, @cipher.encode(plaintext))\n  end\n\nend\n\nclass PseudoShiftCipherTest < MiniTest::Unit::TestCase\n  def setup\n    @cipher = Cipher.new(\"dddddddddd\")\n  end\n\n  def test_cipher_encode\n    skip\n    plaintext = \"aaaaaaaaaa\"\n    ciphertext = \"dddddddddd\"\n    assert_equal(ciphertext, @cipher.encode(plaintext))\n  end\n\n  def test_cipher_decode\n    skip\n    plaintext = \"aaaaaaaaaa\"\n    ciphertext = \"dddddddddd\"\n    assert_equal(plaintext, @cipher.decode(ciphertext))\n  end\n\n  def test_cipher_reversible\n    skip\n    plaintext = \"abcdefghij\"\n    assert_equal(plaintext, @cipher.decode(@cipher.encode(plaintext)))\n  end\nend\n",
          "README.md": "# Simple Cipher\n\nImplement a simple shift cipher like Caesar and a more secure substitution cipher\n\n## Step 1\n\n\"If he had anything confidential to say, he wrote it in cipher, that is, by so changing the order of the letters of the alphabet, that not a word could be made out. If anyone wishes to decipher these, and get at their meaning, he must substitute the fourth letter of the alphabet, namely D, for A, and so with the others.\"\n—Suetonius, Life of Julius Caesar\n\nCiphers are very straight-forward algorithms that allow us to render text less readable while still allowing easy deciphering. They are vulnerable to many forms of cryptoanalysis, but we are lucky that generally our little sisters are not cryptoanalysts.\n\nThe Caeser Cipher was used for some messages from Julius Caesar that were sent afield. Now Caeser knew that the cipher wasn't very good, but he had one ally in that respect: almost nobody could read well. So even being a couple letters off was sufficient so that people couldn't recognize the few words that they did know.\n\nYour task is to create a simple shift cipher like the Caesar Cipher. This image is a great example of the Caesar Cipher: ![Caesar Cipher](http://en.wikipedia.org/wiki/File:Caesar_cipher_left_shift_of_3.svg)\n\nHere are some examples:\n\n    @cipher = Cipher.new\n    @cipher.encode(\"iamapandabear\") #=> \"ldpdsdqgdehdu\"\n    @cipher.decode(\"ldpdsdqgdehdu\") #=> \"iamapandabear\"\n\n## Step 2\n\nShift ciphers are no fun though when your kid sister figures it out. Try amending the code to allow us to specify a key and use that for the shift distance. This is called a substitution cipher.\n\nHere's an example:\n\n    @cipher = Cipher.new(\"aaaaaaaaaaaaaaaaaa\")\n    @cipher.encode(\"iamapandabear\") #=> \"iamapandabear\"\n    @cipher = Cipher.new(\"ddddddddddddddddd\")\n    @cipher.encode(\"imapandabear\") #=> \"lpdsdqgdehdu\"\n\nIn the example above, we've set a = 0 for the key value. So when the plaintext is added to the key, we end up with the same message coming out. So \"aaaa\" is not an ideal key. But if we set the key to \"dddd\", we would get the same thing as the Caesar Cipher.\n\n## Step 3\n\nThe weakest link in any cipher is the human being. Let's make your substitution cipher a little more fault tolerant by providing a source of randomness and ensuring that they key is not composed of numbers or capital letters.\n\nIf someone doesn't submit a key at all, generate a truly random key of at least 100 characters in length, accessible via Cipher#key (the # syntax means instance variable)\n\nIf the key submitted has capital letters or numbers, throw an ArgumentError with a message to that effect.\n\nSome examples:\n    @cipher = Cipher.new\n    @cipher.key #=> \"duxrceqyaimciuucnelkeoxjhdyduucpmrxmaivacmybmsdrzwqxvbxsygzsabdjmdjabeorttiwinfrpmpogvabiofqexnohrqu\"\n\n## Extensions\n\nShift ciphers work by making the text slightly odd, but are vulnerable to frequency analysis. Substitution ciphers help that, but are still very vulnerable when the key is short or if spaces are preserved. Later on you'll see one solution to this problem in the exercise \"crypto-square\".\n\nIf you want to go farther in this field, the questions begin to be about how we can exchange keys in a secure way. Take a look at [Diffie-Hellman on Wikipedia](http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange) for one of the first implementations of this scheme.\n\n## Source\n\nSubstitution Cipher at Wikipedia [view source](http://en.wikipedia.org/wiki/Substitution_cipher)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/wordy",
        "track_id": "ruby",
        "slug": "wordy",
        "files": {
          "wordy_test.rb": "require 'minitest/autorun'\nrequire_relative 'word_problem'\n\nclass WordProblemTest < MiniTest::Unit::TestCase\n  def test_add_1\n    assert_equal 2, WordProblem.new('What is 1 plus 1?').answer\n  end\n\n  def test_add_2\n    skip\n    assert_equal 55, WordProblem.new('What is 53 plus 2?').answer\n  end\n\n  def test_add_negative_numbers\n    skip\n    assert_equal(-11, WordProblem.new('What is -1 plus -10?').answer)\n  end\n\n  def test_add_more_digits\n    skip\n    assert_equal 45801, WordProblem.new('What is 123 plus 45678?').answer\n  end\n\n  def test_subtract\n    skip\n    assert_equal 16, WordProblem.new('What is 4 minus -12?').answer\n  end\n\n  def test_multiply\n    skip\n    assert_equal(-75, WordProblem.new('What is -3 multiplied by 25?').answer)\n  end\n\n  def test_divide\n    skip\n    assert_equal(-11, WordProblem.new('What is 33 divided by -3?').answer)\n  end\n\n  def test_add_twice\n    skip\n    question = 'What is 1 plus 1 plus 1?'\n    assert_equal 3, WordProblem.new(question).answer\n  end\n\n  def test_add_then_subtract\n    skip\n    question = 'What is 1 plus 5 minus -2?'\n    assert_equal 8, WordProblem.new(question).answer\n  end\n\n  def test_subtract_twice\n    skip\n    question = 'What is 20 minus 4 minus 13?'\n    assert_equal 3, WordProblem.new(question).answer\n  end\n\n  def test_subtract_then_add\n    skip\n    question = 'What is 17 minus 6 plus 3?'\n    assert_equal 14, WordProblem.new(question).answer\n  end\n\n  def test_multiply_twice\n    skip\n    question = 'What is 2 multiplied by -2 multiplied by 3?'\n    assert_equal(-12, WordProblem.new(question).answer)\n  end\n\n  def test_add_then_multiply\n    skip\n    question = 'What is -3 plus 7 multiplied by -2?'\n    assert_equal(-8, WordProblem.new(question).answer)\n  end\n\n  def test_divide_twice\n    skip\n    question = 'What is -12 divided by 2 divided by -3?'\n    assert_equal 2, WordProblem.new(question).answer\n  end\n\n  def test_too_advanced\n    skip\n    assert_raises ArgumentError do\n      WordProblem.new('What is 53 cubed?').answer\n    end\n  end\n\n  def test_irrelevant\n    skip\n    assert_raises ArgumentError do\n      WordProblem.new('Who is the president of the United States?').answer\n    end\n  end\n\nend\n",
          "README.md": "# Wordy\n\nWrite a program that takes a word problem and returns the answer as an integer.\n\n## Step 1\n\nE.g.\n\n> What is 5 plus 13?\n\nThe program should handle large numbers and negative numbers.\n\nUse the tests to drive your solution by deleting the `skip` in one test at a time.\n\n## Step 2\n\nE.g.\n\n> What is 5 plus 13?\n\n> What is 7 minus 5?\n\n> What is 6 multiplied by 4?\n\n> What is 25 divided by 5?\n\n## Step 3\n\nE.g.\n\n> What is 5 plus 13 plus 6?\n\n> What is 7 minus 5 minus 1?\n\n> What is 9 minus 3 plus 5?\n\n> What is 3 plus 5 minus 8?\n\n## Step 4\n\nE.g.\n\n> What is 5 plus 13?\n\n> What is 7 minus 5?\n\n> What is 6 times 4?\n\n> What is 25 divided by 5?\n\n> What is 78 plus 5 minus 3?\n\n> What is 18 times 3 plus 16?\n\n> What is 4 times 3 divided by 6?\n\n> What is 4 plus 3 times 2?\n\n## Extensions\n\nImplement questions of the type:\n\n> What is 2 raised to the 5th power?\n\nRemember to write failing tests for this code.\n\n\n## Source\n\nInspired by one of the generated questions in the Extreme Startup game. [view source](https://github.com/rchatley/extreme_startup)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/allergies",
        "track_id": "ruby",
        "slug": "allergies",
        "files": {
          "allergies_test.rb": "require 'minitest/autorun'\nrequire_relative 'allergies'\n\nclass AllergiesTest < MiniTest::Unit::TestCase\n\n  def test_no_allergies_means_not_allergic\n    allergies = Allergies.new(0)\n    refute allergies.allergic_to?('peanuts')\n    refute allergies.allergic_to?('cats')\n    refute allergies.allergic_to?('strawberries')\n  end\n\n  def test_is_allergic_to_eggs\n    skip\n    allergies = Allergies.new(1)\n    assert allergies.allergic_to?('eggs')\n  end\n\n  def test_allergic_to_eggs_in_addition_to_other_stuff\n    skip\n    allergies = Allergies.new(5)\n    assert allergies.allergic_to?('eggs')\n    assert allergies.allergic_to?('shellfish')\n    refute allergies.allergic_to?('strawberries')\n  end\n\n  def test_no_allergies_at_all\n    skip\n    allergies = Allergies.new(0)\n    assert_equal [], allergies.list\n  end\n\n  def test_allergic_to_just_eggs\n    skip\n    allergies = Allergies.new(1)\n    assert_equal ['eggs'], allergies.list\n  end\n\n  def test_allergic_to_just_peanuts\n    skip\n    allergies = Allergies.new(2)\n    assert_equal ['peanuts'], allergies.list\n  end\n\n  def test_allergic_to_eggs_and_peanuts\n    skip\n    allergies = Allergies.new(3)\n    assert_equal ['eggs', 'peanuts'], allergies.list\n  end\n\n  def test_allergic_to_lots_of_stuff\n    skip\n    allergies = Allergies.new(248)\n    assert_equal ['strawberries', 'tomatoes', 'chocolate', 'pollen', 'cats'], allergies.list\n  end\n\n  def test_allergic_to_everything\n    skip\n    allergies = Allergies.new(255)\n    assert_equal ['eggs', 'peanuts', 'shellfish', 'strawberries', 'tomatoes', 'chocolate', 'pollen', 'cats'], allergies.list\n  end\n\n  def test_ignore_non_allergen_score_parts\n    skip\n    allergies = Allergies.new(509)\n    assert_equal ['eggs', 'shellfish', 'strawberries', 'tomatoes', 'chocolate', 'pollen', 'cats'], allergies.list\n  end\n\nend\n",
          "README.md": "# Allergies\n\nWrite a program that, given a person's allergy score, can tell them whether or not they're allergic to a given item, and their full list of allergies.\n\nAn allergy test produces a single numeric score which contains the information about all the allergies the person has (that they were tested for).\n\nThe list of items (and their value) that were tested are:\n\n* eggs (1)\n* peanuts (2)\n* shellfish (4)\n* strawberries (8)\n* tomatoes (16)\n* chocolate (32)\n* pollen (64)\n* cats (128)\n\nSo if Tom is allergic to peanuts and chocolate, he gets a score of 34.\n\nNow, given just that score of 34, your program should be able to say:\n\n- Whether Tom is allergic to any one of those allergens listed above.\n- All the allergens Tom is allergic to.\n\n\n## Source\n\nJumpstart Lab Warm-up [view source](http://jumpstartlab.com)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/kindergarten-garden",
        "track_id": "ruby",
        "slug": "kindergarten-garden",
        "files": {
          "kindergarten_garden_test.rb": "require 'minitest/autorun'\nrequire_relative 'garden'\n\nclass GardenTest < MiniTest::Unit::TestCase\n\n  def test_alices_garden\n    garden = Garden.new(\"RC\\nGG\")\n    assert_equal [:radishes, :clover, :grass, :grass], garden.alice\n  end\n\n  def test_different_garden_for_alice\n    skip\n    garden = Garden.new(\"VC\\nRC\")\n    assert_equal [:violets, :clover, :radishes, :clover], garden.alice\n  end\n\n  def test_bobs_garden\n    skip\n    garden = Garden.new(\"VVCG\\nVVRC\")\n    assert_equal [:clover, :grass, :radishes, :clover], garden.bob\n  end\n\n  def test_bob_and_charlies_gardens\n    skip\n    garden = Garden.new(\"VVCCGG\\nVVCCGG\")\n    assert_equal [:clover, :clover, :clover, :clover], garden.bob\n    assert_equal [:grass, :grass, :grass, :grass], garden.charlie\n  end\n\nend\n\nclass TestFullGarden < MiniTest::Unit::TestCase\n  def setup\n    diagram = \"VRCGVVRVCGGCCGVRGCVCGCGV\\nVRCCCGCRRGVCGCRVVCVGCGCV\"\n    @garden = Garden.new(diagram)\n  end\n\n  def garden\n    @garden\n  end\n\n  def test_alice\n    skip\n    assert_equal [:violets, :radishes, :violets, :radishes], garden.alice\n  end\n\n  def test_bob\n    skip\n    assert_equal [:clover, :grass, :clover, :clover], garden.bob\n  end\n\n  def test_charlie\n    skip\n    assert_equal [:violets, :violets, :clover, :grass], garden.charlie\n  end\n\n  def test_david\n    skip\n    assert_equal [:radishes, :violets, :clover, :radishes], garden.david\n  end\n\n  def test_eve\n    skip\n    assert_equal [:clover, :grass, :radishes, :grass], garden.eve\n  end\n\n  def test_fred\n    skip\n    assert_equal [:grass, :clover, :violets, :clover], garden.fred\n  end\n\n  def test_ginny\n    skip\n    assert_equal [:clover, :grass, :grass, :clover], garden.ginny\n  end\n\n  def test_harriet\n    skip\n    assert_equal [:violets, :radishes, :radishes, :violets], garden.harriet\n  end\n\n  def test_ileana\n    skip\n    assert_equal [:grass, :clover, :violets, :clover], garden.ileana\n  end\n\n  def test_joseph\n    skip\n    assert_equal [:violets, :clover, :violets, :grass], garden.joseph\n  end\n\n  def test_kincaid\n    skip\n    assert_equal [:grass, :clover, :clover, :grass], garden.kincaid\n  end\n\n  def test_larry\n    skip\n    assert_equal [:grass, :violets, :clover, :violets], garden.larry\n  end\nend\n\nclass DisorderedTest < MiniTest::Unit::TestCase\n\n  def setup\n    diagram = \"VCRRGVRG\\nRVGCCGCV\"\n    students = [\"Samantha\", \"Patricia\", \"Xander\", \"Roger\"]\n    @garden = Garden.new(diagram, students)\n  end\n\n  def garden\n    @garden\n  end\n\n  def test_patricia\n    skip\n    assert_equal [:violets, :clover, :radishes, :violets], garden.patricia\n  end\n\n  def test_roger\n    skip\n    assert_equal [:radishes, :radishes, :grass, :clover], garden.roger\n  end\n\n  def test_samantha\n    skip\n    assert_equal [:grass, :violets, :clover, :grass], garden.samantha\n  end\n\n  def test_xander\n    skip\n    assert_equal [:radishes, :grass, :clover, :violets], garden.xander\n  end\n\nend\n\nclass TwoGardensDifferentStudents < MiniTest::Unit::TestCase\n def diagram\n   \"VCRRGVRG\\nRVGCCGCV\"\n end\n\n def garden_1\n   @garden_1 ||= Garden.new(diagram, [\"Alice\", \"Bob\", \"Charlie\", \"Dan\"])\n end\n\n def garden_2\n   @garden_2 ||= Garden.new(diagram, [\"Bob\", \"Charlie\", \"Dan\", \"Erin\"])\n end\n\n def test_bob_and_charlie_per_garden\n   skip\n   assert_equal [:radishes, :radishes, :grass, :clover], garden_1.bob\n   assert_equal [:violets, :clover, :radishes, :violets], garden_2.bob\n   assert_equal [:grass, :violets, :clover, :grass], garden_1.charlie\n   assert_equal [:radishes, :radishes, :grass, :clover], garden_2.charlie\n end\nend\n",
          "README.md": "# Kindergarten Garden\n\nWrite a program that, given a diagram, can tell you which plants each child in the kindergarten class is responsible for.\n\nThe kindergarten class is learning about growing plants. The teachers thought it would be a good idea to give them actual seeds, plant them in actual dirt, and grow actual plants.\n\nThey've chosen to grow grass, clover, radishes, and violets.\n\nTo this end, they've put little styrofoam cups along the window sills, and\nplanted one type of plant in each cup, choosing randomly from the available\ntypes of seeds.\n\n```plain\n[window][window][window]\n........................ # each dot represents a styrofoam cup\n........................\n```\n\nThere are 12 children in the class:\n\n- Alice, Bob, Charlie, David,\n- Eve, Fred, Ginny, Harriet,\n- Ileana, Joseph, Kincaid, and Larry.\n\nEach child gets 4 cups, two on each row. The children are assigned to cups in alphabetical order.\n\nThe following diagram represents Alice's plants:\n\n```plain\n[window][window][window]\nVR......................\nRG......................\n```\n\nSo in the row nearest the window, she has a violet and a radish; in the row behind that, she has a radish and some grass.\n\nYour program will be given the plants from left-to-right starting with the row\nnearest the windows. From this, it should be able to determine which plants belong to which students.\n\nFor example, if it's told that the garden looks like so:\n\n```plain\n[window][window][window]\nVRCGVVRVCGGCCGVRGCVCGCGV\nVRCCCGCRRGVCGCRVVCVGCGCV\n```\n\nThen if asked for Alice's plants, it should provide:\n\n- Violets, radishes, violets, radishes\n\nWhile asking for Bob's plants would yield:\n\n- Clover, grass, clover, clover\n\n\n## Source\n\nRandom musings during airplane trip. [view source](http://jumpstartlab.com)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/linked-list",
        "track_id": "ruby",
        "slug": "linked-list",
        "files": {
          "linked_list_test.rb": "require 'minitest/autorun'\nrequire_relative 'linked_list'\n\nclass DequeTest < MiniTest::Unit::TestCase\n\n  def test_push_pop\n    deque = Deque.new\n    deque.push(10)\n    deque.push(20)\n    assert_equal 20, deque.pop()\n    assert_equal 10, deque.pop()\n  end\n\n  def test_push_shift\n    skip\n    deque = Deque.new\n    deque.push(10)\n    deque.push(20)\n    assert_equal 10, deque.shift()\n    assert_equal 20, deque.shift()\n  end\n\n  def test_unshift_shift\n    skip\n    deque = Deque.new\n    deque.unshift(10)\n    deque.unshift(20)\n    assert_equal 20, deque.shift()\n    assert_equal 10, deque.shift()\n  end\n\n  def test_unshift_pop\n    skip\n    deque = Deque.new\n    deque.unshift(10)\n    deque.unshift(20)\n    assert_equal 10, deque.pop()\n    assert_equal 20, deque.pop()\n  end\n\n  def test_example\n    skip\n    deque = Deque.new\n    deque.push(10)\n    deque.push(20)\n    assert_equal 20, deque.pop()\n    deque.push(30)\n    assert_equal 10, deque.shift()\n    deque.unshift(40)\n    deque.push(50)\n    assert_equal 40, deque.shift()\n    assert_equal 50, deque.pop()\n    assert_equal 30, deque.shift()\n  end\n\nend\n",
          "README.md": "# Linked List\n\nWrite a simple linked list implementation that uses the Proxy pattern\n\nDeques have four fundamental operations (using Array terminology):\n\n* push (insert value at back)\n* unshift (insert value at front)\n* pop (remove value at back)\n* shift (remove value at front)\n\nThe difference between deque and Array performance is that a deque\nimplements all of these operations in constant time. Even clever\nimplemetations of Array will often have to copy the entire Array\nin order to unshift.\n\nUnder the hood we'll use an Element class with two fields, `next` and\n`prev`, that are both writable.\n\nTo make the API usable, you'll use a Deque class as a proxy for this\nlist. There two good ways to implement Deque: maintain separate references to the\nfirst and last Element, or maintain a reference to one of them and\nensure that the list is circular.\n\nTo keep your implementation simple, the tests will not cover error\nconditions. Specifically: pop or shift will never be called on an empty Deque.\n\nIn languages that do not have good support for mutability (such as\nElixir or Erlang), you may choose to implement a functional Deque\nwhere shift and pop have amortized O(1) time. The simplest data structure\nfor this will have a pair of linked lists for the front and back,\nwhere iteration order is front ++ reverse back.\n\n\n## Source\n\nInspired by 'Data Structures and Algorithms with Object-Oriented Design Patterns in Ruby', singly linked-lists. [view source](http://www.brpreiss.com/books/opus8/html/page96.html#SECTION004300000000000000000)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/pythagorean-triplet",
        "track_id": "ruby",
        "slug": "pythagorean-triplet",
        "files": {
          "pythagorean_triplet_test.rb": "require 'minitest/autorun'\nrequire_relative 'triplet'\n\nclass TripletTest < MiniTest::Unit::TestCase\n  def test_sum\n    assert_equal 12, Triplet.new(3, 4, 5).sum\n  end\n\n  def test_product\n    skip\n    assert_equal 60, Triplet.new(3, 4, 5).product\n  end\n\n  def test_pythagorean\n    skip\n    assert Triplet.new(3, 4, 5).pythagorean?\n  end\n\n  def test_not_pythagorean\n    skip\n    assert !Triplet.new(5, 6, 7).pythagorean?\n  end\n\n  def test_triplets_upto_10\n    skip\n    triplets = Triplet.where(max_factor: 10)\n    products = triplets.map(&:product).sort\n    assert_equal [60, 480], products\n  end\n\n  def test_triplets_from_11_upto_20\n    skip\n    triplets = Triplet.where(min_factor: 11, max_factor: 20)\n    products = triplets.map(&:product).sort\n    assert_equal [3840], products\n  end\n\n  def test_triplets_where_sum_x\n    skip\n    triplets = Triplet.where(sum: 180, max_factor: 100)\n    products = triplets.map(&:product).sort\n    assert_equal [118080, 168480, 202500], products\n  end\nend\n",
          "README.md": "# Pythagorean Triplet\n\nThere exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product a * b * c.\n\nA Pythagorean triplet is a set of three natural numbers, {a, b, c}, for which,\n\na**2 + b**2 = c**2\n\nFor example, 3**2 + 4**2 = 9 + 16 = 25 = 5**2.\n\n\n## Source\n\nProblem 9 at Project Euler [view source](http://projecteuler.net/problem=9)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/robot-simulator",
        "track_id": "ruby",
        "slug": "robot-simulator",
        "files": {
          "robot_simulator_test.rb": "require 'minitest/autorun'\nrequire_relative 'simulator'\n\nclass RobotTurningTest < MiniTest::Unit::TestCase\n\n  def robot\n    @robot\n  end\n\n  def setup\n    @robot = Robot.new\n  end\n\n  def test_robot_bearing\n    [:east, :west, :north, :south].each do |direction|\n      robot.orient(direction)\n      assert_equal direction, robot.bearing\n    end\n  end\n\n  def test_invalid_robot_bearing\n    skip\n    assert_raises ArgumentError do\n      robot.orient(:crood)\n    end\n  end\n\n  def test_turn_right_from_north\n    skip\n    robot.orient(:north)\n    robot.turn_right\n    assert_equal :east, robot.bearing\n  end\n\n  def test_turn_right_from_east\n    skip\n    robot.orient(:east)\n    robot.turn_right\n    assert_equal :south, robot.bearing\n  end\n\n  def test_turn_right_from_south\n    skip\n    robot.orient(:south)\n    robot.turn_right\n    assert_equal :west, robot.bearing\n  end\n\n  def test_turn_right_from_west\n    skip\n    robot.orient(:west)\n    robot.turn_right\n    assert_equal :north, robot.bearing\n  end\n\n  def test_turn_left_from_north\n    skip\n    robot.orient(:north)\n    robot.turn_left\n    assert_equal :west, robot.bearing\n  end\n\n  def test_turn_left_from_east\n    skip\n    robot.orient(:east)\n    robot.turn_left\n    assert_equal :north, robot.bearing\n  end\n\n  def test_turn_left_from_south\n    skip\n    robot.orient(:south)\n    robot.turn_left\n    assert_equal :east, robot.bearing\n  end\n\n  def test_turn_left_from_west\n    skip\n    robot.orient(:west)\n    robot.turn_left\n    assert_equal :south, robot.bearing\n  end\n\n  def test_robot_coordinates\n    skip\n    robot.at(3, 0)\n    assert_equal [3, 0], robot.coordinates\n  end\n\n  def test_other_robot_coordinates\n    skip\n    robot.at(-2, 5)\n    assert_equal [-2, 5], robot.coordinates\n  end\n\n  def test_advance_when_facing_north\n    skip\n    robot.at(0,0)\n    robot.orient(:north)\n    robot.advance\n    assert_equal [0, 1], robot.coordinates\n  end\n\n  def test_advance_when_facing_east\n    skip\n    robot.at(0,0)\n    robot.orient(:east)\n    robot.advance\n    assert_equal [1, 0], robot.coordinates\n  end\n\n  def test_advance_when_facing_south\n    skip\n    robot.at(0,0)\n    robot.orient(:south)\n    robot.advance\n    assert_equal [0, -1], robot.coordinates\n  end\n\n  def test_advance_when_facing_west\n    skip\n    robot.at(0,0)\n    robot.orient(:west)\n    robot.advance\n    assert_equal [-1, 0], robot.coordinates\n  end\nend\n\nclass RobotSimulatorTest < MiniTest::Unit::TestCase\n  def simulator\n    @simulator ||= Simulator.new\n  end\n\n  def test_instructions_for_turning_left\n    skip\n    assert_equal [:turn_left], simulator.instructions(\"L\")\n  end\n\n  def test_instructions_for_turning_right\n    skip\n    assert_equal [:turn_right], simulator.instructions(\"R\")\n  end\n\n  def test_instructions_for_advancing\n    skip\n    assert_equal [:advance], simulator.instructions(\"A\")\n  end\n\n  def test_series_of_instructions\n    skip\n    commands = [:turn_right, :advance, :advance, :turn_left]\n    assert_equal commands, simulator.instructions(\"RAAL\")\n  end\n\n  def test_instruct_robot\n    skip\n    robot = Robot.new\n    simulator.place(robot, x: -2, y: 1, direction: :east)\n    simulator.evaluate(robot, \"RLAALAL\")\n    assert_equal [0,2], robot.coordinates\n    assert_equal :west, robot.bearing\n  end\n\n  def test_instruct_many_robots\n    skip\n    robot1 = Robot.new\n    robot2 = Robot.new\n    robot3 = Robot.new\n    simulator.place(robot1, x: 0, y: 0, direction: :north)\n    simulator.place(robot2, x: 2, y: -7, direction: :east)\n    simulator.place(robot3, x: 8, y: 4, direction: :south)\n    simulator.evaluate(robot1, \"LAAARALA\")\n    simulator.evaluate(robot2, \"RRAAAAALA\")\n    simulator.evaluate(robot3, \"LAAARRRALLLL\")\n\n    assert_equal [-4, 1], robot1.coordinates\n    assert_equal :west, robot1.bearing\n\n    assert_equal [-3, -8], robot2.coordinates\n    assert_equal :south, robot2.bearing\n\n    assert_equal [11, 5], robot3.coordinates\n    assert_equal :north, robot3.bearing\n  end\nend\n",
          "README.md": "# Robot Simulator\n\nWrite a robot simulator.\n\n## Step 1\n\nThe robot factory manufactures robots that have three possible movements:\n\n* turn right\n* turn left\n* advance\n\nRobots are placed on a hypothetical infinite grid, facing a particular\ndirection (north, east, south, or west) at a set of {x,y} coordinates, e.g.,\n{3,8}.\n\n## Step 2\n\nRobots can pivot left and right.\n\nThe robot factory manufactures robots that have three possible movements:\n\n* turn right\n* turn left\n* advance\n\nThe factory's test facility needs a program to verify robot movements.\n\nThere are a number of different rooms of varying sizes, measured in Robot\nUnits, the distance a robot moves when you instruct it to `advance`.\n\nThe floor of the room is a grid, each square of which measures 1 square RU\n(Robot Unit).\n\nThe rooms are always oriented so that each wall faces east, south, west, and\nnorth.\n\nThe test algorithm is to place a robot at a coordinate in the room, facing in\na particular direction.\n\nThe robot then receives a number of instructions, at which point the testing\nfacility verifies the robot's new position, and in which direction it is\npointing.\n\n## Step 3\n\nThe robot factory manufactures robots that have three possible movements:\n\n* turn right\n* turn left\n* advance\n\nThe robot factory's test facility has a simulator which can take a string of\nletters and feed this into a robot as instructions.\n\n- The letter-string \"RAALAL\" means:\n  - Turn right\n  - Advance twice\n  - Turn left\n  - Advance once\n  - Turn left yet again\n- Say a robot starts at {7, 3} facing north.\n  Then running this stream of instructions should leave it\n  at {9, 4} facing west.\n\n\n## Source\n\nInspired by an interview question at a famous company. [view source]()\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/twelve-days",
        "track_id": "ruby",
        "slug": "twelve-days",
        "files": {
          "twelve_days_test.rb": "require 'minitest/autorun'\nrequire_relative 'twelve_days'\n\nclass TwelveDaysTest < MiniTest::Unit::TestCase\n\n  def song\n    @song ||= ::TwelveDaysSong.new\n  end\n\n  def teardown\n    @song = nil\n  end\n\n  def test_verse1\n    expected = \"On the first day of Christmas my true love gave to me, a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(1)\n  end\n\n  def test_verse2\n    skip\n    expected = \"On the second day of Christmas my true love gave to me, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(2)\n  end\n\n  def test_verse3\n    skip\n    expected = \"On the third day of Christmas my true love gave to me, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(3)\n  end\n\n  def test_verse4\n    skip\n    expected = \"On the fourth day of Christmas my true love gave to me, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(4)\n  end\n\n  def test_verse5\n    skip\n    expected = \"On the fifth day of Christmas my true love gave to me, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(5)\n  end\n\n  def test_verse6\n    skip\n    expected = \"On the sixth day of Christmas my true love gave to me, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(6)\n  end\n\n  def test_verse7\n    skip\n    expected = \"On the seventh day of Christmas my true love gave to me, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(7)\n  end\n\n  def test_verse8\n    skip\n    expected = \"On the eighth day of Christmas my true love gave to me, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(8)\n  end\n\n  def test_verse9\n    skip\n    expected = \"On the ninth day of Christmas my true love gave to me, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(9)\n  end\n\n  def test_verse10\n    skip\n    expected = \"On the tenth day of Christmas my true love gave to me, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(10)\n  end\n\n  def test_verse11\n    skip\n    expected = \"On the eleventh day of Christmas my true love gave to me, eleven Pipers Piping, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(11)\n  end\n\n  def test_verse12\n    skip\n    expected = \"On the twelfth day of Christmas my true love gave to me, twelve Drummers Drumming, eleven Pipers Piping, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(12)\n  end\n\n  def test_multiple_verses\n    skip\n    expected =\n      \"On the first day of Christmas my true love gave to me, a Partridge in a Pear Tree.\\n\\n\" +\n      \"On the second day of Christmas my true love gave to me, two Turtle Doves, and a Partridge in a Pear Tree.\\n\\n\" +\n      \"On the third day of Christmas my true love gave to me, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\\n\"\n    assert_equal expected, song.verses(1, 3)\n  end\n\n  def test_the_whole_song\n    skip\n    assert_equal song.verses(1, 12), song.sing\n  end\nend\n",
          "README.md": "# Twelve Days\n\nWrite a program that outputs the lyrics to 'The Twelve Days of Christmas'\n\n```ruby\nOn the first day of Christmas my true love gave to me, a Partridge in a Pear Tree.\n\nOn the second day of Christmas my true love gave to me, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the third day of Christmas my true love gave to me, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the fourth day of Christmas my true love gave to me, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the fifth day of Christmas my true love gave to me, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the sixth day of Christmas my true love gave to me, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the seventh day of Christmas my true love gave to me, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the eighth day of Christmas my true love gave to me, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the ninth day of Christmas my true love gave to me, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the tenth day of Christmas my true love gave to me, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the eleventh day of Christmas my true love gave to me, eleven Pipers Piping, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the twelfth day of Christmas my true love gave to me, twelve Drummers Drumming, eleven Pipers Piping, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n```\n\n\n## Source\n\nWikipedia [view source](http://en.wikipedia.org/wiki/The_Twelve_Days_of_Christmas_(song))\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/circular-buffer",
        "track_id": "ruby",
        "slug": "circular-buffer",
        "files": {
          "circular_buffer_test.rb": "require 'minitest/autorun'\nrequire_relative 'circular_buffer'\n\nclass CircularBufferTest < MiniTest::Unit::TestCase\n  \n  def test_read_empty_buffer_throws_buffer_empty_exception\n    buffer = CircularBuffer.new(1)\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\n  end\n  \n  def test_write_and_read_back_one_item\n    skip\n    buffer = CircularBuffer.new(1)\n    buffer.write '1'\n    assert_equal '1', buffer.read\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\n  end\n  \n  def test_write_and_read_back_multiple_items\n    skip\n    buffer = CircularBuffer.new(2)\n    buffer.write '1'\n    buffer.write '2'\n    assert_equal '1', buffer.read\n    assert_equal '2', buffer.read\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\n  end\n  \n  def test_clearing_buffer\n    skip\n    buffer = CircularBuffer.new(3)\n    (1..3).each { |i| buffer.write String(i) }\n    buffer.clear\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\n    buffer.write '1'\n    buffer.write '2'\n    assert_equal '1', buffer.read\n    buffer.write '3'\n    assert_equal '2', buffer.read\n  end\n  \n  def test_alternate_write_and_read\n    skip\n    buffer = CircularBuffer.new(2)\n    buffer.write '1'\n    assert_equal '1', buffer.read\n    buffer.write '2'\n    assert_equal '2', buffer.read\n  end\n\n  def test_reads_back_oldest_item\n    skip\n    buffer = CircularBuffer.new(3)\n    buffer.write '1'\n    buffer.write '2'\n    buffer.read\n    buffer.write '3'\n    assert_equal '2', buffer.read\n    assert_equal '3', buffer.read\n  end\n  \n  def test_writes_of_nil_should_not_occupy_buffer\n    skip    \n    buffer = CircularBuffer.new(5)\n    buffer.write nil\n    (1..3).each { |i| buffer.write String(i) }\n    assert_equal '1', buffer.read\n  end\n  \n  def test_writing_to_a_full_buffer_throws_an_exception\n    skip    \n    buffer = CircularBuffer.new(2)\n    buffer.write '1'\n    buffer.write '2'\n    assert_raises(CircularBuffer::BufferFullException) { buffer.write 'A' }\n  end\n\n  def test_overwriting_oldest_item_in_a_full_buffer\n    skip    \n    buffer = CircularBuffer.new(2)\n    buffer.write '1'\n    buffer.write '2'\n    buffer.write! 'A'\n    assert_equal '2', buffer.read\n    assert_equal 'A', buffer.read\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\n  end\n  \n  def test_alternate_read_and_write_into_buffer_overflow\n    skip    \n    buffer = CircularBuffer.new(5)\n    (1..3).each { |i| buffer.write String(i) }\n    buffer.read\n    buffer.read\n    buffer.write '4'\n    buffer.read\n    (5..8).each { |i| buffer.write String(i) }\n    buffer.write! 'A'\n    buffer.write! 'B'\n    (6..8).each do |i| \n      assert_equal String(i), buffer.read\n    end\n    assert_equal 'A', buffer.read\n    assert_equal 'B', buffer.read\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\n  end\n    \nend\n",
          "README.md": "# Circular Buffer\n\nA data structure that uses a single, fixed-size buffer as if it were connected end-to-end.\n\nA circular buffer, cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. \n\nA circular buffer first starts empty and of some predefined length. For example, this is a 7-element buffer:\n[ ][ ][ ][ ][ ][ ][ ]\n\nAssume that a 1 is written into the middle of the buffer (exact starting location does not matter in a circular buffer):\n[ ][ ][ ][1][ ][ ][ ]\n\nThen assume that two more elements are added — 2 & 3 — which get appended after the 1:\n[ ][ ][ ][1][2][3][ ]\n\nIf two elements are then removed from the buffer, the oldest values inside the buffer are removed. The two elements removed, in this case, are 1 & 2, leaving the buffer with just a 3:\n[ ][ ][ ][ ][ ][3][ ]\n\nIf the buffer has 7 elements then it is completely full:\n[6][7][8][9][3][4][5]\n\nA consequence of the circular buffer is that when it is full and a subsequent write is performed, then it starts overwriting the oldest data. In this case, two more elements — A & B — are added and they overwrite the 3 & 4:\n[6][7][8][9][A][B][5]\n\nFinally, if two elements are now removed then what would be returned is not 3 & 4 but 5 & 6 because A & B overwrote the 3 & the 4 yielding the buffer with:\n[ ][7][8][9][A][B][ ]\n\n## Source\n\nWikipedia [view source](http://en.wikipedia.org/wiki/Circular_buffer)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/largest-series-product",
        "track_id": "ruby",
        "slug": "largest-series-product",
        "files": {
          "largest_series_product_test.rb": "require 'minitest/autorun'\nrequire_relative 'series'\n\nclass SeriesTest < MiniTest::Unit::TestCase\n  def test_digits\n    assert_equal (0..9).to_a, Series.new(\"0123456789\").digits\n  end\n\n  def test_same_digits_reversed\n    skip\n    assert_equal (0..9).to_a.reverse, Series.new(\"9876543210\").digits\n  end\n\n  def test_fewer_digits\n    skip\n    assert_equal (4..8).to_a.reverse, Series.new(\"87654\").digits\n  end\n\n  def test_some_other_digits\n    skip\n    assert_equal [9, 3, 6, 9, 2, 3, 4, 6, 8], Series.new(\"936923468\").digits\n  end\n\n  def test_slices_of_zero\n    skip\n    assert_equal [], Series.new(\"\").digits\n  end\n\n  def test_slices_of_2\n    skip\n    series = Series.new(\"01234\")\n    expected = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert_equal expected, series.slices(2)\n  end\n\n  def test_other_slices_of_2\n    skip\n    series = Series.new(\"98273463\")\n    expected = [[9, 8], [8, 2], [2, 7], [7, 3], [3, 4], [4, 6], [6, 3]]\n    assert_equal expected, series.slices(2)\n  end\n\n  def test_slices_of_3\n    skip\n    series = Series.new(\"01234\")\n    expected = [[0, 1, 2], [1, 2, 3], [2, 3, 4]]\n    assert_equal expected, series.slices(3)\n  end\n\n  def test_other_slices_of_3\n    skip\n    series = Series.new(\"982347\")\n    expected = [[9, 8, 2], [8, 2, 3], [2, 3, 4], [3, 4, 7]]\n    assert_equal expected, series.slices(3)\n  end\n\n  def test_largest_product_of_2\n    skip\n    series = Series.new(\"0123456789\")\n    assert_equal 72, series.largest_product(2)\n  end\n\n  def test_largest_product_of_a_tiny_number\n    skip\n    series = Series.new(\"12\")\n    assert_equal 2, series.largest_product(2)\n  end\n\n  def test_another_tiny_number\n    skip\n    series = Series.new(\"19\")\n    assert_equal 9, series.largest_product(2)\n  end\n\n  def test_largest_product_of_2_shuffled\n    skip\n    series = Series.new(\"576802143\")\n    assert_equal 48, series.largest_product(2)\n  end\n\n  def test_largest_product_of_3\n    skip\n    series = Series.new(\"0123456789\")\n    assert_equal 504, series.largest_product(3)\n  end\n\n  def test_largest_product_of_3_shuffled\n    skip\n    series = Series.new(\"1027839564\")\n    assert_equal 270, series.largest_product(3)\n  end\n\n  def test_largest_product_of_5\n    skip\n    series = Series.new(\"0123456789\")\n    assert_equal 15120, series.largest_product(5)\n  end\n\n  def test_some_big_number\n    skip\n    s = \"73167176531330624919225119674426574742355349194934\"\n    series = Series.new(s)\n    assert_equal 23520, series.largest_product(6)\n  end\n\n  def test_some_other_big_number\n    skip\n    s = \"52677741234314237566414902593461595376319419139427\"\n    series = Series.new(s)\n    assert_equal 28350, series.largest_product(6)\n  end\n\n  def test_identity\n    skip\n    series = Series.new(\"\")\n    assert_equal 1, series.largest_product(0)\n  end\n\n  def test_slices_bigger_than_number\n    skip\n    series = Series.new(\"123\")\n    assert_raises ArgumentError do\n      series.largest_product(4)\n    end\n  end\nend\n",
          "README.md": "# Largest Series Product\n\nWrite a program that, when given a string of digits, can calculate the largest product for a series of consecutive digits of length n.\n\nFor example, for the input `'0123456789'`, the largest product for a series of 3 digits is 504 (7 * 8 * 9), and the largest product for a series of 5 digits is 15120 (5 * 6 * 7 * 8 * 9).\n\nFor the input `'73167176531330624919225119674426574742355349194934'`, the largest product for a series of 6 digits is 23520.\n\n\n## Source\n\nA variation on Problem 8 at Project Euler [view source](http://projecteuler.net/problem=8)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/binary-search",
        "track_id": "ruby",
        "slug": "binary-search",
        "files": {
          "binary_search_test.rb": "require 'minitest/autorun'\nrequire_relative 'binary'\n\nclass BinarySearchTest < MiniTest::Unit::TestCase\n\n  def test_it_has_list_data\n    binary = BinarySearch.new([1, 3, 4, 6, 8, 9, 11])\n    assert_equal [1, 3, 4, 6, 8, 9, 11], binary.list\n  end\n\n  def test_it_raises_error_for_unsorted_list\n    skip\n    assert_raises ArgumentError do\n      BinarySearch.new([2, 1, 4, 3, 6])\n    end\n  end\n\n  def test_it_raises_error_for_data_not_in_list\n    skip\n    assert_raises RuntimeError do\n      BinarySearch.new([1, 3, 6]).search_for(2)\n    end\n  end\n\n  def test_it_finds_position_of_middle_item\n    skip\n    binary = BinarySearch.new([1, 3, 4, 6, 8, 9, 11])\n    assert_equal 3, binary.middle\n  end\n\n  def test_it_finds_position_of_search_data\n    skip\n    binary = BinarySearch.new([1, 3, 4, 6, 8, 9, 11])\n    assert_equal 5, binary.search_for(9)\n  end\n\n  def test_it_finds_position_in_a_larger_list\n    skip\n    binary = BinarySearch.new([1, 3, 5, 8, 13, 21, 34, 55, 89, 144])\n    assert_equal 1, binary.search_for(3)\n    assert_equal 7, binary.search_for(55)\n  end\n\n  def test_it_finds_correct_position_in_a_list_with_an_even_number_of_elements\n    skip\n    binary = BinarySearch.new([1, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377])\n    assert_equal 5, binary.search_for(21)\n    assert_equal 6, binary.search_for(34)\n  end\nend\n",
          "README.md": "# Binary Search\n\nWrite a program that implements a binary search algorithm.\n\nSearching a sorted collection is a common task. A dictionary is a sorted list of word definitions. Given a word, one can find its definition. A telephone book is a sorted list of people's names, addresses, and telephone numbers. Knowing someone's name allows one to quickly find their telephone number and address.\n\nIf the list to be searched contains more than a few items (a dozen, say) a binary search will require far fewer comparisons than a linear search, but it imposes the requirement that the list be sorted.\n\nIn computer science, a binary search or half-interval search algorithm finds the position of a specified input value (the search \"key\") within an array sorted by key value.\n\nIn each step, the algorithm compares the search key value with the key value of the middle element of the array.\n\nIf the keys match, then a matching element has been found and its index, or position, is returned.\n\nOtherwise, if the search key is less than the middle element's key, then the algorithm repeats its action on the sub-array to the left of the middle element or, if the search key is greater, on the sub-array to the right.\n\nIf the remaining array to be searched is empty, then the key cannot be found in the array and a special \"not found\" indication is returned.\n\nA binary search halves the number of items to check with each iteration, so locating an item (or determining its absence) takes logarithmic time. A binary search is a dichotomic divide and conquer search algorithm.\n\n\n## Source\n\nWikipedia [view source](http://en.wikipedia.org/wiki/Binary_search_algorithm)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/pascals-triangle",
        "track_id": "ruby",
        "slug": "pascals-triangle",
        "files": {
          "pascals_triangle_test.rb": "require 'minitest/autorun'\nrequire_relative 'triangle'\n\nclass TriangleTest < MiniTest::Unit::TestCase\n\n  def test_one_row\n    triangle = Triangle.new(1)\n    assert_equal [[1]], triangle.rows\n  end\n\n  def test_two_rows\n    skip\n    triangle = Triangle.new(2)\n    assert_equal [[1], [1, 1]], triangle.rows\n  end\n\n  def test_three_rows\n    skip\n    triangle = Triangle.new(3)\n    assert_equal [[1], [1, 1], [1, 2, 1]], triangle.rows\n  end\n\n  def test_fourth_row\n    skip\n    triangle = Triangle.new(4)\n    assert_equal [1, 3, 3, 1], triangle.rows.last\n  end\n\n  def test_fifth_row\n    skip\n    triangle = Triangle.new(5)\n    assert_equal [1, 4, 6, 4, 1], triangle.rows.last\n  end\n\n  def test_twentieth_row\n    skip\n    triangle = Triangle.new(20)\n    expected = [1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1]\n    assert_equal expected, triangle.rows.last\n  end\nend\n",
          "README.md": "# Pascals Triangle\n\nWrite a program that computes Pascal's triangle up to a given number of rows.\n\nIn Pascal's Triangle each number is computed by adding the numbers to the\nright and left of the current position in the previous row.\n\n```plain\n    1\n   1 1\n  1 2 1\n 1 3 3 1\n1 4 6 4 1\n# ... etc\n```\n\n\n## Source\n\nPascal's Triangle at Wolfram Math World [view source](http://mathworld.wolfram.com/PascalsTriangle.html)\n"
        },
        "fresh": true
      },
      {
        "id": "ruby/custom-set",
        "track_id": "ruby",
        "slug": "custom-set",
        "files": {
          "custom_set_test.rb": "require 'minitest/autorun'\nrequire_relative 'custom_set'\n\nclass CustomSetTest < MiniTest::Unit::TestCase\n\n  def test_equal\n    assert_equal CustomSet.new([1, 3]), CustomSet.new([3, 1])\n  end\n\n  def test_delete\n    skip\n    assert_equal CustomSet.new([1,3]), CustomSet.new([3,2,1]).delete(2)\n    assert_equal CustomSet.new([1,2,3]), CustomSet.new([3,2,1]).delete(4)\n    assert_equal CustomSet.new([1,2,3]), CustomSet.new([3,2,1]).delete(2.0)\n  end\n\n  def test_difference\n    skip\n    assert_equal CustomSet.new([1,3]),\n      CustomSet.new([1,2,3]).difference(CustomSet.new([2,4]))\n\n    assert_equal CustomSet.new([1,2.0,3]),\n      CustomSet.new([1,2.0,3]).difference(CustomSet.new([2,4]))\n  end\n\n  def test_disjoint?\n    skip\n    assert CustomSet.new([1,2]).disjoint?(CustomSet.new([3,4]))\n    refute CustomSet.new([1,2]).disjoint?(CustomSet.new([2,3]))\n    assert CustomSet.new([1.0,2.0]).disjoint?(CustomSet.new([2,3]))\n    assert CustomSet.new.disjoint?(CustomSet.new)\n  end\n\n  def test_empty\n    skip\n    assert_equal CustomSet.new, CustomSet.new([1,2]).empty\n    assert_equal CustomSet.new, CustomSet.new.empty\n  end\n\n  def test_intersection\n    skip\n    assert_equal CustomSet.new([:a, :c]),\n      CustomSet.new([:a, :b, :c]).intersection(CustomSet.new([:a, :c, :d]))\n\n    assert_equal CustomSet.new([3]),\n      CustomSet.new([1, 2, 3]).intersection(CustomSet.new([1.0, 2.0, 3]))\n  end\n\n  def test_member?\n    skip\n    assert CustomSet.new([1,2,3]).member?(2)\n    assert CustomSet.new(1..3).member?(2)\n    refute CustomSet.new(1..3).member?(2.0)\n    refute CustomSet.new(1..3).member?(4)\n  end\n\n  def test_put\n    skip\n    assert_equal CustomSet.new([1,2,3,4]),\n      CustomSet.new([1,2,4]).put(3)\n\n    assert_equal CustomSet.new([1,2,3]),\n      CustomSet.new([1,2,3]).put(3)\n\n    assert_equal CustomSet.new([1,2,3,3.0]),\n      CustomSet.new([1,2,3]).put(3.0)\n  end\n\n  def test_size\n    skip\n    assert_equal 0, CustomSet.new.size\n    assert_equal 3, CustomSet.new([1,2,3]).size\n    assert_equal 3, CustomSet.new([1,2,3,2]).size\n  end\n\n  def test_subset?\n    skip\n    assert CustomSet.new([1,2,3]).subset?(CustomSet.new([1,2,3]))\n    assert CustomSet.new([4,1,2,3]).subset?(CustomSet.new([1,2,3]))\n    refute CustomSet.new([4,1,3]).subset?(CustomSet.new([1,2,3]))\n    refute CustomSet.new([1,2,3,4]).subset?(CustomSet.new([1,2,3.0]))\n    assert CustomSet.new([4,1,3]).subset?(CustomSet.new)\n    assert CustomSet.new.subset?(CustomSet.new)\n  end\n\n  def test_to_list\n    skip\n    assert_equal [], CustomSet.new.to_list.sort\n    assert_equal [1,2,3], CustomSet.new([3,1,2]).to_list.sort\n    assert_equal [1,2,3], CustomSet.new([3,1,2,1]).to_list.sort\n  end\n\n  def test_union\n    skip\n    assert_equal CustomSet.new([3,2,1]),\n      CustomSet.new([1,3]).union(CustomSet.new([2]))\n    assert_equal CustomSet.new([3.0,3,2,1]),\n      CustomSet.new([1,3]).union(CustomSet.new([2,3.0]))\n    assert_equal CustomSet.new([3,1]),\n      CustomSet.new([1,3]).union(CustomSet.new)\n    assert_equal CustomSet.new([2]),\n      CustomSet.new([2]).union(CustomSet.new)\n    assert_equal CustomSet.new([]),\n      CustomSet.new.union(CustomSet.new)\n  end\n\nend\n",
          "README.md": "# Custom Set\n\nCreate a custom set type.\n\nSometimes it is necessary to define a custom data structure of some type, like a\nset. In this exercise you will define your own set. How it works internally\ndoesn't matter, as long as it behaves like a set of unique elements.\n\n\n## Source\n\n [view source]()\n"
        },
        "fresh": true
      }
    ]
  }
}
