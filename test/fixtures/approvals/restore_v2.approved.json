{
  "problems": [
    {
      "id": "go/leap",
      "track_id": "go",
      "language": "go",
      "slug": "leap",
      "name": "Leap",
      "files": {
        "cases_test.go": "package leap\n\n// Source: exercism/x-common\n// Commit: 945d08e Merge pull request #50 from soniakeys/master\n\nvar testCases = []struct {\n\tyear        int\n\texpected    bool\n\tdescription string\n}{\n\t{1996, true, \"leap year\"},\n\t{1997, false, \"non-leap year\"},\n\t{1998, false, \"non-leap even year\"},\n\t{1900, false, \"century\"},\n\t{2400, true, \"fourth century\"},\n\t{2000, true, \"Y2K\"},\n}\n",
        "leap_test.go": "package leap\n\nimport \"testing\"\n\n// Define a function IsLeapYear(int) bool.\n//\n// Also define an exported TestVersion with a value that matches\n// the internal testVersion here.\n\nconst testVersion = 1\n\n// Retired testVersions\n// (none) 4a9e144a3c5dc0d9773f4cf641ffe3efe48641d8\n\nfunc TestLeapYears(t *testing.T) {\n\tif TestVersion != testVersion {\n\t\tt.Fatalf(\"Found TestVersion = %v, want %v\", TestVersion, testVersion)\n\t}\n\tfor _, test := range testCases {\n\t\tobserved := IsLeapYear(test.year)\n\t\tif observed != test.expected {\n\t\t\tt.Fatalf(\"IsLeapYear(%d) = %t, want %t (%s)\",\n\t\t\t\ttest.year, observed, test.expected, test.description)\n\t\t}\n\t}\n}\n\nfunc BenchmarkLeapYears(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range testCases {\n\t\t\tIsLeapYear(test.year)\n\t\t}\n\t}\n}\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\nTo run the tests simply run the command `go test` in the exercise directory.\n\nFor more detailed info about the Go track see the [help\npage](http://help.exercism.io/getting-started-with-go.html).\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n",
        "leap.go": "// iteration 2"
      },
      "fresh": false
    },
    {
      "id": "haskell/list-ops",
      "track_id": "haskell",
      "language": "haskell",
      "slug": "list-ops",
      "name": "List Ops",
      "files": {
        "ListOps.hs": "// iteration 1",
        "list-ops_test.hs": "{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Test.HUnit (Assertion, (@=?), runTestTT, Test(..), Counts(..))\nimport System.Exit (ExitCode(..), exitWith)\nimport qualified ListOps as L\nimport Control.Exception (Exception, throw, evaluate, try)\nimport Data.Typeable (Typeable)\n\ndata FoldlIsStrictException = FoldlIsStrictException deriving (Eq, Show, Typeable)\ninstance Exception FoldlIsStrictException\n\nexitProperly :: IO Counts -> IO ()\nexitProperly m = do\n  counts <- m\n  exitWith $ if failures counts /= 0 || errors counts /= 0 then ExitFailure 1 else ExitSuccess\n\ntestCase :: String -> Assertion -> Test\ntestCase label assertion = TestLabel label (TestCase assertion)\n\nmain :: IO ()\nmain = exitProperly $ runTestTT $ TestList\n       [ TestList listOpsTests ]\n\n\nbig :: Int\nbig = 100000\n\nlistOpsTests :: [Test]\nlistOpsTests =\n  [ testCase \"length of empty list\" $ do\n    0 @=? L.length ([] :: [Int])\n  , testCase \"length of non-empty list\" $ do\n    4 @=? L.length [1 .. 4 :: Int]\n  , testCase \"length of large list\" $ do\n    big @=? L.length [1 .. big :: Int]\n  , testCase \"reverse of empty list\" $ do\n    [] @=? L.reverse ([] :: [Int])\n  , testCase \"reverse of non-empty list\" $ do\n    [100 , 99 .. 1] @=? L.reverse [1 .. 100 :: Int]\n  , testCase \"map of empty list\" $ do\n    [] @=? L.map (+1) ([] :: [Int])\n  , testCase \"map of non-empty list\" $ do\n    [2, 4 .. 8] @=? L.map (+1) [1, 3 .. 7 :: Int]\n  , testCase \"filter of empty list\" $ do\n    [] @=? L.filter undefined ([] :: [Int])\n  , testCase \"filter of normal list\" $ do\n    [1, 3] @=? L.filter odd [1 .. 4 :: Int]\n  , testCase \"foldl' of empty list\" $ do\n    0 @=? L.foldl' (+) (0 :: Int) []\n  , testCase \"foldl' of non-empty list\" $ do\n    7 @=? L.foldl' (+) (-3) [1 .. 4 :: Int]\n  , testCase \"foldl' of huge list\" $ do\n    big * (big + 1) `div` 2 @=? L.foldl' (+) 0 [1 .. big]\n  , testCase \"foldl' with non-commutative function\" $ do\n    0 @=? L.foldl' (-) 10 [1 .. 4 :: Int]\n  , testCase \"foldl' is not just foldr . flip\" $ do\n    \"fdsa\" @=? L.foldl' (flip (:)) [] \"asdf\"\n  , testCase \"foldl' is accumulator-strict (use seq or BangPatterns)\" $ do\n    r <- try . evaluate $\n      L.foldl' (flip const) () [throw FoldlIsStrictException, ()]\n    Left FoldlIsStrictException @=? (r :: Either FoldlIsStrictException ())\n  , testCase \"foldr as id\" $ do\n    [1 .. big] @=? L.foldr (:) [] [1 .. big]\n  , testCase \"foldr as append\" $ do\n    [1 .. big] @=? L.foldr (:) [100 .. big] [1 .. 99]\n  , testCase \"++ of empty lists\" $ do\n    [] @=? [] L.++ ([] :: [Int])\n  , testCase \"++ of empty and non-empty lists\" $ do\n    [1 .. 4] @=? [] L.++ [1 .. 4 :: Int]\n  , testCase \"++ of non-empty and empty lists\" $ do\n    [1 .. 4] @=? [1 .. 4 :: Int] L.++ []\n  , testCase \"++ of non-empty lists\" $ do\n    [1 .. 5] @=? [1 .. 3] L.++ [4, 5 :: Int]\n  , testCase \"++ of large lists\" $ do\n    [1 .. big] @=? [1 .. big `div` 2] L.++ [1 + big `div` 2 .. big]\n  , testCase \"concat of no lists\" $ do\n    [] @=? L.concat ([] :: [[Int]])\n  , testCase \"concat of list of lists\" $ do\n    [1 .. 6] @=? L.concat [[1, 2], [3], [], [4, 5, 6 :: Int]]\n  , testCase \"concat of large list of small lists\" $ do\n    [1 .. big] @=? L.concat (map (:[]) [1 .. big])\n  ]\n",
        "README.md": "# List Ops\n\nImplement basic list operations\n\nIn functional languages list operations like `length`, `map`, and\n`reduce` are very common. Implement a series of basic list operations,\nwithout using existing functions.\n\nCheck out [Exercism\nHelp](http://help.exercism.io/getting-started-with-haskell.html) for\ninstructions to get started writing Haskell.\n\n## Running Tests\n\nUse `runhaskell` (included in the Haskell Platform) to compile and run your\nHaskell code.\n\n    $ runhaskell -Wall bob_test.hs\n\n## Source\n\n [view source]()\n"
      },
      "fresh": false
    },
    {
      "id": "haskell/word-count",
      "track_id": "haskell",
      "language": "haskell",
      "slug": "word-count",
      "name": "Word Count",
      "files": {
        "word-count_test.hs": "import Test.HUnit (Assertion, (@=?), runTestTT, Test(..), Counts(..))\nimport System.Exit (ExitCode(..), exitWith)\nimport Data.Map (fromList)\nimport WordCount (wordCount)\n\nexitProperly :: IO Counts -> IO ()\nexitProperly m = do\n  counts <- m\n  exitWith $ if failures counts /= 0 || errors counts /= 0 then ExitFailure 1 else ExitSuccess\n\ntestCase :: String -> Assertion -> Test\ntestCase label assertion = TestLabel label (TestCase assertion)\n\nwordCountTests :: [Test]\nwordCountTests =\n  [ testCase \"count one word\" $\n    fromList [(\"word\", 1)] @=? wordCount \"word\"\n  , testCase \"count one of each\" $\n    fromList [(\"one\", 1), (\"of\", 1), (\"each\", 1)] @=? wordCount \"one of each\"\n  , testCase \"count multiple occurrences\" $\n    fromList [(\"one\", 1), (\"fish\", 4), (\"two\", 1),\n              (\"red\", 1), (\"blue\", 1)] @=?\n    wordCount \"one fish two fish red fish blue fish\"\n  , testCase \"ignore punctuation\" $\n    fromList [(\"car\", 1), (\"carpet\", 1), (\"as\", 1),\n              (\"java\", 1), (\"javascript\", 1)] @=?\n    wordCount \"car : carpet as java : javascript!!&@$%^&\"\n  , testCase \"include numbers\" $\n    fromList [(\"testing\", 2), (\"1\", 1), (\"2\", 1)] @=?\n    wordCount \"testing, 1, 2 testing\"\n  , testCase \"normalize case\" $\n    fromList [(\"go\", 3)] @=? wordCount \"go Go GO\"\n  , testCase \"prefix punctuation\" $\n    fromList [(\"testing\", 2), (\"1\", 1), (\"2\", 1)] @=?\n    wordCount \"!%%#testing, 1, 2 testing\"\n  , testCase \"symbols are separators\" $\n    fromList [(\"hey\", 1), (\"my\", 1), (\"spacebar\", 1),\n              (\"is\", 1), (\"broken\", 1)] @=?\n    wordCount \"hey,my_spacebar_is_broken.\"\n  ]\n\nmain :: IO ()\nmain = exitProperly (runTestTT (TestList wordCountTests))\n",
        "README.md": "# Word Count\n\nWrite a program that given a phrase can count the occurrences of each word in that phrase.\n\nFor example for the input `\"olly olly in come free\"`\n\n```plain\nolly: 2\nin: 1\ncome: 1\nfree: 1\n```\n\n\nCheck out [Exercism\nHelp](http://help.exercism.io/getting-started-with-haskell.html) for\ninstructions to get started writing Haskell.\n\n## Running Tests\n\nUse `runhaskell` (included in the Haskell Platform) to compile and run your\nHaskell code.\n\n    $ runhaskell -Wall bob_test.hs\n\n## Source\n\nThe golang tour [view source](http://tour.golang.org)\n",
        "WordCount.hs": "// iteration 1"
      },
      "fresh": false
    }
  ]
}
