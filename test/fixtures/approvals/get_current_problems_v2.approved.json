{
  "problems": [
    {
      "id": "clojure/bob",
      "track_id": "clojure",
      "language": "clojure",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "bob_test.clj": "(ns bob.test (:require [clojure.test :refer :all]))\n(load-file \"bob.clj\")\n\n(deftest responds-to-something\n  (is (= \"Whatever.\" (bob/response-for \"Tom-ay-to, tom-aaaah-to.\"))))\n\n(deftest responds-to-shouts\n  (is (= \"Whoa, chill out!\" (bob/response-for \"WATCH OUT!\"))))\n\n(deftest responds-to-questions\n  (is (= \"Sure.\" (bob/response-for \"Does this cryogenic chamber make me look fat?\"))))\n\n(deftest responds-to-forceful-talking\n  (is (= \"Whatever.\" (bob/response-for \"Let's go make out behind the gym!\"))))\n\n(deftest responds-to-acronyms\n  (is (= \"Whatever.\" (bob/response-for \"It's OK if you don't want to go to the DMV.\"))))\n\n(deftest responds-to-forceful-questions\n  (is (= \"Whoa, chill out!\" (bob/response-for \"WHAT THE HELL WERE YOU THINKING?\"))))\n\n(deftest responds-to-shouting-with-special-characters\n  (is (= \"Whoa, chill out!\" (bob/response-for \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\"))))\n\n(deftest responds-to-shouting-numbers\n  (is (= \"Whoa, chill out!\" (bob/response-for \"1, 2, 3 GO!\"))))\n\n(deftest responds-to-shouting-with-no-exclamation-mark\n  (is (= \"Whoa, chill out!\" (bob/response-for \"I HATE YOU\"))))\n\n(deftest responds-to-statement-containing-question-mark\n  (is (= \"Whatever.\" (bob/response-for \"Ending with ? means a question.\"))))\n\n(deftest responds-to-silence\n  (is (= \"Fine. Be that way!\" (bob/response-for \"\"))))\n\n(deftest responds-to-prolonged-silence\n  (is (= \"Fine. Be that way!\" (bob/response-for \"    \"))))\n\n(deftest responds-to-only-numbers\n  (is (= \"Whatever.\" (bob/response-for \"1, 2, 3\"))))\n\n(deftest responds-to-number-question\n  (is (= \"Sure.\" (bob/response-for \"4?\"))))\n\n(run-tests)\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true
    },
    {
      "id": "coffeescript/bob",
      "track_id": "coffeescript",
      "language": "coffeescript",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "bob_test.spec.coffee": "Bob = require \"./bob\"\ndescribe \"Bob\", ->\n  bob = new Bob()\n  it \"stating something\", ->\n    result = bob.hey \"Tom-ay-to, tom-aaaah-to.\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"shouting\", ->\n    result = bob.hey \"WATCH OUT!\"\n    expect(result).toEqual \"Whoa, chill out!\"\n\n  xit \"asking a question\", ->\n    result = bob.hey \"Does this cryogenic chamber make me look fat?\"\n    expect(result).toEqual \"Sure.\"\n\n  xit \"talking forcefully\", ->\n    result = bob.hey \"Let's go make out behind the gym!\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"using acronyms in regular speech\", ->\n    result = bob.hey \"It's OK if you don't want to go to the DMV.\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"forceful questions\", ->\n    result = bob.hey \"WHAT THE HELL WERE YOU THINKING?\"\n    expect(result).toEqual \"Whoa, chill out!\"\n\n  xit \"shouting numbers\", ->\n    result = bob.hey \"1, 2, 3 GO!\"\n    expect(result).toEqual \"Whoa, chill out!\"\n\n  xit \"only number\", ->\n    result = bob.hey \"1, 2, 3\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"shouting with special characters\", ->\n    result = bob.hey \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\"\n    expect(result).toEqual \"Whoa, chill out!\"\n\n  xit \"shouting with no exclamation mark\", ->\n    result = bob.hey \"I HATE YOU\"\n    expect(result).toEqual \"Whoa, chill out!\"\n\n  xit \"statement containing question mark\", ->\n    result = bob.hey \"Ending with a ? means a question.\"\n    expect(result).toEqual \"Whatever.\"\n\n  xit \"prattling on\", ->\n    result = bob.hey \"Wait! Hang on.  Are you going to be OK?\"\n    expect(result).toEqual \"Sure.\"\n\n  xit \"silence\", ->\n    result = bob.hey \"\"\n    expect(result).toEqual \"Fine. Be that way!\"\n\n  xit \"prolonged silence\", ->\n    result = bob.hey \"   \"\n    expect(result).toEqual \"Fine. Be that way!\"\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true
    },
    {
      "id": "cpp/bob",
      "track_id": "cpp",
      "language": "cpp",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "CMakeLists.txt": "# Get the exercise name from the current directory\nget_filename_component(exercise ${CMAKE_CURRENT_SOURCE_DIR} NAME)\n# Basic CMake project\ncmake_minimum_required(VERSION 2.8.11)\n# Name the project after the exercise\nproject(${exercise} CXX)\n\n# Locate Boost libraries: unit_test_framework, date_time and regex\nset(Boost_USE_STATIC_LIBS ON)\nset(Boost_USE_MULTITHREADED ON)\nset(Boost_USE_STATIC_RUNTIME OFF)\nfind_package(Boost 1.55 REQUIRED COMPONENTS unit_test_framework date_time regex)\n\n# gcc/clang won't enable C++11 features without this flag\nif(\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(GNU|Clang)\")\n    set(CMAKE_CXX_FLAGS \"-std=c++11\")\nendif()\n\n# Configure to run all the tests?\nif(${EXERCISM_RUN_ALL_TESTS})\n    add_definitions(-DEXERCISM_RUN_ALL_TESTS)\nendif()\n\n# Make an executable that runs the exercism unit tests against the implementation\nfunction(exercism)\n    # Replace -'s with _'s to get a filename from the exercise name\n    string(REPLACE \"-\" \"_\" file ${exercise})\n    # Implementation could be only a header\n    if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${file}.cpp)\n        set(exercise_cpp ${file}.cpp)\n    else()\n        set(exercise_cpp \"\")\n    endif()\n    # Build executable from sources and headers\n    add_executable(${exercise} ${file}_test.cpp ${exercise_cpp} ${file}.h)\n    # We need boost includes\n    target_include_directories(${exercise} PRIVATE ${Boost_INCLUDE_DIRS})\n    # We need boost libraries\n    target_link_libraries(${exercise} ${Boost_LIBRARIES})\n    # Run the tests on every build\n    add_custom_command(TARGET ${exercise} POST_BUILD COMMAND ${exercise})\nendfunction()\n\nexercism()\n",
        "bob_test.cpp": "#include \"bob.h\"\n#define BOOST_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n\nBOOST_AUTO_TEST_CASE(stating_something)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"Tom-ay-to, tom-aaaah-to.\"));\n}\n\n#if defined(EXERCISM_RUN_ALL_TESTS)\nBOOST_AUTO_TEST_CASE(shouting)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"WATCH OUT!\"));\n}\n\nBOOST_AUTO_TEST_CASE(asking_a_question)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"Does this cryogenic chamber make me look fat?\"));\n}\n\nBOOST_AUTO_TEST_CASE(talking_forcefully)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"Let's go make out behind the gym!\"));\n}\n\nBOOST_AUTO_TEST_CASE(using_acronyms_in_regular_speech)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"It's OK if you don't want to go to the DMV.\"));\n}\n\nBOOST_AUTO_TEST_CASE(forceful_questions)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"WHAT THE HELL WERE YOU THINKING?\"));\n}\n\nBOOST_AUTO_TEST_CASE(shouting_numbers)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"1, 2, 3 GO!\"));\n}\n\nBOOST_AUTO_TEST_CASE(only_numbers)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"1, 2, 3\"));\n}\n\nBOOST_AUTO_TEST_CASE(question_with_only_numbers)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"4?\"));\n}\n\nBOOST_AUTO_TEST_CASE(shouting_with_special_characters)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\"));\n}\n\nBOOST_AUTO_TEST_CASE(shouting_with_no_exclamation_mark)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"I HATE YOU\"));\n}\n\nBOOST_AUTO_TEST_CASE(statement_containing_question_mark)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"Ending with a ? means a question.\"));\n}\n\nBOOST_AUTO_TEST_CASE(prattling_on)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"Wait! Hang on.  Are you going to be OK?\"));\n}\n\nBOOST_AUTO_TEST_CASE(silence)\n{\n    BOOST_REQUIRE_EQUAL(\"Fine. Be that way!\", bob::hey(\"\"));\n}\n\nBOOST_AUTO_TEST_CASE(prolonged_silence)\n{\n    BOOST_REQUIRE_EQUAL(\"Fine. Be that way!\", bob::hey(\"   \"));\n}\n#endif\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n## Passing the Tests\n\nGet the first test compiling, linking and passing.  Once you've done that,\nuncomment the next test by moving the following line past the next test.\n\n```C++\n#if defined(EXERCISM_RUN_ALL_TESTS)\n```\n\nThis may result in compile errors as new constructs may be invoked that\nyou haven't yet declared or defined.  Fix the compile errors minimally\nto get a failing test, then change the code minimally to pass the test,\nrefactor your implementation for readability and expressiveness and then\ngo on to the next test.\n\nTry to use standard C++11 facilities in preference to writing your own\nlow-level algorithms or facilities by hand.  [CppReference](http://en.cppreference.com/)\nis a wiki reference to the C++ language and standard library.  If you\nare new to C++, but have programmed in C, beware of\n[C traps and pitfalls](http://www.slideshare.net/LegalizeAdulthood/c-traps-and-pitfalls-for-c-programmers).\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true
    },
    {
      "id": "csharp/leap",
      "track_id": "csharp",
      "language": "csharp",
      "slug": "leap",
      "name": "Leap",
      "files": {
        "LeapTest.cs": "using NUnit.Framework;\n\n[TestFixture]\npublic class LeapTest\n{\n    [Test]\n    public void Valid_leap_year()\n    {\n        Assert.That(Year.IsLeap(1996), Is.True);\n    }\n\n    [Ignore]\n    [Test]\n    public void Invalid_leap_year()\n    {\n        Assert.That(Year.IsLeap(1997), Is.False);\n    }\n\n    [Ignore]\n    [Test]\n    public void Turn_of_the_20th_century_is_not_a_leap_year()\n    {\n        Assert.That(Year.IsLeap(1900), Is.False);\n    }\n\n    [Ignore]\n    [Test]\n    public void Turn_of_the_25th_century_is_a_leap_year()\n    {\n        Assert.That(Year.IsLeap(2400), Is.True);\n    }\n}",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": true
    },
    {
      "id": "elixir/bob",
      "track_id": "elixir",
      "language": "elixir",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "bob.exs": "defmodule Teenager do\n  def hey(input) do\n    cond do\n\n    end\n  end\nend\n",
        "bob_test.exs": "if System.get_env(\"EXERCISM_TEST_EXAMPLES\") do\n  Code.load_file(\"example.exs\")\nelse\n  Code.load_file(\"bob.exs\")\nend\n\nExUnit.start\n\ndefmodule TeenagerTest do\n  use ExUnit.Case, async: true\n\n  test \"stating something\" do\n    assert Teenager.hey(\"Tom-ay-to, tom-aaaah-to.\") == \"Whatever.\"\n  end\n\n  test \"shouting\" do\n    # assert Teenager.hey(\"WATCH OUT!\") == \"Whoa, chill out!\"\n  end\n\n  test \"asking a question\" do\n    # assert Teenager.hey(\"Does this cryogenic chamber make me look fat?\") == \"Sure.\"\n  end\n\n  test \"talking forcefully\" do\n    # assert Teenager.hey(\"Let's go make out behind the gym!\") == \"Whatever.\"\n  end\n\n  test \"talking in capitals\" do\n    # assert Teenager.hey(\"This Isn't Shouting!\") == \"Whatever.\"\n  end\n\n  test \"shouting numbers\" do\n    # assert Teenager.hey(\"1, 2, 3 GO!\") == \"Whoa, chill out!\"\n  end\n\n  test \"shouting with special characters\" do\n    # assert Teenager.hey(\"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\") == \"Whoa, chill out!\"\n  end\n\n  test \"shouting with no exclamation mark\" do\n    # assert Teenager.hey(\"I HATE YOU\") == \"Whoa, chill out!\"\n  end\n\n  test \"statement containing question mark\" do\n    # assert Teenager.hey(\"Ending with ? means a question.\") == \"Whatever.\"\n  end\n\n  test \"silence\" do\n    # assert Teenager.hey(\"\") == \"Fine. Be that way!\"\n  end\n\n  test \"prolonged silence\" do\n    # assert Teenager.hey(\"  \") == \"Fine. Be that way!\"\n  end\n\n  test \"only numbers\" do\n    # assert Teenager.hey(\"1, 2, 3\") == \"Whatever.\"\n  end\n\n  test \"question with numbers\" do\n    # assert Teenager.hey(\"4?\") == \"Sure.\"\n  end\n\n  test \"shouting in Russian\" do\n    # Hopefully this is Russian for \"get out\"\n    # assert Teenager.hey(\"УХОДИТЬ\") == \"Whoa, chill out!\"\n  end\nend\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true
    },
    {
      "id": "erlang/leap",
      "track_id": "erlang",
      "language": "erlang",
      "slug": "leap",
      "name": "Leap",
      "files": {
        "leap_tests.erl": "% To run tests:\n% erl -make\n% erl -noshell -eval \"eunit:test(leap, [verbose])\" -s init stop\n%\n\n-module(leap_tests).\n\n-include_lib(\"eunit/include/eunit.hrl\").\n\nleap_year_test() ->\n    ?assert(leap:leap_year(1996)).\n\nnon_leap_year_test() ->\n    ?assertNot(leap:leap_year(1997)).\n\ncentury_test() ->\n    ?assertNot(leap:leap_year(1900)).\n\nfourth_century_test() ->\n    ?assert(leap:leap_year(2400)).\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": true
    },
    {
      "id": "fsharp/sum-of-multiples",
      "track_id": "fsharp",
      "language": "fsharp",
      "slug": "sum-of-multiples",
      "name": "Sum Of Multiples",
      "files": {
        "SumOfMultiplesTest.fs": "﻿module SumOfMultiplesTest\n\nopen NUnit.Framework\nopen SumOfMultiples\n\n[<TestFixture>]\ntype SumOfMultiplesTest() =\n    let mutable sumOfMultiples = SumOfMultiples()\n    \n    [<Test>]\n    member tc.Sum_to_1() = \n        Assert.That(sumOfMultiples.To(0), Is.EqualTo(0))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Sum_to_3() = \n        Assert.That(sumOfMultiples.To(3), Is.EqualTo(0))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Sum_to_10() = \n        Assert.That(sumOfMultiples.To(10), Is.EqualTo(23))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Configurable_7_13_17_to_20() = \n        Assert.That(SumOfMultiples([7; 13; 17]).To(20), Is.EqualTo(51))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Configurable_43_47_to_10000() = \n        Assert.That(SumOfMultiples([43; 47]).To(10000), Is.EqualTo(2203160))",
        "README.md": "# Sum Of Multiples\n\nWrite a program that, given a number, can find the sum of all the multiples of 3 or 5 up to but not including that number.\n\nIf we list all the natural numbers below 10 that are multiples of 3 or\n5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nAllow the program to be configured to find the sum of multiples of\nnumbers other than 3 and 5.\n\n\n## Source\n\nA variation on Problem 1 at Project Euler [view source](http://projecteuler.net/problem=1)\n"
      },
      "fresh": true
    },
    {
      "id": "go/clock",
      "track_id": "go",
      "language": "go",
      "slug": "clock",
      "name": "Clock",
      "files": {
        "clock_test.go": "package clock\n\nimport \"testing\"\n\nvar newTests = []struct {\n\th, m int\n\tdisp string\n}{\n\t{8, 0, \"08:00\"},\n\t{9, 0, \"09:00\"},\n\t{11, 9, \"11:09\"},\n}\n\nvar addTests = []struct {\n\th, m, a int\n\tdisp    string\n}{\n\t{10, 0, 3, \"10:03\"},   // simple\n\t{10, 0, 61, \"11:01\"},  // add > 1 hour\n\t{23, 30, 60, \"00:30\"}, // add across midnight\n\t{10, 0, -90, \"08:30\"}, // subtract > 1 hour\n\t{0, 30, -60, \"23:30\"}, // subtract across midnight\n\n\t{0, 45, 40, \"01:25\"},   // hour carry\n\t{1, 25, -40, \"00:45\"},  // hour borrow\n\t{23, 45, 40, \"00:25\"},  // carry across midnight\n\t{0, 25, -40, \"23:45\"},  // borrow across midnight\n\t{0, 0, 160, \"02:40\"},   // add > 2 hrs\n\t{0, 45, 160, \"03:25\"},  // add > 2 hrs with carry\n\t{0, 0, -160, \"21:20\"},  // subtract > 2 hrs\n\t{6, 15, -160, \"03:35\"}, // subtract > 2 hrs with borrow\n\n\t{0, 160, 0, \"02:40\"},  // initial minutes roll over\n\t{25, 0, 0, \"01:00\"},   // initial hour rolls over\n\t{25, 160, 0, \"03:40\"}, // both rollover\n\t{0, -160, 0, \"21:20\"}, // same cases, negative\n\t{-25, 0, 0, \"23:00\"},\n\t{-25, -160, 0, \"20:20\"},\n}\n\nfunc TestClock(t *testing.T) {\n\tfor _, n := range newTests {\n\t\tif c := New(n.h, n.m); c.String() != n.disp {\n\t\t\tt.Fatalf(\"New(%d, %d) = %q, want %q\", n.h, n.m, c, n.disp)\n\t\t}\n\t}\n\tfor _, a := range addTests {\n\t\tif c := New(a.h, a.m).Add(a.a); c.String() != a.disp {\n\t\t\tt.Fatalf(\"New(%d, %d).Add(%d) = %q, want %q\", a.h, a.m, a.a, c, a.disp)\n\t\t}\n\t}\n\tclock0 := New(15, 37)\n\tclock1 := New(15, 37)\n\tclock2 := New(15, 36)\n\tclock3 := New(14, 37)\n\tif clock0 != clock1 {\n\t\tt.Fatal(clock0, \"!=\", clock1, \"want ==\")\n\t}\n\tif clock2 == clock1 {\n\t\tt.Fatal(clock2, \"==\", clock1, \"want !=\")\n\t}\n\tif clock3 == clock1 {\n\t\tt.Fatal(clock3, \"==\", clock1, \"want !=\")\n\t}\n}\n",
        "README.md": "# Clock\n\nImplement a clock that handles times without dates.\n\nCreate a clock that is independent of date.\n\nYou should be able to add and subtract minutes to it.\n\nTwo clocks that represent the same time should be equal to each other.\n\n\n## Source\n\nPairing session with Erin Drummond [view source](https://twitter.com/ebdrummond)\n"
      },
      "fresh": true
    },
    {
      "id": "haskell/leap",
      "track_id": "haskell",
      "language": "haskell",
      "slug": "leap",
      "name": "Leap",
      "files": {
        "leap_test.hs": "import Test.HUnit (Assertion, (@=?), runTestTT, Test(..), Counts(..))\nimport System.Exit (ExitCode(..), exitWith)\nimport LeapYear (isLeapYear)\n\nexitProperly :: IO Counts -> IO ()\nexitProperly m = do\n  counts <- m\n  exitWith $ if failures counts /= 0 || errors counts /= 0 then ExitFailure 1 else ExitSuccess\n\ntestCase :: String -> Assertion -> Test\ntestCase label assertion = TestLabel label (TestCase assertion)\n\nmain :: IO ()\nmain = exitProperly $ runTestTT $ TestList\n       [ TestList isLeapYearTests ]\n\nisLeapYearTests :: [Test]\nisLeapYearTests =\n  [ testCase \"vanilla leap year\" $\n    True @=? isLeapYear 1996\n  , testCase \"any old year\" $\n    False @=? isLeapYear 1997\n  , testCase \"century\" $\n    False @=? isLeapYear 1900\n  , testCase \"exceptional century\" $\n    True @=? isLeapYear 2400\n  ]\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": true
    },
    {
      "id": "javascript/bob",
      "track_id": "javascript",
      "language": "javascript",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "bob.js": "//\n// This is only a SKELETON file for the \"Bob\" exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nvar Bob = function() {};\n\nBob.prototype.hey = function(input) {\n//\n// YOUR CODE GOES HERE\n//\n};\n\nmodule.exports = Bob;\n",
        "bob_test.spec.js": "var Bob = require('./bob.js');\n\ndescribe(\"Bob\", function() {\n  var bob = new Bob();\n\n  it(\"stating something\", function() {\n    var result = bob.hey('Tom-ay-to, tom-aaaah-to.');\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"shouting\", function() {\n    var result = bob.hey('WATCH OUT!');\n    expect(result).toEqual('Whoa, chill out!');\n  });\n\n  xit(\"asking a question\", function() {\n    var result = bob.hey('Does this cryogenic chamber make me look fat?');\n    expect(result).toEqual('Sure.');\n  });\n\n  xit(\"talking forcefully\", function() {\n    var result = bob.hey(\"Let's go make out behind the gym!\");\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"using acronyms in regular speech\", function() {\n    var result = bob.hey(\"It's OK if you don't want to go to the DMV.\");\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"forceful questions\", function() {\n    var result = bob.hey('WHAT THE HELL WERE YOU THINKING?');\n    expect(result).toEqual('Whoa, chill out!');\n  });\n\n  xit(\"shouting numbers\", function() {\n    var result = bob.hey('1, 2, 3 GO!');\n    expect(result).toEqual('Whoa, chill out!');\n  });\n\n  xit(\"only numbers\", function() {\n    var result = bob.hey('1, 2, 3');\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"question with only numbers\", function() {\n    var result = bob.hey('4?');\n    expect(result).toEqual('Sure.');\n  });\n\n  xit(\"shouting with special characters\", function() {\n    var result = bob.hey('ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!');\n    expect(result).toEqual('Whoa, chill out!');\n  });\n\n  xit(\"shouting with umlauts\", function() {\n    var result = bob.hey(\"\\xdcML\\xc4\\xdcTS!\");\n    expect(result).toEqual('Whoa, chill out!');\n  });\n\n  xit(\"calmly speaking about umlauts\", function() {\n    var result = bob.hey(\"\\xfcML\\xe4\\xdcTS\");\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"shouting with no exclamation mark\", function () {\n    var result = bob.hey('I HATE YOU');\n    expect(result).toEqual('Whoa, chill out!');\n  });\n\n  xit(\"statement containing question mark\", function() {\n    var result = bob.hey('Ending with a ? means a question.');\n    expect(result).toEqual('Whatever.');\n  });\n\n  xit(\"prattling on\", function () {\n    var result = bob.hey('Wait! Hang on.  Are you going to be OK?');\n    expect(result).toEqual('Sure.');\n  });\n\n  xit(\"silence\", function () {\n    var result = bob.hey('');\n    expect(result).toEqual('Fine. Be that way!');\n  });\n\n   xit(\"prolonged silence\", function () {\n    var result = bob.hey('   ');\n    expect(result).toEqual('Fine. Be that way!');\n  });\n});\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n## Making the Test Suite Pass\n\nExecute the tests with:\n\n```bash\n$ jasmine-node bob_test.spec.js\n```\n\nAll but the first test have been skipped.\n\nOnce you get a test passing, you can unskip the next one by\nchanging `xit` to `it`.\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true
    },
    {
      "id": "lua/hamming",
      "track_id": "lua",
      "language": "lua",
      "slug": "hamming",
      "name": "Hamming",
      "files": {
        "hamming_test.lua": "local compute = require('./hamming').compute\n\ndescribe('Hamming', function () \n\n  it('no difference between identical strands', function () \n     assert.are.equals(compute('A', 'A'),0)\n  end)\n\n  it('complete hamming distance of for single nucleotide strand', function () \n     assert.are.equals(compute('A','G'),1)\n  end)\n\n  it('complete hamming distance of for small strand', function ()\n     assert.are.equals(compute('AG','CT'),2)\n  end)\n\n  it('small hamming distance', function ()\n     assert.are.equals(compute('AT','CT'),1)\n  end)\n\n  it('small hamming distance in longer strand', function ()\n     assert.are.equals(compute('GGACG', 'GGTCG'),1)\n  end)\n\n  it('ignores extra length on first strand when longer', function ()\n     assert.are.equals(compute('AAAG', 'AAA'),0)\n  end)\n\n  it('ignores extra length on other strand when longer', function ()\n     assert.are.equals(compute('AAA', 'AAAG'),0)\n  end)\n\n  it('large hamming distance', function ()\n     assert.are.equals(compute('GATACA', 'GCATAA'),4)\n  end)\n\n  it('hamming distance in very long strand', function ()\n     assert.are.equals(compute('GGACGGATTCTG', 'AGGACGGATTCT'),9)\n  end)\n\nend)\n\n",
        "README.md": "# Hamming\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n### Getting started\nFirst install lua using [homebrew][1]\n\n    $ brew install lua\n\nThen install [luarocks][2] to install packages for lua\n\n    $ brew install luarocks\n\nThen install [busted][3] testing framework for lua\n\n    $ luarocks install busted\n    \nThen run your test\n\n    $ busted bob_test.lua \n    \nOther resources\n\n  1. [Lua Style Guide][4]\n  2. [Learn Lua in 15 minutes][5] \n\n[1]: http://brew.sh/\n[2]: http://luarocks.org/\n[3]: http://olivinelabs.com/busted/\n[4]: https://github.com/Olivine-Labs/lua-style-guide\n[5]: http://tylerneylon.com/a/learn-lua/\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
      },
      "fresh": true
    },
    {
      "id": "objective-c/bob",
      "track_id": "objective-c",
      "language": "objective-c",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "BobTest.m": "#import <XCTest/XCTest.h>\n#import \"Bob.h\"\n\n@interface test_suite : XCTestCase\n\n@end\n\n@implementation test_suite\n\n- (Bob *)bob {\n  return [[Bob alloc] init];\n}\n\n- (void)testStatingSomething {\n  NSString *input = @\"Tom-ay-to, tom-aaaah-to.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShouting {\n  NSString *input = @\"WATCH OUT!\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testAskingAQuestion {\n  NSString *input = @\"Does this cryogenic chamber make me look fat?\";\n  NSString *expected = @\"Sure.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testTalkingForcefully {\n  NSString *input = @\"Let's go make out behind the gym!\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testUsingAcronyms {\n  NSString *input = @\"It's OK if you don't want to go to the DMV.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testForcefulQuestions {\n  NSString *input = @\"WHAT THE HELL WERE YOU THINKING?\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShoutingNumbers {\n  NSString *input = @\"1, 2, 3 GO!\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testOnlyNumbers {\n  NSString *input = @\"1, 2, 3.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n- (void)testQuestionWithOnlyNumbers {\n  NSString *input = @\"4?\";\n  NSString *expected = @\"Sure.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShoutingWithSpecialCharacters {\n  NSString *input = @\"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShoutingWithUmlautsCharacters {\n  NSString *input = @\"ÄMLÄTS!\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testCalmlySpeakingAboutUmlauts {\n  NSString *input = @\"ÄMLäTS!\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testShoutingWithNoExclamationMark {\n  NSString *input = @\"I HATE YOU\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testStatementContainingQuestionsMark {\n  NSString *input = @\"Ending with a ? means a question.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testPrattlingOn {\n  NSString *input = @\"Wait! Hang on.  Are you going to be OK?\";\n  NSString *expected = @\"Sure.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testSilence {\n  NSString *input = @\"\";\n  NSString *expected = @\"Fine, be that way.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n- (void)testProlongedSilence {\n  NSString *input = @\"     \";\n  NSString *expected = @\"Fine, be that way.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result, @\"\");\n}\n\n@end\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true
    },
    {
      "id": "ocaml/bob",
      "track_id": "ocaml",
      "language": "ocaml",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "Makefile": "test: test.native\n\t@./test.native\n\ntest.native: *.ml *.mli\n\t@corebuild -quiet test.native\n\nclean:\n\trm -rf _build\n\n.PHONY: clean\n",
        "bob.mli": "(*\nAnswers to `hey` like a teenager.\n\n## Examples\n\n  # response_for \"\"\n  \"Fine. Be that way!\"\n\n  # response_for \"Do you like math?\"\n  \"Sure.\"\n\n  # response_for \"HELLO!\"\n  \"Woah, chill out!\"\n\n  # response_for \"Coding is cool.\"\n  \"Whatever.\"\n*)\nval response_for : string -> string\n",
        "test.ml": "open Core.Std\nopen OUnit2\nopen Bob\n\nlet ae exp got _test_ctxt = assert_equal ~printer:String.to_string exp got\n\nlet tests =\n  [\"something\">::\n     ae \"Whatever.\" (response_for \"Tom-ay-to, tom-aaaah-to.\");\n   \"shouts\">::\n     ae \"Whoa, chill out!\" (response_for \"WATCH OUT!\");\n   \"questions\">::\n     ae \"Sure.\" (response_for \"Does this cryogenic chamber make me look fat?\");\n   \"forceful talking\">::\n     ae \"Whatever.\" (response_for \"Let's go make out behind the gym!\");\n   \"acronyms\">::\n     ae \"Whatever.\" (response_for \"It's ok if you don't want to go to the DMV.\");\n   \"forceful questions\">::\n     ae \"Whoa, chill out!\" (response_for \"WHAT THE HELL WERE YOU THINKING?\");\n   \"shouting with special characters\">::\n     ae \"Whoa, chill out!\"\n       (response_for \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\");\n   \"shouting numbers\">::\n     ae \"Whoa, chill out!\" (response_for \"1, 2, 3, GO!\");\n   \"statement containing question mark\">::\n     ae \"Whatever.\" (response_for \"Ending with ? means a question.\");\n   \"silence\">::\n     ae \"Fine. Be that way!\" (response_for \"\");\n   \"prolonged silence\">::\n     ae \"Fine. Be that way!\" (response_for \"   \");\n   \"non-letters with question\">::\n     ae \"Sure.\" (response_for \":) ?\");\n   \"multiple line questons\">::\n     ae \"Whatever.\"\n       (response_for \"\\nDoes this cryogenic chamber make me look fat? \\nno\");\n   \"other whitespace\">::\n     (* No unicode whitespace as OCaml Core doesn't seem to handle Unicode.\n      * Not it seems does it see ASCII 11 (\\v) as whitespace.\n     *)\n     ae \"Fine. Be that way!\" (response_for \"\\n\\r \\t\");\n   \"only numbers\">::\n     ae \"Whatever.\" (response_for \"1, 2, 3\");\n   \"question with only numbers\">::\n     ae \"Sure.\" (response_for \"4?\");\n  ]\n\nlet () =\n  run_test_tt_main (\"bob tests\" >::: tests)\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true
    },
    {
      "id": "perl5/bob",
      "track_id": "perl5",
      "language": "perl5",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "bob.pm": "#\n# This is a SKELETON file and has been provided to enable you to get working on the\n# first exercise more quickly.\n#\n\npackage Bob;\n\nuse strict;\nuse Exporter;\nuse vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);\n\n$VERSION = 1.00;\n@ISA = qw(Exporter);\n@EXPORT = ();\n@EXPORT_OK = qw(hey);\n%EXPORT_TAGS = ( DEFAULT => [qw(&hey)],\n);\n\nsub hey {\n#\n# YOUR CODE GOES HERE\n#\n}\n\n1;\n",
        "bob.t": "use strict;\nuse warnings;\nuse open ':std', ':encoding(utf8)';\nuse utf8;\n\nmy $module = $ENV{EXERCISM} ? 'Example' : 'Bob';\n\nuse Test::More;\n\nmy @cases = (\n    # input                                           expected output        title\n    ['Tom-ay-to, tom-aaaah-to.',                       'Whatever.',          'stating something'],\n    ['WATCH OUT!',                                     'Whoa, chill out!',   'shouting'],\n    ['Does this cryogenic chamber make me look fat?',  'Sure.',              'question'],\n    ['You are, what, like 15?',                        'Sure.',              'numeric question'],\n    [\"Let's go make out behind the gym!\",              'Whatever.',          'talking forcefully'],\n    [\"It's OK if you don't want to go to the DMV.\",    'Whatever.',          'using acronyms in regular speech'],\n    ['WHAT THE HELL WERE YOU THINKING?',               'Whoa, chill out!',   'forceful questions'],\n    ['1, 2, 3 GO!',                                    'Whoa, chill out!',   'shouting numbers'],\n    ['1, 2, 3',                                        'Whatever.',          'only numbers'],\n    ['4?',                                             'Sure.',              'question with only numbers'],\n    ['ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!',  'Whoa, chill out!',   'shouting with special characters'],\n    [\"ÜMLÄÜTS!\",                                       'Whoa, chill out!',   'shouting with umlauts'],\n    [\"\\xdcML\\xc4\\xdcTS!\",                              'Whoa, chill out!',   'shouting with umlauts'],\n    [\"ÜMLäÜTS!\",                                       'Whatever.',          'speaking calmly with umlauts'],\n    #[\"\\xdcML\\xe4\\xdcTS!\",                              'Whatever.',          'speaking calmly with umlauts'],\n    ['I HATE YOU',                                     'Whoa, chill out!',   'shouting with no exclamation mark'],\n    ['Ending with ? means a question.',                'Whatever.',          'statement containing question mark'],\n    [\"Wait! Hang on. Are you going to be OK?\",         'Sure.',              'prattling on'],\n    ['',                                               'Fine. Be that way!', 'silence'],\n    ['    ',                                           'Fine. Be that way!', 'prolonged silence'],\n);\n\n\nplan tests => 3 + @cases;\n\nok -e \"$module.pm\", \"missing $module.pm\"\n    or BAIL_OUT(\"You need to create a module called $module.pm with a function called hey() that gets one parameter: The text Bob hears.\");\n\neval \"use $module\";\nok !$@, \"Cannot load $module.pm\"\n    or BAIL_OUT(\"Does $module.pm compile?  Does it end with 1; ?\");\n\ncan_ok($module, 'hey') or BAIL_OUT(\"Missing package $module; or missing sub hey()\");\n\nmy $sub = $module . '::hey';\n\nforeach my $c (@cases) {\n    #diag uc $c->[0];\n    my $title = $c->[2] ? \"$c->[2]: $c->[0]\" : $c->[0];\n    no strict 'refs';\n    is $sub->($c->[0]), $c->[1], $title;\n}\n\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true
    },
    {
      "id": "python/bob",
      "track_id": "python",
      "language": "python",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "bob_test.py": "# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\nimport unittest\n\nimport bob\n\n\nclass BobTests(unittest.TestCase):\n\n    def test_stating_something(self):\n        self.assertEqual(\n            'Whatever.',\n            bob.hey('Tom-ay-to, tom-aaaah-to.')\n        )\n\n    def test_shouting(self):\n        self.assertEqual(\n            'Whoa, chill out!',\n            bob.hey('WATCH OUT!')\n        )\n\n    def test_asking_a_question(self):\n        self.assertEqual(\n            'Sure.',\n            bob.hey('Does this cryogenic chamber make me look fat?')\n        )\n\n    def test_asking_a_numeric_question(self):\n        self.assertEqual(\n            'Sure.',\n            bob.hey('You are, what, like 15?')\n        )\n\n    def test_talking_forcefully(self):\n        self.assertEqual(\n            'Whatever.',\n            bob.hey(\"Let's go make out behind the gym!\")\n        )\n\n    def test_using_acronyms_in_regular_speech(self):\n        self.assertEqual(\n            'Whatever.', bob.hey(\"It's OK if you don't want to go to the DMV.\")\n        )\n\n    def test_forceful_questions(self):\n        self.assertEqual(\n            'Whoa, chill out!', bob.hey('WHAT THE HELL WERE YOU THINKING?')\n        )\n\n    def test_shouting_numbers(self):\n        self.assertEqual(\n            'Whoa, chill out!', bob.hey('1, 2, 3 GO!')\n        )\n\n    def test_only_numbers(self):\n        self.assertEqual(\n            'Whatever.', bob.hey('1, 2, 3')\n        )\n\n    def test_question_with_only_numbers(self):\n        self.assertEqual(\n            'Sure.', bob.hey('4?')\n        )\n\n    def test_shouting_with_special_characters(self):\n        self.assertEqual(\n            'Whoa, chill out!',\n            bob.hey('ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!')\n        )\n\n    def test_shouting_with_umlauts(self):\n        self.assertEqual(\n            'Whoa, chill out!', bob.hey('ÜMLÄÜTS!')\n        )\n\n    def test_calmly_speaking_with_umlauts(self):\n        self.assertEqual(\n            'Whatever.', bob.hey('ÜMLäÜTS!')\n        )\n\n    def test_shouting_with_no_exclamation_mark(self):\n        self.assertEqual(\n            'Whoa, chill out!', bob.hey('I HATE YOU')\n        )\n\n    def test_statement_containing_question_mark(self):\n        self.assertEqual(\n            'Whatever.', bob.hey('Ending with ? means a question.')\n        )\n\n    def test_prattling_on(self):\n        self.assertEqual(\n            'Sure.', bob.hey(\"Wait! Hang on. Are you going to be OK?\")\n        )\n\n    def test_silence(self):\n        self.assertEqual(\n            'Fine. Be that way!', bob.hey('')\n        )\n\n    def test_prolonged_silence(self):\n        self.assertEqual(\n            'Fine. Be that way!', bob.hey('    \\t')\n        )\n        \n    def test_starts_with_whitespace(self):\n        self.assertEqual(\n            'Whatever.', bob.hey('         hmmmmmmm...')\n        )\n\nif __name__ == '__main__':\n    unittest.main()\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true
    },
    {
      "id": "ruby/anagram",
      "track_id": "ruby",
      "language": "ruby",
      "slug": "anagram",
      "name": "Anagram",
      "files": {
        "anagram_test.rb": "require 'minitest/autorun'\nrequire_relative 'anagram'\n\nclass AnagramTest < MiniTest::Unit::TestCase\n\n  def test_no_matches\n    detector = Anagram.new('diaper')\n    assert_equal [], detector.match(%w(hello world zombies pants))\n  end\n\n  def test_detect_simple_anagram\n    skip\n    detector = Anagram.new('ant')\n    anagrams = detector.match(['tan', 'stand', 'at'])\n    assert_equal ['tan'], anagrams\n  end\n\n  def test_detect_multiple_anagrams\n    skip\n    detector = Anagram.new('master')\n    anagrams = detector.match(['stream', 'pigeon', 'maters'])\n    assert_equal ['maters', 'stream'], anagrams.sort\n  end\n\n  def test_does_not_confuse_different_duplicates\n    skip\n    detector = Anagram.new('galea')\n    assert_equal [], detector.match(['eagle'])\n  end\n\n  def test_identical_word_is_not_anagram\n    skip\n    detector = Anagram.new('corn')\n    anagrams = detector.match %w(corn dark Corn rank CORN cron park)\n    assert_equal ['cron'], anagrams\n  end\n\n  def test_eliminate_anagrams_with_same_checksum\n    skip\n    detector = Anagram.new('mass')\n    assert_equal [], detector.match(['last'])\n  end\n\n  def test_eliminate_anagram_subsets\n    skip\n    detector = Anagram.new('good')\n    assert_equal [], detector.match(['dog', 'goody'])\n  end\n\n  def test_detect_anagram\n    skip\n    detector = Anagram.new('listen')\n    anagrams = detector.match %w(enlists google inlets banana)\n    assert_equal ['inlets'], anagrams\n  end\n\n  def test_multiple_anagrams\n    skip\n    detector = Anagram.new('allergy')\n    anagrams = detector.match %w(gallery ballerina regally clergy largely leading)\n    assert_equal ['gallery', 'largely', 'regally'], anagrams.sort\n  end\n\n  def test_anagrams_are_case_insensitive\n    skip\n    detector = Anagram.new('Orchestra')\n    anagrams = detector.match %w(cashregister Carthorse radishes)\n    assert_equal ['Carthorse'], anagrams\n  end\nend\n",
        "README.md": "# Anagram\n\nWrite a program that, given a word and a list of possible anagrams, selects the correct sublist.\n\nGiven `\"listen\"` and a list of candidates like `\"enlists\" \"google\"\n\"inlets\" \"banana\"` the program should return a list containing\n`\"inlets\"`.\n\n\n## Source\n\nInspired by the Extreme Startup game [view source](https://github.com/rchatley/extreme_startup)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/word-count",
      "track_id": "ruby",
      "language": "ruby",
      "slug": "word-count",
      "name": "Word Count",
      "files": {
        "word_count_test.rb": "require 'minitest/autorun'\nrequire_relative 'phrase'\n\nclass PhraseTest < MiniTest::Unit::TestCase\n\n  def test_count_one_word\n    phrase = Phrase.new(\"word\")\n    counts = {\"word\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_one_of_each\n    skip\n    phrase = Phrase.new(\"one of each\")\n    counts = {\"one\" => 1, \"of\" => 1, \"each\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_multiple_occurrences\n    skip\n    phrase = Phrase.new(\"one fish two fish red fish blue fish\")\n    counts = {\"one\" => 1, \"fish\" => 4, \"two\" => 1, \"red\" => 1, \"blue\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_everything_just_once\n    skip\n    phrase = Phrase.new(\"all the kings horses and all the kings men\")\n    phrase.word_count # count it an extra time\n    counts = {\n      \"all\" => 2, \"the\" => 2, \"kings\" => 2, \"horses\" => 1, \"and\" => 1, \"men\" => 1\n    }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_ignore_punctuation\n    skip\n    phrase = Phrase.new(\"car : carpet as java : javascript!!&@$%^&\")\n    counts = {\"car\" => 1, \"carpet\" => 1, \"as\" => 1, \"java\" => 1, \"javascript\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_handles_cramped_lists\n    skip\n    phrase = Phrase.new(\"one,two,three\")\n    counts = {\"one\" => 1, \"two\" => 1, \"three\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_include_numbers\n    skip\n    phrase = Phrase.new(\"testing, 1, 2 testing\")\n    counts = {\"testing\" => 2, \"1\" => 1, \"2\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_normalize_case\n    skip\n    phrase = Phrase.new(\"go Go GO\")\n    counts = {\"go\" => 3}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_with_apostrophes\n    skip\n    phrase = Phrase.new(\"First: don't laugh. Then: don't cry.\")\n    counts = {\"first\"=>1, \"don't\"=>2, \"laugh\"=>1, \"then\"=>1, \"cry\"=>1}\n    assert_equal counts, phrase.word_count\n  end\nend\n",
        "README.md": "# Word Count\n\nWrite a program that given a phrase can count the occurrences of each word in that phrase.\n\nFor example for the input `\"olly olly in come free\"`\n\n```plain\nolly: 2\nin: 1\ncome: 1\nfree: 1\n```\n\n\n\n## Source\n\nThe golang tour [view source](http://tour.golang.org)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/hamming",
      "track_id": "ruby",
      "language": "ruby",
      "slug": "hamming",
      "name": "Hamming",
      "files": {
        "hamming_test.rb": "require 'minitest/autorun'\nrequire_relative 'hamming'\n\nclass HammingTest < MiniTest::Unit::TestCase\n  def test_no_difference_between_identical_strands\n    assert_equal 0, Hamming.compute('A', 'A')\n  end\n\n  def test_complete_hamming_distance_of_for_single_nucleotide_strand\n    skip\n    assert_equal 1, Hamming.compute('A','G')\n  end\n\n  def test_complete_hamming_distance_of_for_small_strand\n    skip\n    assert_equal 2, Hamming.compute('AG','CT')\n  end\n\n  def test_small_hamming_distance\n    skip\n    assert_equal 1, Hamming.compute('AT','CT')\n  end\n\n  def test_small_hamming_distance_in_longer_strand\n    skip\n    assert_equal 1, Hamming.compute('GGACG', 'GGTCG')\n  end\n\n  def test_ignores_extra_length_on_first_strand_when_longer\n    skip\n    assert_equal 1, Hamming.compute('AGAGACTTA', 'AAA')\n  end\n\n  def test_ignores_extra_length_on_other_strand_when_longer\n    skip\n    assert_equal 2, Hamming.compute('AGG', 'AAAACTGACCCACCCCAGG')\n  end\n\n  def test_large_hamming_distance\n    skip\n    assert_equal 4, Hamming.compute('GATACA', 'GCATAA')\n  end\n\n  def test_hamming_distance_in_very_long_strand\n    skip\n    assert_equal 9, Hamming.compute('GGACGGATTCTG', 'AGGACGGATTCT')\n  end\nend\n",
        "README.md": "# Hamming\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
      },
      "fresh": true
    },
    {
      "id": "scala/bob",
      "track_id": "scala",
      "language": "scala",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "build.sbt": "scalaVersion := \"2.10.3\"\n\nlibraryDependencies += \"org.scalatest\" % \"scalatest_2.10\" % \"2.0\" % \"test\"\n",
        "src/test/scala/bob_test.scala": "import org.scalatest._\n\nclass BobSpecs extends FlatSpec with Matchers {\n  def teenager = new Bob\n\n  it should \"respond to a statement\" in {\n    val response = teenager.hey(\"Tom-ay-to, tom-aaaah-to.\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"respond to shouting\" in {\n    pending\n    val response = teenager.hey(\"WATCH OUT!\")\n    response should be (\"Whoa, chill out!\")\n  }\n\n  it should \"respond to questions\" in {\n    pending\n    val response = teenager.hey(\"Does this cryogenic chamber make me look fat?\")\n    response should be (\"Sure.\")\n  }\n\n  it should \"allow questions to end with numbers\" in {\n    pending\n    val response = teenager.hey(\"You are what, like 15?\")\n    response should be (\"Sure.\")\n  }\n\n  it should \"respond to talking forcefully\" in {\n    pending\n    val response = teenager.hey(\"Let's go work out at the gym!\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"allow acroynms in regular speech\" in {\n    pending\n    val response = teenager.hey(\"It's OK if you don't want to go to the DMV.\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"see forceful questions as shouting\" in {\n    pending\n    val response = teenager.hey(\"WHAT THE HELL WERE YOU THINKING?\")\n    response should be (\"Whoa, chill out!\")\n  }\n\n  it should \"allow numbers when shouting\" in {\n    pending\n    val response = teenager.hey(\"1, 2, 3, GO!\")\n    response should be (\"Whoa, chill out!\")\n  }\n\n  it should \"see only numbers as speech\" in {\n    pending\n    val response = teenager.hey(\"1, 2, 3\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"respond to questions with only numbers\" in {\n    pending\n    val response = teenager.hey(\"4?\")\n    response should be (\"Sure.\")\n  }\n\n  it should \"respond to shouting with no exclamation mark\" in {\n    pending\n    val response = teenager.hey(\"I HATE YOU\")\n    response should be (\"Whoa, chill out!\")\n  }\n\n  it should \"respond to statements with ? in the middle\" in {\n    pending\n    val response = teenager.hey(\"Ending with ? means a question.\")\n    response should be (\"Whatever.\")\n  }\n\n  it should \"respond to prattling on\" in {\n    pending\n    val response = teenager.hey(\"Wait! Hang on. Are you going to be OK?\")\n    response should be (\"Sure.\")\n  }\n\n  it should \"respond to silence\" in {\n    pending\n    val response = teenager.hey(\"\")\n    response should be (\"Fine. Be that way!\")\n  }\n\n  it should \"respond to prolonged silence\" in {\n    pending\n    val response = teenager.hey(\"       \")\n    response should be (\"Fine. Be that way!\")\n  }\n\n  it should \"respond to multiple line questions\" in {\n    pending\n    val response = teenager.hey(\"\"\"\nDoes this cryogenic chamber make me look fat?\nno\"\"\")\n    response should be (\"Whatever.\")\n  }\n}\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": true
    },
    {
      "id": "swift/leap",
      "track_id": "swift",
      "language": "swift",
      "slug": "leap",
      "name": "Leap",
      "files": {
        "LeapTest.swift": "import XCTest\n\nclass LeapTest : XCTestCase {\n\n\tfunc testVanillaLeapYear() {\n\t  let year = Year(calendarYear: 1996)\n\t  XCTAssertTrue(year.isLeapYear);\n\t}\n\n\tfunc testAnyOldYear() {\n\t  let year = Year(calendarYear: 1997)\n\t  XCTAssertTrue(!year.isLeapYear);\n\t}\n\n\tfunc testCentury() {\n\t  let year = Year(calendarYear: 1900)\n\t  XCTAssertTrue(!year.isLeapYear);\n\t}\n\n\tfunc testExceptionalCentury() {\n\t  let year = Year(calendarYear: 2400)\n\t  XCTAssertTrue(year.isLeapYear);\n\t}\n\n}",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": true
    }
  ]
}
